/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    BaseContract,
    BigNumber,
    BigNumberish,
    BytesLike,
    CallOverrides,
    ContractTransaction,
    Overrides,
    PopulatedTransaction,
    Signer,
    utils,
} from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import { OnEvent, PromiseOrValue, TypedEvent, TypedEventFilter, TypedListener } from "./typechain/common";

export type CollateralAssetStruct = {
    factor: FixedPoint.UnsignedStruct;
    oracle: PromiseOrValue<string>;
    underlyingRebasingToken: PromiseOrValue<string>;
    decimals: PromiseOrValue<BigNumberish>;
    exists: PromiseOrValue<boolean>;
};

export type CollateralAssetStructOutput = [FixedPoint.UnsignedStructOutput, string, string, number, boolean] & {
    factor: FixedPoint.UnsignedStructOutput;
    oracle: string;
    underlyingRebasingToken: string;
    decimals: number;
    exists: boolean;
};

export type KrAssetStruct = {
    kFactor: FixedPoint.UnsignedStruct;
    oracle: PromiseOrValue<string>;
    supplyLimit: PromiseOrValue<BigNumberish>;
    mintable: PromiseOrValue<boolean>;
    exists: PromiseOrValue<boolean>;
};

export type KrAssetStructOutput = [FixedPoint.UnsignedStructOutput, string, BigNumber, BigNumber, boolean, boolean] & {
    kFactor: FixedPoint.UnsignedStructOutput;
    oracle: string;
    supplyLimit: BigNumber;
    closeFee: BigNumber;
    mintable: boolean;
    exists: boolean;
};

export type MinterParamsStruct = {
    burnfee: FixedPoint.UnsignedStruct;
    minimumCollateralizationRatio: FixedPoint.UnsignedStruct;
    liquidationIncentiveMultiplier: FixedPoint.UnsignedStruct;
    minimumDebtValue: FixedPoint.UnsignedStruct;
    secondsUntilStalePrice: PromiseOrValue<BigNumberish>;
    feeRecipient: PromiseOrValue<string>;
};

export type MinterParamsStructOutput = [
    FixedPoint.UnsignedStructOutput,
    FixedPoint.UnsignedStructOutput,
    FixedPoint.UnsignedStructOutput,
    FixedPoint.UnsignedStructOutput,
    BigNumber,
    string,
] & {
    burnfee: FixedPoint.UnsignedStructOutput;
    minimumCollateralizationRatio: FixedPoint.UnsignedStructOutput;
    liquidationIncentiveMultiplier: FixedPoint.UnsignedStructOutput;
    minimumDebtValue: FixedPoint.UnsignedStructOutput;
    secondsUntilStalePrice: BigNumber;
    feeRecipient: string;
};

export type MinterInitArgsStruct = {
    operator: PromiseOrValue<string>;
    council: PromiseOrValue<string>;
    burnFee: PromiseOrValue<BigNumberish>;
    feeRecipient: PromiseOrValue<string>;
    liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>;
    minimumCollateralizationRatio: PromiseOrValue<BigNumberish>;
    minimumDebtValue: PromiseOrValue<BigNumberish>;
    secondsUntilStalePrice: PromiseOrValue<BigNumberish>;
};

export type MinterInitArgsStructOutput = [
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
] & {
    operator: string;
    council: string;
    burnFee: BigNumber;
    feeRecipient: string;
    liquidationIncentiveMultiplier: BigNumber;
    minimumCollateralizationRatio: BigNumber;
    minimumDebtValue: BigNumber;
    secondsUntilStalePrice: BigNumber;
};

export type PauseStruct = {
    enabled: PromiseOrValue<boolean>;
    timestamp0: PromiseOrValue<BigNumberish>;
    timestamp1: PromiseOrValue<BigNumberish>;
};

export type PauseStructOutput = [boolean, BigNumber, BigNumber] & {
    enabled: boolean;
    timestamp0: BigNumber;
    timestamp1: BigNumber;
};

export type SafetyStateStruct = { pause: PauseStruct };

export type SafetyStateStructOutput = [PauseStructOutput] & {
    pause: PauseStructOutput;
};

export declare namespace IDiamondCut {
    export type FacetCutStruct = {
        facetAddress: PromiseOrValue<string>;
        action: PromiseOrValue<BigNumberish>;
        functionSelectors: PromiseOrValue<BytesLike>[];
    };

    export type FacetCutStructOutput = [string, number, string[]] & {
        facetAddress: string;
        action: number;
        functionSelectors: string[];
    };
}

export declare namespace IDiamondLoupe {
    export type FacetStruct = {
        facetAddress: PromiseOrValue<string>;
        functionSelectors: PromiseOrValue<BytesLike>[];
    };

    export type FacetStructOutput = [string, string[]] & {
        facetAddress: string;
        functionSelectors: string[];
    };
}

export declare namespace FixedPoint {
    export type UnsignedStruct = { rawValue: PromiseOrValue<BigNumberish> };

    export type UnsignedStructOutput = [BigNumber] & { rawValue: BigNumber };
}

export interface KreskoInterface extends utils.Interface {
    functions: {
        "getRoleAdmin(bytes32)": FunctionFragment;
        "getRoleMember(bytes32,uint256)": FunctionFragment;
        "getRoleMemberCount(bytes32)": FunctionFragment;
        "grantRole(bytes32,address)": FunctionFragment;
        "hasRole(bytes32,address)": FunctionFragment;
        "renounceRole(bytes32,address)": FunctionFragment;
        "revokeRole(bytes32,address)": FunctionFragment;
        "diamondCut((address,uint8,bytes4[])[],address,bytes)": FunctionFragment;
        "upgradeState(address,bytes)": FunctionFragment;
        "facetAddress(bytes4)": FunctionFragment;
        "facetAddresses()": FunctionFragment;
        "facetFunctionSelectors(address)": FunctionFragment;
        "facets()": FunctionFragment;
        "acceptOwnership()": FunctionFragment;
        "initialized()": FunctionFragment;
        "owner()": FunctionFragment;
        "pendingOwner()": FunctionFragment;
        "transferOwnership(address)": FunctionFragment;
        "setERC165(bytes4[],bytes4[])": FunctionFragment;
        "supportsInterface(bytes4)": FunctionFragment;
        "assetActionPaused(uint8,address)": FunctionFragment;
        "collateralAsset(address)": FunctionFragment;
        "collateralDeposits(address,address)": FunctionFragment;
        "collateralExists(address)": FunctionFragment;
        "getAccountCollateralValue(address)": FunctionFragment;
        "getAccountKrAssetValue(address)": FunctionFragment;
        "getAccountMinimumCollateralValue(address)": FunctionFragment;
        "getCollateralRatiosFor(address[])": FunctionFragment;
        "getCollateralValueAndOraclePrice(address,uint256,bool)": FunctionFragment;
        "getDepositedCollateralAssetIndex(address,address)": FunctionFragment;
        "getDepositedCollateralAssets(address)": FunctionFragment;
        "getKrAssetValue(address,uint256,bool)": FunctionFragment;
        "getMintedKreskoAssets(address)": FunctionFragment;
        "getMintedKreskoAssetsIndex(address,address)": FunctionFragment;
        "krAssetExists(address)": FunctionFragment;
        "kreskoAsset(address)": FunctionFragment;
        "kreskoAssetDebt(address,address)": FunctionFragment;
        "burnFee()": FunctionFragment;
        "domainSeparator()": FunctionFragment;
        "feeRecipient()": FunctionFragment;
        "getAllParams()": FunctionFragment;
        "liquidationIncentiveMultiplier()": FunctionFragment;
        "minimumCollateralizationRatio()": FunctionFragment;
        "minimumDebtValue()": FunctionFragment;
        "minterInitializations()": FunctionFragment;
        "secondsUntilStalePrice()": FunctionFragment;
        "calculateMaxLiquidatableValueForAssets(address,address,address)": FunctionFragment;
        "isAccountLiquidatable(address)": FunctionFragment;
        "liquidate(address,address,uint256,address,uint256,uint256)": FunctionFragment;
        "addCollateralAsset(address,uint256,address)": FunctionFragment;
        "addKreskoAsset(address,uint256,address,uint256)": FunctionFragment;
        "initialize((address,address,uint256,address,uint256,uint256,uint256,uint256))": FunctionFragment;
        "updateBurnFee(uint256)": FunctionFragment;
        "updateCollateralAsset(address,uint256,address)": FunctionFragment;
        "updateFeeRecipient(address)": FunctionFragment;
        "updateKreskoAsset(address,uint256,address,bool,uint256)": FunctionFragment;
        "updateLiquidationIncentiveMultiplier(uint256)": FunctionFragment;
        "updateMinimumCollateralizationRatio(uint256)": FunctionFragment;
        "updateMinimumDebtValue(uint256)": FunctionFragment;
        "updateSecondsUntilStalePrice(uint256)": FunctionFragment;
        "safetyStateFor(address,uint8)": FunctionFragment;
        "safetyStateSet()": FunctionFragment;
        "toggleAssetsPaused(address[],uint8,bool,uint256)": FunctionFragment;
        "burnKreskoAsset(address,address,uint256,uint256)": FunctionFragment;
        "depositCollateral(address,address,uint256)": FunctionFragment;
        "mintKreskoAsset(address,address,uint256)": FunctionFragment;
        "withdrawCollateral(address,address,uint256,uint256)": FunctionFragment;
    };

    getFunction(
        nameOrSignatureOrTopic:
            | "getRoleAdmin"
            | "getRoleMember"
            | "getRoleMemberCount"
            | "grantRole"
            | "hasRole"
            | "renounceRole"
            | "revokeRole"
            | "diamondCut"
            | "upgradeState"
            | "facetAddress"
            | "facetAddresses"
            | "facetFunctionSelectors"
            | "facets"
            | "acceptOwnership"
            | "initialized"
            | "owner"
            | "pendingOwner"
            | "transferOwnership"
            | "setERC165"
            | "supportsInterface"
            | "assetActionPaused"
            | "collateralAsset"
            | "collateralDeposits"
            | "collateralExists"
            | "getAccountCollateralValue"
            | "getAccountKrAssetValue"
            | "getAccountMinimumCollateralValue"
            | "getCollateralRatiosFor"
            | "getCollateralValueAndOraclePrice"
            | "getDepositedCollateralAssetIndex"
            | "getDepositedCollateralAssets"
            | "getKrAssetValue"
            | "getMintedKreskoAssets"
            | "getMintedKreskoAssetsIndex"
            | "krAssetExists"
            | "kreskoAsset"
            | "kreskoAssetDebt"
            | "burnFee"
            | "domainSeparator"
            | "feeRecipient"
            | "getAllParams"
            | "liquidationIncentiveMultiplier"
            | "minimumCollateralizationRatio"
            | "minimumDebtValue"
            | "minterInitializations"
            | "secondsUntilStalePrice"
            | "calculateMaxLiquidatableValueForAssets"
            | "isAccountLiquidatable"
            | "liquidate"
            | "addCollateralAsset"
            | "addKreskoAsset"
            | "initialize"
            | "updateBurnFee"
            | "updateCollateralAsset"
            | "updateFeeRecipient"
            | "updateKreskoAsset"
            | "updateLiquidationIncentiveMultiplier"
            | "updateMinimumCollateralizationRatio"
            | "updateMinimumDebtValue"
            | "updateSecondsUntilStalePrice"
            | "safetyStateFor"
            | "safetyStateSet"
            | "toggleAssetsPaused"
            | "burnKreskoAsset"
            | "depositCollateral"
            | "mintKreskoAsset"
            | "withdrawCollateral",
    ): FunctionFragment;

    encodeFunctionData(functionFragment: "getRoleAdmin", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(
        functionFragment: "getRoleMember",
        values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(functionFragment: "getRoleMemberCount", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(
        functionFragment: "grantRole",
        values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(
        functionFragment: "hasRole",
        values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(
        functionFragment: "renounceRole",
        values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(
        functionFragment: "revokeRole",
        values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(
        functionFragment: "diamondCut",
        values: [IDiamondCut.FacetCutStruct[], PromiseOrValue<string>, PromiseOrValue<BytesLike>],
    ): string;
    encodeFunctionData(
        functionFragment: "upgradeState",
        values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>],
    ): string;
    encodeFunctionData(functionFragment: "facetAddress", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(functionFragment: "facetAddresses", values?: undefined): string;
    encodeFunctionData(functionFragment: "facetFunctionSelectors", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "facets", values?: undefined): string;
    encodeFunctionData(functionFragment: "acceptOwnership", values?: undefined): string;
    encodeFunctionData(functionFragment: "initialized", values?: undefined): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "pendingOwner", values?: undefined): string;
    encodeFunctionData(functionFragment: "transferOwnership", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "setERC165",
        values: [PromiseOrValue<BytesLike>[], PromiseOrValue<BytesLike>[]],
    ): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [PromiseOrValue<BytesLike>]): string;
    encodeFunctionData(
        functionFragment: "assetActionPaused",
        values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "collateralAsset", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "collateralDeposits",
        values: [PromiseOrValue<string>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "collateralExists", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getAccountCollateralValue", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getAccountKrAssetValue", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getAccountMinimumCollateralValue", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "getCollateralRatiosFor", values: [PromiseOrValue<string>[]]): string;
    encodeFunctionData(
        functionFragment: "getCollateralValueAndOraclePrice",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
    ): string;
    encodeFunctionData(
        functionFragment: "getDepositedCollateralAssetIndex",
        values: [PromiseOrValue<string>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "getDepositedCollateralAssets", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "getKrAssetValue",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>],
    ): string;
    encodeFunctionData(functionFragment: "getMintedKreskoAssets", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "getMintedKreskoAssetsIndex",
        values: [PromiseOrValue<string>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "krAssetExists", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "kreskoAsset", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "kreskoAssetDebt",
        values: [PromiseOrValue<string>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "burnFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "domainSeparator", values?: undefined): string;
    encodeFunctionData(functionFragment: "feeRecipient", values?: undefined): string;
    encodeFunctionData(functionFragment: "getAllParams", values?: undefined): string;
    encodeFunctionData(functionFragment: "liquidationIncentiveMultiplier", values?: undefined): string;
    encodeFunctionData(functionFragment: "minimumCollateralizationRatio", values?: undefined): string;
    encodeFunctionData(functionFragment: "minimumDebtValue", values?: undefined): string;
    encodeFunctionData(functionFragment: "minterInitializations", values?: undefined): string;
    encodeFunctionData(functionFragment: "secondsUntilStalePrice", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "calculateMaxLiquidatableValueForAssets",
        values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "isAccountLiquidatable", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "liquidate",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "addCollateralAsset",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(
        functionFragment: "addKreskoAsset",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;
    encodeFunctionData(functionFragment: "initialize", values: [MinterInitArgsStruct]): string;
    encodeFunctionData(functionFragment: "updateBurnFee", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(
        functionFragment: "updateCollateralAsset",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
    ): string;
    encodeFunctionData(functionFragment: "updateFeeRecipient", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(
        functionFragment: "updateKreskoAsset",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<string>,
            PromiseOrValue<boolean>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "updateLiquidationIncentiveMultiplier",
        values: [PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(
        functionFragment: "updateMinimumCollateralizationRatio",
        values: [PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(functionFragment: "updateMinimumDebtValue", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(
        functionFragment: "updateSecondsUntilStalePrice",
        values: [PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(
        functionFragment: "safetyStateFor",
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(functionFragment: "safetyStateSet", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "toggleAssetsPaused",
        values: [
            PromiseOrValue<string>[],
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<boolean>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "burnKreskoAsset",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "depositCollateral",
        values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(
        functionFragment: "mintKreskoAsset",
        values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
    ): string;
    encodeFunctionData(
        functionFragment: "withdrawCollateral",
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
        ],
    ): string;

    decodeFunctionResult(functionFragment: "getRoleAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMember", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "diamondCut", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "upgradeState", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetAddresses", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facetFunctionSelectors", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "facets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "acceptOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialized", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pendingOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setERC165", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "assetActionPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collateralAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collateralDeposits", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collateralExists", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAccountCollateralValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAccountKrAssetValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAccountMinimumCollateralValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCollateralRatiosFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCollateralValueAndOraclePrice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDepositedCollateralAssetIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDepositedCollateralAssets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getKrAssetValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMintedKreskoAssets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getMintedKreskoAssetsIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "krAssetExists", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "kreskoAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "kreskoAssetDebt", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "burnFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "domainSeparator", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "feeRecipient", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getAllParams", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "liquidationIncentiveMultiplier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "minimumCollateralizationRatio", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "minimumDebtValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "minterInitializations", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "secondsUntilStalePrice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateMaxLiquidatableValueForAssets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAccountLiquidatable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addCollateralAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addKreskoAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateBurnFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateCollateralAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateFeeRecipient", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateKreskoAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateLiquidationIncentiveMultiplier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateMinimumCollateralizationRatio", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateMinimumDebtValue", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "updateSecondsUntilStalePrice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safetyStateFor", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "safetyStateSet", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "toggleAssetsPaused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "burnKreskoAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositCollateral", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mintKreskoAsset", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawCollateral", data: BytesLike): Result;

    events: {
        "DiamondCut(tuple[],address,bytes)": EventFragment;
        "OwnershipTransferred(address,address)": EventFragment;
        "PendingOwnershipTransfer(address,address)": EventFragment;
    };

    getEvent(nameOrSignatureOrTopic: "DiamondCut"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PendingOwnershipTransfer"): EventFragment;
}

export interface DiamondCutEventObject {
    _diamondCut: IDiamondCut.FacetCutStructOutput[];
    _init: string;
    _calldata: string;
}
export type DiamondCutEvent = TypedEvent<[IDiamondCut.FacetCutStructOutput[], string, string], DiamondCutEventObject>;

export type DiamondCutEventFilter = TypedEventFilter<DiamondCutEvent>;

export interface OwnershipTransferredEventObject {
    previousOwner: string;
    newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PendingOwnershipTransferEventObject {
    previousOwner: string;
    newOwner: string;
}
export type PendingOwnershipTransferEvent = TypedEvent<[string, string], PendingOwnershipTransferEventObject>;

export type PendingOwnershipTransferEventFilter = TypedEventFilter<PendingOwnershipTransferEvent>;

export interface Kresko extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;

    interface: KreskoInterface;

    queryFilter<TEvent extends TypedEvent>(
        event: TypedEventFilter<TEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined,
    ): Promise<Array<TEvent>>;

    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;

    functions: {
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

        getRoleMember(
            role: PromiseOrValue<BytesLike>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<[string]>;

        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;

        grantRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        hasRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[boolean]>;

        renounceRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        revokeRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        diamondCut(
            _diamondCut: IDiamondCut.FacetCutStruct[],
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        upgradeState(
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        facetAddress(
            _functionSelector: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides,
        ): Promise<[string] & { facetAddress_: string }>;

        facetAddresses(overrides?: CallOverrides): Promise<[string[]] & { facetAddresses_: string[] }>;

        facetFunctionSelectors(
            _facet: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[string[]] & { facetFunctionSelectors_: string[] }>;

        facets(overrides?: CallOverrides): Promise<
            [IDiamondLoupe.FacetStructOutput[]] & {
                facets_: IDiamondLoupe.FacetStructOutput[];
            }
        >;

        acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

        initialized(overrides?: CallOverrides): Promise<[boolean]>;

        owner(overrides?: CallOverrides): Promise<[string]>;

        pendingOwner(overrides?: CallOverrides): Promise<[string]>;

        transferOwnership(
            _newOwner: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        setERC165(
            interfaceIds: PromiseOrValue<BytesLike>[],
            interfaceIdsToRemove: PromiseOrValue<BytesLike>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        supportsInterface(_interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;

        assetActionPaused(
            _action: PromiseOrValue<BigNumberish>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[boolean]>;

        collateralAsset(
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[CollateralAssetStructOutput]>;

        collateralDeposits(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[BigNumber]>;

        collateralExists(_collateralAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

        getAccountCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput]>;

        getAccountKrAssetValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput]>;

        getAccountMinimumCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput]>;

        getCollateralRatiosFor(
            _accounts: PromiseOrValue<string>[],
            overrides?: CallOverrides,
        ): Promise<
            [FixedPoint.UnsignedStructOutput[]] & {
                ratios: FixedPoint.UnsignedStructOutput[];
            }
        >;

        getCollateralValueAndOraclePrice(
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreCollateralFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput, FixedPoint.UnsignedStructOutput]>;

        getDepositedCollateralAssetIndex(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[BigNumber] & { i: BigNumber }>;

        getDepositedCollateralAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

        getKrAssetValue(
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreKFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput]>;

        getMintedKreskoAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

        getMintedKreskoAssetsIndex(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[BigNumber]>;

        krAssetExists(_krAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

        kreskoAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[KrAssetStructOutput]>;

        kreskoAssetDebt(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<[BigNumber]>;

        burnFee(overrides?: CallOverrides): Promise<[FixedPoint.UnsignedStructOutput]>;

        domainSeparator(overrides?: CallOverrides): Promise<[string]>;

        feeRecipient(overrides?: CallOverrides): Promise<[string]>;

        getAllParams(overrides?: CallOverrides): Promise<[MinterParamsStructOutput]>;

        liquidationIncentiveMultiplier(overrides?: CallOverrides): Promise<[FixedPoint.UnsignedStructOutput]>;

        minimumCollateralizationRatio(overrides?: CallOverrides): Promise<[FixedPoint.UnsignedStructOutput]>;

        minimumDebtValue(overrides?: CallOverrides): Promise<[FixedPoint.UnsignedStructOutput]>;

        minterInitializations(overrides?: CallOverrides): Promise<[BigNumber]>;

        secondsUntilStalePrice(overrides?: CallOverrides): Promise<[BigNumber]>;

        calculateMaxLiquidatableValueForAssets(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<
            [FixedPoint.UnsignedStructOutput] & {
                maxLiquidatableUSD: FixedPoint.UnsignedStructOutput;
            }
        >;

        isAccountLiquidatable(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

        liquidate(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _repayAmount: PromiseOrValue<BigNumberish>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        addCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        addKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        initialize(
            args: MinterInitArgsStruct,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateBurnFee(
            _burnFee: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateFeeRecipient(
            _feeRecipient: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _mintable: PromiseOrValue<boolean>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateLiquidationIncentiveMultiplier(
            _liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateMinimumCollateralizationRatio(
            _minimumCollateralizationRatio: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateMinimumDebtValue(
            _minimumDebtValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        updateSecondsUntilStalePrice(
            _secondsUntilStalePrice: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        safetyStateFor(
            _asset: PromiseOrValue<string>,
            _action: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<[SafetyStateStructOutput]>;

        safetyStateSet(overrides?: CallOverrides): Promise<[boolean]>;

        toggleAssetsPaused(
            _assets: PromiseOrValue<string>[],
            _action: PromiseOrValue<BigNumberish>,
            _withDuration: PromiseOrValue<boolean>,
            _duration: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        burnKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        depositCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        mintKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;

        withdrawCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<ContractTransaction>;
    };

    getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    getRoleMember(
        role: PromiseOrValue<BytesLike>,
        index: PromiseOrValue<BigNumberish>,
        overrides?: CallOverrides,
    ): Promise<string>;

    getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    grantRole(
        role: PromiseOrValue<BytesLike>,
        account: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    hasRole(
        role: PromiseOrValue<BytesLike>,
        account: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<boolean>;

    renounceRole(
        role: PromiseOrValue<BytesLike>,
        account: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    revokeRole(
        role: PromiseOrValue<BytesLike>,
        account: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    diamondCut(
        _diamondCut: IDiamondCut.FacetCutStruct[],
        _init: PromiseOrValue<string>,
        _calldata: PromiseOrValue<BytesLike>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    upgradeState(
        _init: PromiseOrValue<string>,
        _calldata: PromiseOrValue<BytesLike>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    facetAddress(_functionSelector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    facetAddresses(overrides?: CallOverrides): Promise<string[]>;

    facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    facets(overrides?: CallOverrides): Promise<IDiamondLoupe.FacetStructOutput[]>;

    acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    initialized(overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
        _newOwner: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setERC165(
        interfaceIds: PromiseOrValue<BytesLike>[],
        interfaceIdsToRemove: PromiseOrValue<BytesLike>[],
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supportsInterface(_interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

    assetActionPaused(
        _action: PromiseOrValue<BigNumberish>,
        _asset: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<boolean>;

    collateralAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<CollateralAssetStructOutput>;

    collateralDeposits(
        _account: PromiseOrValue<string>,
        _asset: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<BigNumber>;

    collateralExists(_collateralAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    getAccountCollateralValue(
        _account: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput>;

    getAccountKrAssetValue(
        _account: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput>;

    getAccountMinimumCollateralValue(
        _account: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput>;

    getCollateralRatiosFor(
        _accounts: PromiseOrValue<string>[],
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput[]>;

    getCollateralValueAndOraclePrice(
        _collateralAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        _ignoreCollateralFactor: PromiseOrValue<boolean>,
        overrides?: CallOverrides,
    ): Promise<[FixedPoint.UnsignedStructOutput, FixedPoint.UnsignedStructOutput]>;

    getDepositedCollateralAssetIndex(
        _account: PromiseOrValue<string>,
        _collateralAsset: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getDepositedCollateralAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    getKrAssetValue(
        _kreskoAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        _ignoreKFactor: PromiseOrValue<boolean>,
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput>;

    getMintedKreskoAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    getMintedKreskoAssetsIndex(
        _account: PromiseOrValue<string>,
        _kreskoAsset: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<BigNumber>;

    krAssetExists(_krAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    kreskoAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<KrAssetStructOutput>;

    kreskoAssetDebt(
        _account: PromiseOrValue<string>,
        _asset: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<BigNumber>;

    burnFee(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

    domainSeparator(overrides?: CallOverrides): Promise<string>;

    feeRecipient(overrides?: CallOverrides): Promise<string>;

    getAllParams(overrides?: CallOverrides): Promise<MinterParamsStructOutput>;

    liquidationIncentiveMultiplier(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

    minimumCollateralizationRatio(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

    minimumDebtValue(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

    minterInitializations(overrides?: CallOverrides): Promise<BigNumber>;

    secondsUntilStalePrice(overrides?: CallOverrides): Promise<BigNumber>;

    calculateMaxLiquidatableValueForAssets(
        _account: PromiseOrValue<string>,
        _repayKreskoAsset: PromiseOrValue<string>,
        _collateralAssetToSeize: PromiseOrValue<string>,
        overrides?: CallOverrides,
    ): Promise<FixedPoint.UnsignedStructOutput>;

    isAccountLiquidatable(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    liquidate(
        _account: PromiseOrValue<string>,
        _repayKreskoAsset: PromiseOrValue<string>,
        _repayAmount: PromiseOrValue<BigNumberish>,
        _collateralAssetToSeize: PromiseOrValue<string>,
        _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
        _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addCollateralAsset(
        _collateralAsset: PromiseOrValue<string>,
        _factor: PromiseOrValue<BigNumberish>,
        _oracle: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addKreskoAsset(
        _kreskoAsset: PromiseOrValue<string>,
        _kFactor: PromiseOrValue<BigNumberish>,
        _oracle: PromiseOrValue<string>,
        _supplyLimit: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initialize(
        args: MinterInitArgsStruct,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateBurnFee(
        _burnFee: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateCollateralAsset(
        _collateralAsset: PromiseOrValue<string>,
        _factor: PromiseOrValue<BigNumberish>,
        _oracle: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateFeeRecipient(
        _feeRecipient: PromiseOrValue<string>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateKreskoAsset(
        _kreskoAsset: PromiseOrValue<string>,
        _kFactor: PromiseOrValue<BigNumberish>,
        _oracle: PromiseOrValue<string>,
        _mintable: PromiseOrValue<boolean>,
        _supplyLimit: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateLiquidationIncentiveMultiplier(
        _liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinimumCollateralizationRatio(
        _minimumCollateralizationRatio: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateMinimumDebtValue(
        _minimumDebtValue: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    updateSecondsUntilStalePrice(
        _secondsUntilStalePrice: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    safetyStateFor(
        _asset: PromiseOrValue<string>,
        _action: PromiseOrValue<BigNumberish>,
        overrides?: CallOverrides,
    ): Promise<SafetyStateStructOutput>;

    safetyStateSet(overrides?: CallOverrides): Promise<boolean>;

    toggleAssetsPaused(
        _assets: PromiseOrValue<string>[],
        _action: PromiseOrValue<BigNumberish>,
        _withDuration: PromiseOrValue<boolean>,
        _duration: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    burnKreskoAsset(
        _account: PromiseOrValue<string>,
        _kreskoAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    depositCollateral(
        _account: PromiseOrValue<string>,
        _collateralAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    mintKreskoAsset(
        _account: PromiseOrValue<string>,
        _kreskoAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    withdrawCollateral(
        _account: PromiseOrValue<string>,
        _collateralAsset: PromiseOrValue<string>,
        _amount: PromiseOrValue<BigNumberish>,
        _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    callStatic: {
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

        getRoleMember(
            role: PromiseOrValue<BytesLike>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<string>;

        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

        grantRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<void>;

        hasRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<boolean>;

        renounceRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<void>;

        revokeRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<void>;

        diamondCut(
            _diamondCut: IDiamondCut.FacetCutStruct[],
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides,
        ): Promise<void>;

        upgradeState(
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides,
        ): Promise<void>;

        facetAddress(_functionSelector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

        facetAddresses(overrides?: CallOverrides): Promise<string[]>;

        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

        facets(overrides?: CallOverrides): Promise<IDiamondLoupe.FacetStructOutput[]>;

        acceptOwnership(overrides?: CallOverrides): Promise<void>;

        initialized(overrides?: CallOverrides): Promise<boolean>;

        owner(overrides?: CallOverrides): Promise<string>;

        pendingOwner(overrides?: CallOverrides): Promise<string>;

        transferOwnership(_newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

        setERC165(
            interfaceIds: PromiseOrValue<BytesLike>[],
            interfaceIdsToRemove: PromiseOrValue<BytesLike>[],
            overrides?: CallOverrides,
        ): Promise<void>;

        supportsInterface(_interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

        assetActionPaused(
            _action: PromiseOrValue<BigNumberish>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<boolean>;

        collateralAsset(
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<CollateralAssetStructOutput>;

        collateralDeposits(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        collateralExists(_collateralAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

        getAccountCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput>;

        getAccountKrAssetValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput>;

        getAccountMinimumCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput>;

        getCollateralRatiosFor(
            _accounts: PromiseOrValue<string>[],
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput[]>;

        getCollateralValueAndOraclePrice(
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreCollateralFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<[FixedPoint.UnsignedStructOutput, FixedPoint.UnsignedStructOutput]>;

        getDepositedCollateralAssetIndex(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getDepositedCollateralAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

        getKrAssetValue(
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreKFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput>;

        getMintedKreskoAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

        getMintedKreskoAssetsIndex(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        krAssetExists(_krAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

        kreskoAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<KrAssetStructOutput>;

        kreskoAssetDebt(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        burnFee(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

        domainSeparator(overrides?: CallOverrides): Promise<string>;

        feeRecipient(overrides?: CallOverrides): Promise<string>;

        getAllParams(overrides?: CallOverrides): Promise<MinterParamsStructOutput>;

        liquidationIncentiveMultiplier(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

        minimumCollateralizationRatio(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

        minimumDebtValue(overrides?: CallOverrides): Promise<FixedPoint.UnsignedStructOutput>;

        minterInitializations(overrides?: CallOverrides): Promise<BigNumber>;

        secondsUntilStalePrice(overrides?: CallOverrides): Promise<BigNumber>;

        calculateMaxLiquidatableValueForAssets(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<FixedPoint.UnsignedStructOutput>;

        isAccountLiquidatable(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

        liquidate(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _repayAmount: PromiseOrValue<BigNumberish>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        addCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<void>;

        addKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        initialize(args: MinterInitArgsStruct, overrides?: CallOverrides): Promise<void>;

        updateBurnFee(_burnFee: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

        updateCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<void>;

        updateFeeRecipient(_feeRecipient: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

        updateKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _mintable: PromiseOrValue<boolean>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        updateLiquidationIncentiveMultiplier(
            _liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        updateMinimumCollateralizationRatio(
            _minimumCollateralizationRatio: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        updateMinimumDebtValue(
            _minimumDebtValue: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        updateSecondsUntilStalePrice(
            _secondsUntilStalePrice: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        safetyStateFor(
            _asset: PromiseOrValue<string>,
            _action: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<SafetyStateStructOutput>;

        safetyStateSet(overrides?: CallOverrides): Promise<boolean>;

        toggleAssetsPaused(
            _assets: PromiseOrValue<string>[],
            _action: PromiseOrValue<BigNumberish>,
            _withDuration: PromiseOrValue<boolean>,
            _duration: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        burnKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        depositCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        mintKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;

        withdrawCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<void>;
    };

    filters: {
        "DiamondCut(tuple[],address,bytes)"(_diamondCut?: null, _init?: null, _calldata?: null): DiamondCutEventFilter;
        DiamondCut(_diamondCut?: null, _init?: null, _calldata?: null): DiamondCutEventFilter;

        "OwnershipTransferred(address,address)"(
            previousOwner?: PromiseOrValue<string> | null,
            newOwner?: PromiseOrValue<string> | null,
        ): OwnershipTransferredEventFilter;
        OwnershipTransferred(
            previousOwner?: PromiseOrValue<string> | null,
            newOwner?: PromiseOrValue<string> | null,
        ): OwnershipTransferredEventFilter;

        "PendingOwnershipTransfer(address,address)"(
            previousOwner?: PromiseOrValue<string> | null,
            newOwner?: PromiseOrValue<string> | null,
        ): PendingOwnershipTransferEventFilter;
        PendingOwnershipTransfer(
            previousOwner?: PromiseOrValue<string> | null,
            newOwner?: PromiseOrValue<string> | null,
        ): PendingOwnershipTransferEventFilter;
    };

    estimateGas: {
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

        getRoleMember(
            role: PromiseOrValue<BytesLike>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

        grantRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        hasRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        renounceRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        revokeRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        diamondCut(
            _diamondCut: IDiamondCut.FacetCutStruct[],
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        upgradeState(
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        facetAddress(_functionSelector: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

        facetAddresses(overrides?: CallOverrides): Promise<BigNumber>;

        facetFunctionSelectors(_facet: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        facets(overrides?: CallOverrides): Promise<BigNumber>;

        acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

        initialized(overrides?: CallOverrides): Promise<BigNumber>;

        owner(overrides?: CallOverrides): Promise<BigNumber>;

        pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

        transferOwnership(
            _newOwner: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        setERC165(
            interfaceIds: PromiseOrValue<BytesLike>[],
            interfaceIdsToRemove: PromiseOrValue<BytesLike>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        supportsInterface(_interfaceId: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

        assetActionPaused(
            _action: PromiseOrValue<BigNumberish>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        collateralAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        collateralDeposits(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        collateralExists(_collateralAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        getAccountCollateralValue(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        getAccountKrAssetValue(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        getAccountMinimumCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getCollateralRatiosFor(_accounts: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<BigNumber>;

        getCollateralValueAndOraclePrice(
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreCollateralFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getDepositedCollateralAssetIndex(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getDepositedCollateralAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        getKrAssetValue(
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreKFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        getMintedKreskoAssets(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        getMintedKreskoAssetsIndex(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        krAssetExists(_krAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        kreskoAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        kreskoAssetDebt(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        burnFee(overrides?: CallOverrides): Promise<BigNumber>;

        domainSeparator(overrides?: CallOverrides): Promise<BigNumber>;

        feeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

        getAllParams(overrides?: CallOverrides): Promise<BigNumber>;

        liquidationIncentiveMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

        minimumCollateralizationRatio(overrides?: CallOverrides): Promise<BigNumber>;

        minimumDebtValue(overrides?: CallOverrides): Promise<BigNumber>;

        minterInitializations(overrides?: CallOverrides): Promise<BigNumber>;

        secondsUntilStalePrice(overrides?: CallOverrides): Promise<BigNumber>;

        calculateMaxLiquidatableValueForAssets(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        isAccountLiquidatable(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

        liquidate(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _repayAmount: PromiseOrValue<BigNumberish>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        addCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        addKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        initialize(
            args: MinterInitArgsStruct,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateBurnFee(
            _burnFee: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateFeeRecipient(
            _feeRecipient: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _mintable: PromiseOrValue<boolean>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateLiquidationIncentiveMultiplier(
            _liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateMinimumCollateralizationRatio(
            _minimumCollateralizationRatio: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateMinimumDebtValue(
            _minimumDebtValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        updateSecondsUntilStalePrice(
            _secondsUntilStalePrice: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        safetyStateFor(
            _asset: PromiseOrValue<string>,
            _action: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<BigNumber>;

        safetyStateSet(overrides?: CallOverrides): Promise<BigNumber>;

        toggleAssetsPaused(
            _assets: PromiseOrValue<string>[],
            _action: PromiseOrValue<BigNumberish>,
            _withDuration: PromiseOrValue<boolean>,
            _duration: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        burnKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        depositCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        mintKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;

        withdrawCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<BigNumber>;
    };

    populateTransaction: {
        getRoleAdmin(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getRoleMember(
            role: PromiseOrValue<BytesLike>,
            index: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getRoleMemberCount(role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        grantRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        hasRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        renounceRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        revokeRole(
            role: PromiseOrValue<BytesLike>,
            account: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        diamondCut(
            _diamondCut: IDiamondCut.FacetCutStruct[],
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        upgradeState(
            _init: PromiseOrValue<string>,
            _calldata: PromiseOrValue<BytesLike>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        facetAddress(
            _functionSelector: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        facetAddresses(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        facetFunctionSelectors(
            _facet: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        facets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        acceptOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

        initialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        transferOwnership(
            _newOwner: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        setERC165(
            interfaceIds: PromiseOrValue<BytesLike>[],
            interfaceIdsToRemove: PromiseOrValue<BytesLike>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        supportsInterface(
            _interfaceId: PromiseOrValue<BytesLike>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        assetActionPaused(
            _action: PromiseOrValue<BigNumberish>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        collateralAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        collateralDeposits(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        collateralExists(
            _collateralAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getAccountCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getAccountKrAssetValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getAccountMinimumCollateralValue(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getCollateralRatiosFor(
            _accounts: PromiseOrValue<string>[],
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getCollateralValueAndOraclePrice(
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreCollateralFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getDepositedCollateralAssetIndex(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getDepositedCollateralAssets(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getKrAssetValue(
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _ignoreKFactor: PromiseOrValue<boolean>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getMintedKreskoAssets(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        getMintedKreskoAssetsIndex(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        krAssetExists(_krAsset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        kreskoAsset(_asset: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

        kreskoAssetDebt(
            _account: PromiseOrValue<string>,
            _asset: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        burnFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        feeRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        getAllParams(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        liquidationIncentiveMultiplier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        minimumCollateralizationRatio(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        minimumDebtValue(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        minterInitializations(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        secondsUntilStalePrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        calculateMaxLiquidatableValueForAssets(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        isAccountLiquidatable(
            _account: PromiseOrValue<string>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        liquidate(
            _account: PromiseOrValue<string>,
            _repayKreskoAsset: PromiseOrValue<string>,
            _repayAmount: PromiseOrValue<BigNumberish>,
            _collateralAssetToSeize: PromiseOrValue<string>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        addCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        addKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        initialize(
            args: MinterInitArgsStruct,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateBurnFee(
            _burnFee: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateCollateralAsset(
            _collateralAsset: PromiseOrValue<string>,
            _factor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateFeeRecipient(
            _feeRecipient: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateKreskoAsset(
            _kreskoAsset: PromiseOrValue<string>,
            _kFactor: PromiseOrValue<BigNumberish>,
            _oracle: PromiseOrValue<string>,
            _mintable: PromiseOrValue<boolean>,
            _supplyLimit: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateLiquidationIncentiveMultiplier(
            _liquidationIncentiveMultiplier: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateMinimumCollateralizationRatio(
            _minimumCollateralizationRatio: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateMinimumDebtValue(
            _minimumDebtValue: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        updateSecondsUntilStalePrice(
            _secondsUntilStalePrice: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        safetyStateFor(
            _asset: PromiseOrValue<string>,
            _action: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides,
        ): Promise<PopulatedTransaction>;

        safetyStateSet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

        toggleAssetsPaused(
            _assets: PromiseOrValue<string>[],
            _action: PromiseOrValue<BigNumberish>,
            _withDuration: PromiseOrValue<boolean>,
            _duration: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        burnKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _mintedKreskoAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        depositCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        mintKreskoAsset(
            _account: PromiseOrValue<string>,
            _kreskoAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;

        withdrawCollateral(
            _account: PromiseOrValue<string>,
            _collateralAsset: PromiseOrValue<string>,
            _amount: PromiseOrValue<BigNumberish>,
            _depositedCollateralAssetIndex: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> },
        ): Promise<PopulatedTransaction>;
    };
}
