{
    "language": "Solidity",
    "sources": {
        "src/contracts/flux/FeedsRegistry.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title   Flux Feeds Registry\n * @notice  Get price in usd from an ERC20 token address\n * @dev     Contains a registry of price feeds. If a TOKEN/USD feed exists,\n *          just use that. Otherwise multiply prices from TOKEN/ETH and ETH/USD\n *          feeds. For USD, just return 1.\n */\ncontract FeedsRegistry is AccessControl {\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    event AddFeed(bytes32 indexed currencyKey, bool isEth, address feed);\n\n    // stringToBytes32(\"ETH\")\n    bytes32 public constant ETH = 0x4554480000000000000000000000000000000000000000000000000000000000;\n\n    // stringToBytes32(\"USD\")\n    bytes32 public constant USD = 0x5553440000000000000000000000000000000000000000000000000000000000;\n\n    mapping(bytes32 => address) public usdFeeds;\n    mapping(bytes32 => address) public ethFeeds;\n\n    constructor(address admin) {\n        _setupRole(ADMIN_ROLE, admin);\n    }\n\n    /**\n     * @notice Get price in usd multiplied by 1e8\n     * @param currencyKey ERC20 token whose price we want\n     */\n    function getPrice(bytes32 currencyKey) public view returns (uint256 price) {\n        address tokenUsd = usdFeeds[currencyKey];\n        if (tokenUsd != address(0)) {\n            // USD feeds are already scaled by 1e8 so can just return price\n            return _latestPrice(usdFeeds[currencyKey]);\n        }\n\n        address tokenEth = ethFeeds[currencyKey];\n        address ethUsd = usdFeeds[ETH];\n        if (tokenEth != address(0) && ethUsd != address(0)) {\n            uint256 price1 = _latestPrice(tokenEth);\n            uint256 price2 = _latestPrice(ethUsd);\n\n            // USD feeds are scale by 1e8 and ETH feeds by 1e18 so need to\n            // divide by 1e18\n            return price1.mul(price2).div(1e18);\n        } else if (currencyKey == USD) {\n            return 1e8;\n        }\n    }\n\n    function _latestPrice(address feed) internal view returns (uint256) {\n        if (feed == address(0)) {\n            return 0;\n        }\n        (, int256 price, , , ) = AggregatorV3Interface(feed).latestRoundData();\n        return uint256(price);\n    }\n\n    /**\n     * @notice Add TOKEN/USD feed to registry\n     * @param currencyKey ERC20 token symbol for which feed is being added\n     */\n    function addUsdFeed(bytes32 currencyKey, address feed) external {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        usdFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, false, feed);\n    }\n\n    /**\n     * @notice Add TOKEN/ETH feed to registry\n     * @param currencyKey ERC20 token symbol for which feed is being added\n     */\n    function addEthFeed(bytes32 currencyKey, address feed) external {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        ethFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, true, feed);\n    }\n\n    function getPriceFromSymbol(string memory symbol) external view returns (uint256) {\n        return getPrice(stringToBytes32(symbol));\n    }\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory b = bytes(source);\n        if (b.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/AccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/math/SafeMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
        },
        "src/contracts/flux/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
        },
        "@openzeppelin/contracts/access/IAccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
        },
        "@openzeppelin/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "src/contracts/flux/interfaces/AggregatorV2V3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
        },
        "src/contracts/flux/interfaces/AggregatorInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
        },
        "src/contracts/Kresko.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./utils/OwnableUpgradeable.sol\";\n\nimport \"./interfaces/IKreskoAsset.sol\";\nimport \"./interfaces/INonRebasingWrapperToken.sol\";\nimport \"./flux/interfaces/AggregatorV2V3Interface.sol\";\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/Arrays.sol\";\n\n/**\n * @title The core of the Kresko protocol.\n * @notice Responsible for managing collateral and minting / burning overcollateralized synthetic\n * assets called Kresko assets. Management of critical features such as adding new collateral\n * assets / Kresko assets and updating protocol constants such as the burn fee\n * minimum collateralization ratio, and liquidation incentive is restricted to the contract owner.\n */\ncontract Kresko is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using FixedPoint for FixedPoint.Unsigned;\n    using Arrays for address[];\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * ==================================================\n     * ==================== Structs =====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Information on a token that can be used as collateral.\n     * @dev Setting the factor to zero effectively makes the asset useless as collateral while still allowing\n     * it to be deposited and withdrawn.\n     * @param factor The collateral factor used for calculating the value of the collateral.\n     * @param oracle The oracle that provides the USD price of one collateral asset.\n     * @param underlyingRebasingToken If the collateral asset is an instance of NonRebasingWrapperToken,\n     * this is set to the underlying token that rebases. Otherwise, this is the zero address.\n     * Added so that Kresko.sol can handle NonRebasingWrapperTokens with fewer transactions.\n     * @param decimals The decimals for the token, stored here to avoid repetitive external calls.\n     * @param exists Whether the collateral asset exists within the protocol.\n     */\n    struct CollateralAsset {\n        FixedPoint.Unsigned factor;\n        AggregatorV2V3Interface oracle;\n        address underlyingRebasingToken;\n        uint8 decimals;\n        bool exists;\n    }\n\n    /**\n     * @notice Information on a token that is a Kresko asset.\n     * @dev Each Kresko asset has 18 decimals.\n     * @param kFactor The k-factor used for calculating the required collateral value for Kresko asset debt.\n     * @param oracle The oracle that provides the USD price of one Kresko asset.\n     * @param exists Whether the Kresko asset exists within the protocol.\n     * @param mintable Whether the Kresko asset can be minted.\n     * @param marketCapUSDLimit The market capitalization limit in USD of the Kresko asset.\n     */\n    struct KrAsset {\n        FixedPoint.Unsigned kFactor;\n        AggregatorV2V3Interface oracle;\n        bool exists;\n        bool mintable;\n        uint256 marketCapUSDLimit;\n    }\n\n    /**\n     * ==================================================\n     * =================== Constants ====================\n     * ==================================================\n     */\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 1e18;\n\n    /// @notice The maximum configurable burn fee.\n    uint256 public constant MAX_BURN_FEE = 5e16; // 5%\n\n    /// @notice The minimum configurable minimum collateralization ratio.\n    uint256 public constant MIN_COLLATERALIZATION_RATIO = 1e18; // 100%\n\n    /// @notice The minimum configurable liquidation incentive multiplier.\n    /// This means liquidator only receives equal amount of collateral to debt repaid.\n    uint256 public constant MIN_LIQUIDATION_INCENTIVE_MULTIPLIER = 1e18; // 100%\n\n    /// @notice The maximum configurable liquidation incentive multiplier.\n    /// This means liquidator receives 25% bonus collateral compared to the debt repaid.\n    uint256 public constant MAX_LIQUIDATION_INCENTIVE_MULTIPLIER = 1.25e18; // 125%\n\n    /// @notice The maximum configurable minimum debt USD value.\n    uint256 public constant MAX_DEBT_VALUE = 1000e18; // $1,000\n\n    /**\n     * ==================================================\n     * ===================== State ======================\n     * ==================================================\n     */\n\n    /* ===== Configurable parameters ===== */\n\n    mapping(address => bool) public trustedContracts;\n\n    /// @notice The percent fee imposed upon the value of burned krAssets, taken as collateral and sent to feeRecipient.\n    FixedPoint.Unsigned public burnFee;\n\n    /// @notice The recipient of burn fees.\n    address public feeRecipient;\n\n    /// @notice The factor used to calculate the incentive a liquidator receives in the form of seized collateral.\n    FixedPoint.Unsigned public liquidationIncentiveMultiplier;\n\n    /// @notice The absolute minimum ratio of collateral value to debt value that is used to calculate\n    /// collateral requirements.\n    FixedPoint.Unsigned public minimumCollateralizationRatio;\n\n    /// @notice The minimum USD value of an individual synthetic asset debt position.\n    FixedPoint.Unsigned public minimumDebtValue;\n\n    /* ===== General state - Collateral Assets ===== */\n\n    /// @notice Mapping of collateral asset token address to information on the collateral asset.\n    mapping(address => CollateralAsset) public collateralAssets;\n\n    /**\n     * @notice Mapping of account address to a mapping of collateral asset token address to the amount of the collateral\n     * asset the account has deposited.\n     * @dev Collateral assets must not rebase.\n     */\n    mapping(address => mapping(address => uint256)) public collateralDeposits;\n\n    /// @notice Mapping of account address to an array of the addresses of each collateral asset the account\n    /// has deposited.\n    mapping(address => address[]) public depositedCollateralAssets;\n\n    /* ===== General state - Kresko Assets ===== */\n\n    /// @notice Mapping of Kresko asset token address to information on the Kresko asset.\n    mapping(address => KrAsset) public kreskoAssets;\n\n    /// @notice Mapping of Kresko asset symbols to whether the symbol is used by an existing Kresko asset.\n    mapping(string => bool) public kreskoAssetSymbols;\n\n    /// @notice Mapping of account address to a mapping of Kresko asset token address to the amount of the Kresko asset\n    /// the account has minted and therefore owes to the protocol.\n    mapping(address => mapping(address => uint256)) public kreskoAssetDebt;\n\n    /// @notice Mapping of account address to an array of the addresses of each Kresko asset the account has minted.\n    mapping(address => address[]) public mintedKreskoAssets;\n\n    /**\n     * ==================================================\n     * ===================== Events =====================\n     * ==================================================\n     */\n\n    /* ===== Collateral ===== */\n\n    /**\n     * @notice Emitted when a collateral asset is added to the protocol.\n     * @dev Can only be emitted once for a given collateral asset.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     * @param oracle The address of the oracle.\n     */\n    event CollateralAssetAdded(address indexed collateralAsset, uint256 indexed factor, address indexed oracle);\n\n    /**\n     * @notice Emitted when a collateral asset's collateral factor is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param factor The collateral factor.\n     */\n    event CollateralAssetFactorUpdated(address indexed collateralAsset, uint256 indexed factor);\n\n    /**\n     * @notice Emitted when a collateral asset's oracle is updated.\n     * @param collateralAsset The address of the collateral asset.\n     * @param oracle The address of the oracle.\n     */\n    event CollateralAssetOracleUpdated(address indexed collateralAsset, address indexed oracle);\n\n    /**\n     * @notice Emitted when an account deposits collateral.\n     * @param account The address of the account depositing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was deposited.\n     */\n    event CollateralDeposited(address indexed account, address indexed collateralAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account withdraws collateral.\n     * @param account The address of the account withdrawing collateral.\n     * @param collateralAsset The address of the collateral asset.\n     * @param amount The amount of the collateral asset that was withdrawn.\n     */\n    event CollateralWithdrawn(address indexed account, address indexed collateralAsset, uint256 indexed amount);\n\n    /* ===== Kresko Assets ===== */\n\n    /**\n     * @notice Emitted when a Kresko asset is added to the protocol.\n     * @dev Can only be emitted once for a given Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param symbol The symbol of the Kresko asset.\n     * @param kFactor The k-factor.\n     * @param oracle The address of the oracle.\n     * @param marketCapLimit The initial market capitalization USD limit.\n     */\n    event KreskoAssetAdded(\n        address indexed kreskoAsset,\n        string indexed symbol,\n        uint256 indexed kFactor,\n        address oracle,\n        uint256 marketCapLimit\n    );\n\n    /**\n     * @notice Emitted when a Kresko asset's k-factor is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param kFactor The k-factor.\n     */\n    event KreskoAssetKFactorUpdated(address indexed kreskoAsset, uint256 indexed kFactor);\n\n    /**\n     * @notice Emitted when a Kresko asset's mintable property is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param mintable The mintable value.\n     */\n    event KreskoAssetMintableUpdated(address indexed kreskoAsset, bool indexed mintable);\n\n    /**\n     * @notice Emitted when a Kresko asset's oracle is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param oracle The address of the oracle.\n     */\n    event KreskoAssetOracleUpdated(address indexed kreskoAsset, address indexed oracle);\n\n    /**\n     * @notice Emitted when a Kresko asset's market capitalization USD limit is updated.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param limit The market capitalization USD limit.\n     */\n    event KreskoAssetMarketCapLimitUpdated(address indexed kreskoAsset, uint256 indexed limit);\n\n    /**\n     * @notice Emitted when an account mints a Kresko asset.\n     * @param account The address of the account minting the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the Kresko asset that was minted.\n     */\n    event KreskoAssetMinted(address indexed account, address indexed kreskoAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account burns a Kresko asset.\n     * @param account The address of the account burning the Kresko asset.\n     * @param kreskoAsset The address of the Kresko asset.\n     * @param amount The amount of the Kresko asset that was burned.\n     */\n    event KreskoAssetBurned(address indexed account, address indexed kreskoAsset, uint256 indexed amount);\n\n    /**\n     * @notice Emitted when an account pays a burn fee with a collateral asset upon burning a Kresko asset.\n     * @dev This can be emitted multiple times for a single Kresko asset burn.\n     * @param account The address of the account burning the Kresko asset.\n     * @param paymentCollateralAsset The address of the collateral asset used to pay the burn fee.\n     * @param paymentAmount The amount of the payment collateral asset that was paid.\n     * @param paymentValue The USD value of the payment.\n     */\n    event BurnFeePaid(\n        address indexed account,\n        address indexed paymentCollateralAsset,\n        uint256 indexed paymentAmount,\n        uint256 paymentValue\n    );\n\n    /**\n     * @notice Emitted when a liquidation occurs.\n     * @param account The address of the account being liquidated.\n     * @param liquidator The account performing the liquidation.\n     * @param repayKreskoAsset The address of the Kresko asset being paid back to the protocol by the liquidator.\n     * @param repayAmount The amount of the repay Kresko asset being paid back to the protocol by the liquidator.\n     * @param seizedCollateralAsset The address of the collateral asset being seized from the account by the liquidator.\n     * @param collateralSent The amount of the seized collateral asset being seized from the account by the liquidator.\n     */\n    event LiquidationOccurred(\n        address indexed account,\n        address indexed liquidator,\n        address indexed repayKreskoAsset,\n        uint256 repayAmount,\n        address seizedCollateralAsset,\n        uint256 collateralSent\n    );\n\n    /* ===== Configurable Parameters ===== */\n\n    /**\n     * @notice Emitted when the a trusted contract is added/removed.\n     * @param contractAddress A trusted contract (eg. Kresko Zapper).\n     * @param isTrusted true if the contract was added, false if removed\n     */\n    event TrustedContract(address indexed contractAddress, bool indexed isTrusted);\n\n    /**\n     * @notice Emitted when the burn fee is updated.\n     * @param burnFee The new burn fee raw value.\n     */\n    event BurnFeeUpdated(uint256 indexed burnFee);\n\n    /**\n     * @notice Emitted when the fee recipient is updated.\n     * @param feeRecipient The new fee recipient.\n     */\n    event FeeRecipientUpdated(address indexed feeRecipient);\n\n    /**\n     * @notice Emitted when the liquidation incentive multiplier is updated.\n     * @param liquidationIncentiveMultiplier The new liquidation incentive multiplier raw value.\n     */\n    event LiquidationIncentiveMultiplierUpdated(uint256 indexed liquidationIncentiveMultiplier);\n\n    /**\n     * @notice Emitted when the minimum collateralization ratio is updated.\n     * @param minimumCollateralizationRatio The new minimum collateralization ratio raw value.\n     */\n    event MinimumCollateralizationRatioUpdated(uint256 indexed minimumCollateralizationRatio);\n\n    /**\n     * @notice Emitted when the minimum debt value updated.\n     * @param minimumDebtValue The new minimum debt value.\n     */\n    event MinimumDebtValueUpdated(uint256 indexed minimumDebtValue);\n\n    /**\n     * ==================================================\n     * =================== Modifiers ====================\n     * ==================================================\n     */\n\n    /**\n     * @notice Ensure only trusted contracts can act on behalf of `_account`\n     * @param _accountIsNotMsgSender The address of the collateral asset.\n     */\n    modifier ensureTrustedCallerWhen(bool _accountIsNotMsgSender) {\n        if (_accountIsNotMsgSender) {\n            require(trustedContracts[msg.sender], \"KR: Unauthorized caller\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset does not exist within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetExists(address _collateralAsset) {\n        require(collateralAssets[_collateralAsset].exists, \"KR: !collateralExists\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if a collateral asset already exists within the protocol.\n     * @param _collateralAsset The address of the collateral asset.\n     */\n    modifier collateralAssetDoesNotExist(address _collateralAsset) {\n        require(!collateralAssets[_collateralAsset].exists, \"KR: collateralExists\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol or is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExistsAndMintable(address _kreskoAsset) {\n        require(kreskoAssets[_kreskoAsset].exists, \"KR: !krAssetExist\");\n        require(kreskoAssets[_kreskoAsset].mintable, \"KR: !krAssetMintable\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if a Kresko asset does not exist within the protocol. Does not revert if\n     * the Kresko asset is not mintable.\n     * @param _kreskoAsset The address of the Kresko asset.\n     */\n    modifier kreskoAssetExistsMaybeNotMintable(address _kreskoAsset) {\n        require(kreskoAssets[_kreskoAsset].exists, \"KR: !krAssetExist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the symbol of a Kresko asset already exists within the protocol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _symbol The symbol of the Kresko asset.\n     */\n    modifier kreskoAssetDoesNotExist(address _kreskoAsset, string calldata _symbol) {\n        require(!kreskoAssets[_kreskoAsset].exists, \"KR: krAssetExists\");\n        require(!kreskoAssetSymbols[_symbol], \"KR: symbolExists\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if provided string is empty.\n     * @param _str The string to ensure is not empty.\n     */\n    modifier nonNullString(string calldata _str) {\n        require(bytes(_str).length > 0, \"KR: !string\");\n        _;\n    }\n\n    /**\n     * @notice Empty constructor, see `initialize`.\n     * @dev Protects against a call to initialize when this contract is called directly without a proxy.\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n        // Intentionally left blank.\n    }\n\n    /**\n     * @notice Initializes the core Kresko protocol.\n     * @param _burnFee Initial burn fee as a raw value for a FixedPoint.Unsigned.\n     * @param _feeRecipient Initial fee recipient.\n     * @param _liquidationIncentiveMultiplier Initial liquidation incentive multiplier.\n     * @param _minimumCollateralizationRatio Initial collateralization ratio as a raw value for a FixedPoint.Unsigned.\n     * @param _minimumDebtValue Initial minimum debt value denominated in USD.\n     */\n    function initialize(\n        uint256 _burnFee,\n        address _feeRecipient,\n        uint256 _liquidationIncentiveMultiplier,\n        uint256 _minimumCollateralizationRatio,\n        uint256 _minimumDebtValue\n    ) external initializer {\n        // Set msg.sender as the owner.\n        __Ownable_init();\n        updateBurnFee(_burnFee);\n        updateFeeRecipient(_feeRecipient);\n        updateLiquidationIncentiveMultiplier(_liquidationIncentiveMultiplier);\n        updateMinimumCollateralizationRatio(_minimumCollateralizationRatio);\n        updateMinimumDebtValue(_minimumDebtValue);\n    }\n\n    /**\n     * ==================================================\n     * ======== Core external & public functions ========\n     * ==================================================\n     */\n\n    /* ===== Collateral ===== */\n\n    /**\n     * @notice Deposits collateral into the protocol.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to deposit.\n     */\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        // Transfer tokens into this contract prior to any state changes as an extra measure against re-entrancy.\n        IERC20MetadataUpgradeable(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Record the collateral deposit.\n        _recordCollateralDeposit(_account, _collateralAsset, _amount);\n    }\n\n    /**\n     * @notice Deposits a rebasing collateral into the protocol by wrapping the underlying\n     * rebasing token.\n     * @param _account The user to deposit collateral for.\n     * @param _collateralAsset The address of the NonRebasingWrapperToken collateral asset.\n     * @param _rebasingAmount The amount of the underlying rebasing token to deposit.\n     */\n    function depositRebasingCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _rebasingAmount\n    ) external nonReentrant collateralAssetExists(_collateralAsset) {\n        require(_rebasingAmount > 0, \"KR: 0-deposit\");\n\n        address underlyingRebasingToken = collateralAssets[_collateralAsset].underlyingRebasingToken;\n        require(underlyingRebasingToken != address(0), \"KR: !NRWTCollateral\");\n\n        // Transfer underlying rebasing token in.\n        IERC20Upgradeable(underlyingRebasingToken).safeTransferFrom(msg.sender, address(this), _rebasingAmount);\n\n        // Approve the newly received rebasing token to the NonRebasingWrapperToken in preparation\n        // for calling depositUnderlying.\n        require(\n            IERC20Upgradeable(underlyingRebasingToken).approve(_collateralAsset, _rebasingAmount),\n            \"KR: ApprovalFail\"\n        );\n\n        // Wrap into NonRebasingWrapperToken.\n        uint256 nonRebasingAmount = INonRebasingWrapperToken(_collateralAsset).depositUnderlying(_rebasingAmount);\n\n        // Record the collateral deposit.\n        _recordCollateralDeposit(_account, _collateralAsset, nonRebasingAmount);\n    }\n\n    /**\n     * @notice Withdraws sender's collateral from the protocol.\n     * @dev Requires the post-withdrawal collateral value to violate minimum collateral requirement.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) ensureTrustedCallerWhen(_account != msg.sender) {\n        uint256 depositAmount = collateralDeposits[_account][_collateralAsset];\n        _amount = (_amount <= depositAmount ? _amount : depositAmount);\n        _verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _amount,\n            depositAmount,\n            _depositedCollateralAssetIndex\n        );\n\n        IERC20MetadataUpgradeable(_collateralAsset).safeTransfer(_account, _amount);\n    }\n\n    /**\n     * @notice Withdraws NonRebasingWrapperToken collateral from the protocol and unwraps it.\n     * @param _account The address to withdraw assets for.\n     * @param _collateralAsset The address of the NonRebasingWrapperToken collateral asset.\n     * @param _amount The amount of the NonRebasingWrapperToken collateral asset to withdraw.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the sender's deposited collateral\n     * assets array. Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function withdrawRebasingCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external nonReentrant collateralAssetExists(_collateralAsset) ensureTrustedCallerWhen(_account != msg.sender) {\n        uint256 depositAmount = collateralDeposits[_account][_collateralAsset];\n        _amount = (_amount <= depositAmount ? _amount : depositAmount);\n        _verifyAndRecordCollateralWithdrawal(\n            _account,\n            _collateralAsset,\n            _amount,\n            depositAmount,\n            _depositedCollateralAssetIndex\n        );\n\n        address underlyingRebasingToken = collateralAssets[_collateralAsset].underlyingRebasingToken;\n        require(underlyingRebasingToken != address(0), \"KR: !NRWTCollateral\");\n\n        // Unwrap the NonRebasingWrapperToken into the rebasing underlying.\n        uint256 underlyingAmountWithdrawn = INonRebasingWrapperToken(_collateralAsset).withdrawUnderlying(_amount);\n\n        // Transfer the sender the rebasing underlying.\n        IERC20MetadataUpgradeable(underlyingRebasingToken).safeTransfer(_account, underlyingAmountWithdrawn);\n    }\n\n    /* ===== Kresko Assets ===== */\n\n    /**\n     * @notice Mints new Kresko assets.\n     * @param _account The address to mint assets for.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to be minted.\n     */\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount\n    ) external nonReentrant kreskoAssetExistsAndMintable(_kreskoAsset) ensureTrustedCallerWhen(_account != msg.sender) {\n        require(_amount > 0, \"KR: 0-mint\");\n\n        // Enforce synthetic asset's maximum market capitalization limit\n        require(\n            getKrAssetValue(_kreskoAsset, IKreskoAsset(_kreskoAsset).totalSupply() + _amount, true).rawValue <=\n                kreskoAssets[_kreskoAsset].marketCapUSDLimit,\n            \"KR: MC limit\"\n        );\n\n        // Get the value of the minter's current deposited collateral.\n        FixedPoint.Unsigned memory accountCollateralValue = getAccountCollateralValue(_account);\n        // Get the account's current minimum collateral value required to maintain current debts.\n        FixedPoint.Unsigned memory minAccountCollateralValue = getAccountMinimumCollateralValue(_account);\n        // Calculate additional collateral amount required to back requested additional mint.\n        FixedPoint.Unsigned memory additionalCollateralValue = getMinimumCollateralValue(_kreskoAsset, _amount);\n\n        // Verify that minter has sufficient collateral to back current debt + new requested debt.\n        require(\n            minAccountCollateralValue.add(additionalCollateralValue).isLessThanOrEqual(accountCollateralValue),\n            \"KR: insufficientCollateral\"\n        );\n\n        // The synthetic asset debt position must be greater than the minimum debt position value\n        uint256 existingDebtAmount = kreskoAssetDebt[_account][_kreskoAsset];\n        require(\n            getKrAssetValue(_kreskoAsset, existingDebtAmount + _amount, true).isGreaterThanOrEqual(minimumDebtValue),\n            \"KR: belowMinDebtValue\"\n        );\n\n        // If the account does not have an existing debt for this Kresko Asset,\n        // push it to the list of the account's minted Kresko Assets.\n        if (existingDebtAmount == 0) {\n            mintedKreskoAssets[_account].push(_kreskoAsset);\n        }\n        // Record the mint.\n        kreskoAssetDebt[_account][_kreskoAsset] = existingDebtAmount + _amount;\n\n        IKreskoAsset(_kreskoAsset).mint(_account, _amount);\n\n        emit KreskoAssetMinted(_account, _kreskoAsset, _amount);\n    }\n\n    /**\n     * @notice Burns existing Kresko assets.\n     * @param _account The address to burn kresko assets for\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to be burned.\n     * @param _mintedKreskoAssetIndex The index of the collateral asset in the user's minted assets array.\n     * @notice Only needed if withdrawing the entire deposit of a particular collateral asset.\n     */\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount,\n        uint256 _mintedKreskoAssetIndex\n    )\n        external\n        nonReentrant\n        kreskoAssetExistsMaybeNotMintable(_kreskoAsset)\n        ensureTrustedCallerWhen(_account != msg.sender)\n    {\n        require(_amount > 0, \"KR: 0-burn\");\n\n        // Ensure the amount being burned is not greater than the user's debt.\n        uint256 debtAmount = kreskoAssetDebt[_account][_kreskoAsset];\n        require(_amount <= debtAmount, \"KR: amount > debt\");\n\n        // If the requested burn would put the user's debt position below the minimum\n        // debt value, close the position entirely instead.\n        if (getKrAssetValue(_kreskoAsset, debtAmount - _amount, true).isLessThan(minimumDebtValue)) {\n            _amount = debtAmount;\n        }\n\n        // Record the burn.\n        kreskoAssetDebt[_account][_kreskoAsset] -= _amount;\n\n        // If the sender is burning all of the kresko asset, remove it from minted assets array.\n        if (_amount == debtAmount) {\n            mintedKreskoAssets[_account].removeAddress(_kreskoAsset, _mintedKreskoAssetIndex);\n        }\n\n        _chargeBurnFee(_account, _kreskoAsset, _amount);\n\n        // Burn the received kresko assets, removing them from circulation.\n        IKreskoAsset(_kreskoAsset).burn(msg.sender, _amount);\n\n        emit KreskoAssetBurned(_account, _kreskoAsset, _amount);\n    }\n\n    // * ===== Liquidation ===== */\n\n    /**\n     * @notice Attempts to liquidate an account by repaying the portion of the account's Kresko asset\n     *         debt, receiving in return a portion of the account's collateral at a discounted rate.\n     * @param _account The account to attempt to liquidate.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _mintedKreskoAssetIndex The index of the Kresko asset in the account's minted assets array.\n     * @param _depositedCollateralAssetIndex Index of the collateral asset in the account's collateral assets array.\n     * @param _keepKrAssetDebt Liquidator can choose to receive the whole seized amount keeping the krAsset debt.\n     * Setting _keepKrAssetDebt to false will instead only send the incentive and repay krAsset debt.\n     */\n\n    function liquidate(\n        address _account,\n        address _repayKreskoAsset,\n        uint256 _repayAmount,\n        address _collateralAssetToSeize,\n        uint256 _mintedKreskoAssetIndex,\n        uint256 _depositedCollateralAssetIndex,\n        bool _keepKrAssetDebt\n    ) external nonReentrant {\n        // Not used with modifiers due to stack too deep errors\n        require(kreskoAssets[_repayKreskoAsset].exists, \"KR: !krAssetExist\");\n        require(collateralAssets[_collateralAssetToSeize].exists, \"KR: !collateralExists\");\n        require(_repayAmount > 0, \"KR: 0-repay\");\n\n        // Borrower cannot liquidate themselves\n        require(msg.sender != _account, \"KR: self liquidation\");\n\n        // Check that this account is below its minimum collateralization ratio and can be liquidated.\n        require(isAccountLiquidatable(_account), \"KR: !accountLiquidatable\");\n\n        // Repay amount USD = repay amount * KR asset USD exchange rate.\n        FixedPoint.Unsigned memory repayAmountUSD = FixedPoint.Unsigned(_repayAmount).mul(\n            FixedPoint.Unsigned(uint256(kreskoAssets[_repayKreskoAsset].oracle.latestAnswer()))\n        );\n\n        // Get the token debt amount\n        uint256 krAssetDebt = kreskoAssetDebt[_account][_repayKreskoAsset];\n        // Avoid stack too deep error\n        {\n            // Liquidator may not repay more value than what the liquidation pair allows\n            // Nor repay more tokens than the account holds debt for the asset\n            FixedPoint.Unsigned memory maxLiquidation = calculateMaxLiquidatableValueForAssets(\n                _account,\n                _repayKreskoAsset,\n                _collateralAssetToSeize\n            );\n            require(krAssetDebt >= _repayAmount, \"KR: repayAmount > debtAmount\");\n            require(repayAmountUSD.isLessThanOrEqual(maxLiquidation), \"KR: repayUSD > maxUSD\");\n        }\n\n        FixedPoint.Unsigned memory collateralPriceUSD = FixedPoint.Unsigned(\n            uint256(collateralAssets[_collateralAssetToSeize].oracle.latestAnswer())\n        );\n\n        // Get the actual seized amount\n        uint256 seizeAmount = _liquidateAssets(\n            _account,\n            krAssetDebt,\n            _repayAmount,\n            _fromCollateralFixedPointAmount(\n                _collateralAssetToSeize,\n                // Calculate amount of collateral to seize.\n                _calculateAmountToSeize(collateralPriceUSD, repayAmountUSD)\n            ),\n            _repayKreskoAsset,\n            _mintedKreskoAssetIndex,\n            _collateralAssetToSeize,\n            _depositedCollateralAssetIndex\n        );\n\n        // Charge burn fee from the liquidated user\n        _chargeBurnFee(_account, _repayKreskoAsset, _repayAmount);\n\n        // Burn the received Kresko assets, removing them from circulation.\n        IKreskoAsset(_repayKreskoAsset).burn(msg.sender, _repayAmount);\n\n        uint256 collateralToSend = _keepKrAssetDebt\n            ? seizeAmount\n            : _calculateCollateralToSendAndAdjustDebt(\n                _collateralAssetToSeize,\n                _repayKreskoAsset,\n                _repayAmount,\n                seizeAmount,\n                repayAmountUSD,\n                collateralPriceUSD\n            );\n\n        // Send liquidator the seized collateral.\n        IERC20MetadataUpgradeable(_collateralAssetToSeize).safeTransfer(msg.sender, collateralToSend);\n\n        emit LiquidationOccurred(\n            _account,\n            msg.sender,\n            _repayKreskoAsset,\n            _repayAmount,\n            _collateralAssetToSeize,\n            collateralToSend\n        );\n    }\n\n    /**\n     * ==================================================\n     * ============== Owner-only functions ==============\n     * ==================================================\n     */\n\n    /* ===== Collateral ===== */\n\n    /**\n     * @notice Adds a collateral asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for an asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _factor The collateral factor of the collateral asset as a raw value for a FixedPoint.Unsigned.\n     * Must be <= 1e18.\n     * @param _oracle The oracle address for the collateral asset's USD value.\n     */\n    function addCollateralAsset(\n        address _collateralAsset,\n        uint256 _factor,\n        address _oracle,\n        bool isNonRebasingWrapperToken\n    ) external nonReentrant onlyOwner collateralAssetDoesNotExist(_collateralAsset) {\n        require(_collateralAsset != address(0), \"KR: !collateralAddr\");\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, \"KR: factor > 1FP\");\n        require(_oracle != address(0), \"KR: !oracleAddr\");\n\n        // Set as the rebasing underlying token if the collateral asset is a\n        // NonRebasingWrapperToken, otherwise set as address(0).\n        address underlyingRebasingToken = isNonRebasingWrapperToken\n            ? INonRebasingWrapperToken(_collateralAsset).underlyingToken()\n            : address(0);\n\n        collateralAssets[_collateralAsset] = CollateralAsset({\n            factor: FixedPoint.Unsigned(_factor),\n            oracle: AggregatorV2V3Interface(_oracle),\n            underlyingRebasingToken: underlyingRebasingToken,\n            exists: true,\n            decimals: IERC20MetadataUpgradeable(_collateralAsset).decimals()\n        });\n        emit CollateralAssetAdded(_collateralAsset, _factor, _oracle);\n    }\n\n    /**\n     * @notice Updates the collateral factor of a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _factor The new collateral factor as a raw value for a FixedPoint.Unsigned. Must be <= 1e18.\n     */\n    function updateCollateralFactor(address _collateralAsset, uint256 _factor)\n        external\n        onlyOwner\n        collateralAssetExists(_collateralAsset)\n    {\n        // Setting the factor to 0 effectively sunsets a collateral asset, which is intentionally allowed.\n        require(_factor <= FixedPoint.FP_SCALING_FACTOR, \"KR: factor > 1FP\");\n\n        collateralAssets[_collateralAsset].factor = FixedPoint.Unsigned(_factor);\n        emit CollateralAssetFactorUpdated(_collateralAsset, _factor);\n    }\n\n    /**\n     * @notice Updates the oracle address of a previously added collateral asset.\n     * @dev Only callable by the owner.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _oracle The new oracle address for the collateral asset.\n     */\n    function updateCollateralAssetOracle(address _collateralAsset, address _oracle)\n        external\n        onlyOwner\n        collateralAssetExists(_collateralAsset)\n    {\n        require(_oracle != address(0), \"KR: !oracleAddr\");\n\n        collateralAssets[_collateralAsset].oracle = AggregatorV2V3Interface(_oracle);\n        emit CollateralAssetOracleUpdated(_collateralAsset, _oracle);\n    }\n\n    /* ===== Kresko Assets ===== */\n\n    /**\n     * @notice Adds a Kresko asset to the protocol.\n     * @dev Only callable by the owner and cannot be called more than once for a given symbol.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _symbol The symbol of the Kresko asset.\n     * @param _kFactor The k-factor of the Kresko asset as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     * @param _oracle The oracle address for the Kresko asset.\n     * @param _marketCapUSDLimit The initial market capitalization USD limit for the Kresko asset.\n     */\n    function addKreskoAsset(\n        address _kreskoAsset,\n        string calldata _symbol,\n        uint256 _kFactor,\n        address _oracle,\n        uint256 _marketCapUSDLimit\n    ) external onlyOwner nonNullString(_symbol) kreskoAssetDoesNotExist(_kreskoAsset, _symbol) {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, \"KR: kFactor < 1FP\");\n        require(_oracle != address(0), \"KR: !oracleAddr\");\n        IKreskoAsset kreskoAsset = IKreskoAsset(_kreskoAsset);\n        require(kreskoAsset.hasRole(kreskoAsset.OPERATOR_ROLE(), address(this)), \"KR: !assetOperator\");\n\n        // Store symbol to prevent duplicate KreskoAsset symbols.\n        kreskoAssetSymbols[_symbol] = true;\n\n        // Deploy KreskoAsset contract and store its details.\n        kreskoAssets[_kreskoAsset] = KrAsset({\n            kFactor: FixedPoint.Unsigned(_kFactor),\n            oracle: AggregatorV2V3Interface(_oracle),\n            exists: true,\n            mintable: true,\n            marketCapUSDLimit: _marketCapUSDLimit\n        });\n        emit KreskoAssetAdded(_kreskoAsset, _symbol, _kFactor, _oracle, _marketCapUSDLimit);\n    }\n\n    /**\n     * @notice Updates the k-factor of a previously added Kresko asset.\n     * @dev Only callable by the owner.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _kFactor The new k-factor as a raw value for a FixedPoint.Unsigned. Must be >= 1e18.\n     */\n    function updateKreskoAssetFactor(address _kreskoAsset, uint256 _kFactor)\n        external\n        onlyOwner\n        kreskoAssetExistsMaybeNotMintable(_kreskoAsset)\n    {\n        require(_kFactor >= FixedPoint.FP_SCALING_FACTOR, \"KR: kFactor < 1FP\");\n\n        kreskoAssets[_kreskoAsset].kFactor = FixedPoint.Unsigned(_kFactor);\n        emit KreskoAssetKFactorUpdated(_kreskoAsset, _kFactor);\n    }\n\n    /**\n     * @dev Updates the mintable property of a previously added Kresko asset.\n     * @dev Only callable by the owner.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _mintable The new mintable value.\n     */\n    function updateKreskoAssetMintable(address _kreskoAsset, bool _mintable)\n        external\n        onlyOwner\n        kreskoAssetExistsMaybeNotMintable(_kreskoAsset)\n    {\n        kreskoAssets[_kreskoAsset].mintable = _mintable;\n        emit KreskoAssetMintableUpdated(_kreskoAsset, _mintable);\n    }\n\n    /**\n     * @dev Updates the oracle address of a previously added Kresko asset.\n     * @dev Only callable by the owner.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _oracle The new oracle address for the Kresko asset's USD value.\n     */\n    function updateKreskoAssetOracle(address _kreskoAsset, address _oracle)\n        external\n        onlyOwner\n        kreskoAssetExistsMaybeNotMintable(_kreskoAsset)\n    {\n        require(_oracle != address(0), \"KR: !oracleAddr\");\n\n        kreskoAssets[_kreskoAsset].oracle = AggregatorV2V3Interface(_oracle);\n        emit KreskoAssetOracleUpdated(_kreskoAsset, _oracle);\n    }\n\n    /**\n     * @dev Updates the market capitalization USD limit property of a previously added Kresko asset.\n     * @dev Only callable by the owner.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _marketCapUSDLimit The new market capitalization USD limit.\n     */\n    function updateKreskoAssetMarketCapUSDLimit(address _kreskoAsset, uint256 _marketCapUSDLimit)\n        external\n        onlyOwner\n        kreskoAssetExistsMaybeNotMintable(_kreskoAsset)\n    {\n        kreskoAssets[_kreskoAsset].marketCapUSDLimit = _marketCapUSDLimit;\n        emit KreskoAssetMarketCapLimitUpdated(_kreskoAsset, _marketCapUSDLimit);\n    }\n\n    /* ===== Configurable parameters ===== */\n    /**\n     * @notice Toggles a trusted contract to perform actions on behalf of user (eg. Kresko Zapper).\n     * @param _trustedContract Contract to toggle the trusted status for.\n     */\n    function toggleTrustedContract(address _trustedContract) external onlyOwner {\n        bool isTrusted = !trustedContracts[_trustedContract];\n\n        trustedContracts[_trustedContract] = isTrusted;\n\n        emit TrustedContract(_trustedContract, isTrusted);\n    }\n\n    /**\n     * @notice Updates the burn fee.\n     * @param _burnFee The new burn fee as a raw value for a FixedPoint.Unsigned.\n     */\n    function updateBurnFee(uint256 _burnFee) public onlyOwner {\n        require(_burnFee <= MAX_BURN_FEE, \"KR: burnFee > max\");\n        burnFee = FixedPoint.Unsigned(_burnFee);\n        emit BurnFeeUpdated(_burnFee);\n    }\n\n    /**\n     * @notice Updates the fee recipient.\n     * @param _feeRecipient The new fee recipient.\n     */\n    function updateFeeRecipient(address _feeRecipient) public onlyOwner {\n        require(_feeRecipient != address(0), \"KR: !feeRecipient\");\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /**\n     * @notice Updates the liquidation incentive multiplier.\n     * @param _liquidationIncentiveMultiplier The new liquidation incentive multiplie.\n     */\n    function updateLiquidationIncentiveMultiplier(uint256 _liquidationIncentiveMultiplier) public onlyOwner {\n        require(_liquidationIncentiveMultiplier >= MIN_LIQUIDATION_INCENTIVE_MULTIPLIER, \"KR: liqIncentiveMulti < min\");\n        require(_liquidationIncentiveMultiplier <= MAX_LIQUIDATION_INCENTIVE_MULTIPLIER, \"KR: liqIncentiveMulti > max\");\n        liquidationIncentiveMultiplier = FixedPoint.Unsigned(_liquidationIncentiveMultiplier);\n        emit LiquidationIncentiveMultiplierUpdated(_liquidationIncentiveMultiplier);\n    }\n\n    /**\n     * @dev Updates the contract's collateralization ratio.\n     * @param _minimumCollateralizationRatio The new minimum collateralization ratio as a raw value\n     * for a FixedPoint.Unsigned.\n     */\n    function updateMinimumCollateralizationRatio(uint256 _minimumCollateralizationRatio) public onlyOwner {\n        require(_minimumCollateralizationRatio >= MIN_COLLATERALIZATION_RATIO, \"KR: minCollateralRatio < min\");\n        minimumCollateralizationRatio = FixedPoint.Unsigned(_minimumCollateralizationRatio);\n        emit MinimumCollateralizationRatioUpdated(_minimumCollateralizationRatio);\n    }\n\n    /**\n     * @dev Updates the contract's minimum debt value.\n     * @param _minimumDebtValue The new minimum debt value as a raw value for a FixedPoint.Unsigned.\n     */\n    function updateMinimumDebtValue(uint256 _minimumDebtValue) public onlyOwner {\n        require(_minimumDebtValue <= MAX_DEBT_VALUE, \"KR: debtValue > max\");\n        minimumDebtValue = FixedPoint.Unsigned(_minimumDebtValue);\n        emit MinimumDebtValueUpdated(_minimumDebtValue);\n    }\n\n    /**\n     * ==================================================\n     * ============= Core internal functions ============\n     * ==================================================\n     */\n\n    /* ==== Collateral ==== */\n\n    /**\n     * @notice Records account as having deposited an amount of a collateral asset.\n     * @dev Token transfers are expected to be done by the caller.\n     * @param _account The address of the collateral asset.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset deposited.\n     */\n    function _recordCollateralDeposit(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount\n    ) internal {\n        // Because the depositedCollateralAssets[_account] is pushed to if the existing\n        // deposit amount is 0, require the amount to be > 0. Otherwise, the depositedCollateralAssets[_account]\n        // could be filled with duplicates, causing collateral to be double-counted in the collateral value.\n        require(_amount > 0, \"KR: 0-deposit\");\n\n        // If the account does not have an existing deposit for this collateral asset,\n        // push it to the list of the account's deposited collateral assets.\n        uint256 existingDepositAmount = collateralDeposits[_account][_collateralAsset];\n        if (existingDepositAmount == 0) {\n            depositedCollateralAssets[_account].push(_collateralAsset);\n        }\n        // Record the deposit.\n        unchecked {\n            collateralDeposits[_account][_collateralAsset] = existingDepositAmount + _amount;\n        }\n\n        emit CollateralDeposited(_account, _collateralAsset, _amount);\n    }\n\n    function _verifyAndRecordCollateralWithdrawal(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositAmount,\n        uint256 _depositedCollateralAssetIndex\n    ) internal {\n        require(_amount > 0, \"KR: 0-withdraw\");\n\n        // Ensure the withdrawal does not result in the account having a collateral value\n        // under the minimum collateral amount required to maintain a healthy position.\n        // I.e. the new account's collateral value must still exceed the account's minimum\n        // collateral value.\n        // Get the account's current collateral value.\n        FixedPoint.Unsigned memory accountCollateralValue = getAccountCollateralValue(_account);\n        // Get the collateral value that the account will lose as a result of this withdrawal.\n        (FixedPoint.Unsigned memory withdrawnCollateralValue, ) = getCollateralValueAndOraclePrice(\n            _collateralAsset,\n            _amount,\n            false // Take the collateral factor into consideration.\n        );\n        // Get the account's minimum collateral value.\n        FixedPoint.Unsigned memory accountMinCollateralValue = getAccountMinimumCollateralValue(_account);\n        // Require accountCollateralValue - withdrawnCollateralValue >= accountMinCollateralValue.\n        require(\n            accountCollateralValue.sub(withdrawnCollateralValue).isGreaterThanOrEqual(accountMinCollateralValue),\n            \"KR: collateralTooLow\"\n        );\n\n        // Record the withdrawal.\n        collateralDeposits[_account][_collateralAsset] = _depositAmount - _amount;\n\n        // If the user is withdrawing all of the collateral asset, remove the collateral asset\n        // from the user's deposited collateral assets array.\n        if (_amount == _depositAmount) {\n            depositedCollateralAssets[_account].removeAddress(_collateralAsset, _depositedCollateralAssetIndex);\n        }\n\n        emit CollateralWithdrawn(_account, _collateralAsset, _amount);\n    }\n\n    /**\n     * @notice For a given collateral asset and amount, returns a FixedPoint.Unsigned representation.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals > 18, there may be a loss of precision.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset.\n     * @return A FixedPoint.Unsigned of amount scaled according to the collateral asset's decimals.\n     */\n    function _toCollateralFixedPointAmount(address _collateralAsset, uint256 _amount)\n        internal\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        CollateralAsset memory collateralAsset = collateralAssets[_collateralAsset];\n        // Initially, use the amount as the raw value for the FixedPoint.Unsigned,\n        // which internally uses FixedPoint.FP_DECIMALS (18) decimals. Most collateral\n        // assets will have 18 decimals.\n        FixedPoint.Unsigned memory fixedPointAmount = FixedPoint.Unsigned(_amount);\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (collateralAsset.decimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, multiply the amount\n            // to get the correct fixed point value.\n            // E.g. 1 full token of a 17 decimal token will  cause the\n            // initial setting of amount to be 0.1, so we multiply\n            // by 10 ** (18 - 17) = 10 to get it to 0.1 * 10 = 1.\n            return fixedPointAmount.mul(10**(FixedPoint.FP_DECIMALS - collateralAsset.decimals));\n        } else if (collateralAsset.decimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, divide the amount\n            // to get the correct fixed point value.\n            // Note because FixedPoint numbers are 18 decimals, this results\n            // in loss of precision. E.g. if the collateral asset has 19\n            // decimals and the deposit amount is only 1 uint, this will divide\n            // 1 by 10 ** (19 - 18), resulting in 1 / 10 = 0\n            return fixedPointAmount.div(10**(collateralAsset.decimals - FixedPoint.FP_DECIMALS));\n        }\n        return fixedPointAmount;\n    }\n\n    /**\n     * @notice For a given collateral asset and fixed point amount, i.e. where a rawValue of 1e18 is equal to 1\n     *   whole token, returns the amount according to the collateral asset's decimals.\n     * @dev If the collateral asset has decimals other than 18, the amount is scaled appropriately.\n     *   If decimals < 18, there may be a loss of precision.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _fixedPointAmount The fixed point amount of the collateral asset.\n     * @return An amount that is compatible with the collateral asset's decimals.\n     */\n    function _fromCollateralFixedPointAmount(address _collateralAsset, FixedPoint.Unsigned memory _fixedPointAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        CollateralAsset memory collateralAsset = collateralAssets[_collateralAsset];\n        // Initially, use the rawValue, which internally uses FixedPoint.FP_DECIMALS (18) decimals\n        // Most collateral assets will have 18 decimals.\n        uint256 amount = _fixedPointAmount.rawValue;\n        // Handle cases where the collateral asset's decimal amount is not 18.\n        if (collateralAsset.decimals < FixedPoint.FP_DECIMALS) {\n            // If the decimals are less than 18, divide the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 17 decimals, divide by 10 ** (18 - 17) = 10\n            // to get a value of 1e17.\n            // This may result in a loss of precision.\n            return amount / (10**(FixedPoint.FP_DECIMALS - collateralAsset.decimals));\n        } else if (collateralAsset.decimals > FixedPoint.FP_DECIMALS) {\n            // If the decimals are greater than 18, multiply the depositAmount\n            // to get the correct fixed point value.\n            // E.g. 1 full token will result in amount being 1e18 at this point,\n            // so if the token has 19 decimals, multiply by 10 ** (19 - 18) = 10\n            // to get a value of 1e19.\n            return amount * (10**(collateralAsset.decimals - FixedPoint.FP_DECIMALS));\n        }\n        return amount;\n    }\n\n    /* ==== Kresko Assets ==== */\n\n    /**\n     * @notice Charges the protocol burn fee based off the value of the burned asset.\n     * @dev Takes the fee from the account's collateral assets. Attempts collateral assets\n     *   in reverse order of the account's deposited collateral assets array.\n     * @param _account The account to charge the burn fee from.\n     * @param _kreskoAsset The address of the kresko asset being burned.\n     * @param _kreskoAssetAmountBurned The amount of the kresko asset being burned.\n     */\n    function _chargeBurnFee(\n        address _account,\n        address _kreskoAsset,\n        uint256 _kreskoAssetAmountBurned\n    ) internal {\n        KrAsset memory krAsset = kreskoAssets[_kreskoAsset];\n        // Calculate the value of the fee according to the value of the krAssets being burned.\n        FixedPoint.Unsigned memory feeValue = FixedPoint\n            .Unsigned(uint256(krAsset.oracle.latestAnswer()))\n            .mul(FixedPoint.Unsigned(_kreskoAssetAmountBurned))\n            .mul(burnFee);\n\n        // Do nothing if the fee value is 0.\n        if (feeValue.rawValue == 0) {\n            return;\n        }\n\n        address[] memory accountCollateralAssets = depositedCollateralAssets[_account];\n        // Iterate backward through the account's deposited collateral assets to safely\n        // traverse the array while still being able to remove elements if necessary.\n        // This is because removing the last element of the array does not shift around\n        // other elements in the array.\n        for (uint256 i = accountCollateralAssets.length - 1; i >= 0; i--) {\n            address collateralAssetAddress = accountCollateralAssets[i];\n\n            (uint256 transferAmount, FixedPoint.Unsigned memory feeValuePaid) = _calcBurnFee(\n                collateralAssetAddress,\n                _account,\n                feeValue,\n                i\n            );\n\n            // Remove the transferAmount from the stored deposit for the account.\n            collateralDeposits[_account][collateralAssetAddress] -= transferAmount;\n            // Transfer the fee to the feeRecipient.\n            IERC20MetadataUpgradeable(collateralAssetAddress).safeTransfer(feeRecipient, transferAmount);\n            emit BurnFeePaid(_account, collateralAssetAddress, transferAmount, feeValuePaid.rawValue);\n\n            feeValue = feeValue.sub(feeValuePaid);\n            // If the entire fee has been paid, no more action needed.\n            if (feeValue.rawValue == 0) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the burn fee for a burned asset.\n     * @param _collateralAssetAddress The collateral asset from which to take to the fee.\n     * @param _account The owner of the collateral.\n     * @param _feeValue The original value of the fee.\n     * @param _collateralAssetIndex The collateral asset's index in the user's depositedCollateralAssets array.\n     * @return The transfer amount to be received as a uint256 and a FixedPoint.Unsigned\n     * representing the fee value paid.\n     */\n    function _calcBurnFee(\n        address _collateralAssetAddress,\n        address _account,\n        FixedPoint.Unsigned memory _feeValue,\n        uint256 _collateralAssetIndex\n    ) internal returns (uint256, FixedPoint.Unsigned memory) {\n        uint256 depositAmount = collateralDeposits[_account][_collateralAssetAddress];\n\n        // Don't take the collateral asset's collateral factor into consideration.\n        (\n            FixedPoint.Unsigned memory depositValue,\n            FixedPoint.Unsigned memory oraclePrice\n        ) = getCollateralValueAndOraclePrice(_collateralAssetAddress, depositAmount, true);\n\n        FixedPoint.Unsigned memory feeValuePaid;\n        uint256 transferAmount;\n        // If feeValue < depositValue, the entire fee can be charged for this collateral asset.\n        if (_feeValue.isLessThan(depositValue)) {\n            // We want to make sure that transferAmount is < depositAmount.\n            // Proof:\n            //   depositValue <= oraclePrice * depositAmount (<= due to a potential loss of precision)\n            //   feeValue < depositValue\n            // Meaning:\n            //   feeValue < oraclePrice * depositAmount\n            // Solving for depositAmount we get:\n            //   feeValue / oraclePrice < depositAmount\n            // Due to integer division:\n            //   transferAmount = floor(feeValue / oracleValue)\n            //   transferAmount <= feeValue / oraclePrice\n            // We see that:\n            //   transferAmount <= feeValue / oraclePrice < depositAmount\n            //   transferAmount < depositAmount\n            transferAmount = _fromCollateralFixedPointAmount(_collateralAssetAddress, _feeValue.div(oraclePrice));\n            feeValuePaid = _feeValue;\n        } else {\n            // If the feeValue >= depositValue, the entire deposit\n            // should be taken as the fee.\n            transferAmount = depositAmount;\n            feeValuePaid = depositValue;\n            // Because the entire deposit is taken, remove it from the depositCollateralAssets array.\n            depositedCollateralAssets[_account].removeAddress(_collateralAssetAddress, _collateralAssetIndex);\n        }\n        return (transferAmount, feeValuePaid);\n    }\n\n    /* ==== Liquidation ==== */\n\n    /**\n    //  * @notice Calculate amount of collateral to seize during the liquidation process.\n    //  * @param _collateralOraclePriceUSD The address of the collateral asset to be seized.\n    //  * @param _kreskoAssetRepayAmountUSD Kresko asset amount being repaid in exchange for the seized collateral.\n    //  */\n    function _calculateAmountToSeize(\n        FixedPoint.Unsigned memory _collateralOraclePriceUSD,\n        FixedPoint.Unsigned memory _kreskoAssetRepayAmountUSD\n    ) internal view returns (FixedPoint.Unsigned memory) {\n        // Seize amount = (repay amount USD * liquidation incentive / collateral price USD).\n        // Denominate seize amount in collateral type\n        // Apply liquidation incentive multiplier\n        return _kreskoAssetRepayAmountUSD.mul(liquidationIncentiveMultiplier).div(_collateralOraclePriceUSD);\n    }\n\n    /**\n     * @notice Calculates the liquidation incentive collateral amount to be sent to the liquidator\n     * @param _repayKreskoAsset krAsset debt to be repaid.\n     * @param _repayAmount krAsset amount to be repaid.\n     * @param _seizeAmount The calculated amount of collateral assets to be seized.\n     * @param _repayAmountUSD Total USD value of krAsset repayment.\n     * @param _collateralPriceUSD Single collateral units USD price.\n     */\n    function _calculateCollateralToSendAndAdjustDebt(\n        address _collateralSeized,\n        address _repayKreskoAsset,\n        uint256 _repayAmount,\n        uint256 _seizeAmount,\n        FixedPoint.Unsigned memory _repayAmountUSD,\n        FixedPoint.Unsigned memory _collateralPriceUSD\n    ) internal returns (uint256) {\n        uint256 liquidatorDebtBeforeRepay = kreskoAssetDebt[msg.sender][_repayKreskoAsset];\n\n        // If liquidator has no debt remaining set the debt to 0\n        uint256 liquidatorDebtAfterRepay = liquidatorDebtBeforeRepay > _repayAmount\n            ? liquidatorDebtBeforeRepay - _repayAmount\n            : 0;\n\n        if (liquidatorDebtBeforeRepay > 0 && liquidatorDebtAfterRepay == 0) {\n            kreskoAssetDebt[msg.sender][_repayKreskoAsset] = liquidatorDebtAfterRepay;\n            uint256 liquidatorRepayIndex;\n            address[] memory liquidatorAssets = mintedKreskoAssets[msg.sender];\n\n            for (liquidatorRepayIndex; liquidatorRepayIndex < liquidatorAssets.length; liquidatorRepayIndex++) {\n                if (liquidatorAssets[liquidatorRepayIndex] == _repayKreskoAsset) break;\n            }\n            mintedKreskoAssets[msg.sender].removeAddress(_repayKreskoAsset, liquidatorRepayIndex);\n        }\n\n        FixedPoint.Unsigned memory seizedAmountUSD = _toCollateralFixedPointAmount(_collateralSeized, _seizeAmount).mul(\n            _collateralPriceUSD\n        );\n\n        return\n            _fromCollateralFixedPointAmount(\n                _collateralSeized,\n                seizedAmountUSD.sub(_repayAmountUSD).div(_collateralPriceUSD)\n            );\n    }\n\n    /**\n     * @notice Remove Kresko assets and collateral assets from the liquidated user's holdings.\n     * @param _account The account to attempt to liquidate.\n     * @param _krAssetDebt The amount of Kresko assets that the liquidated user owes.\n     * @param _repayAmount The amount of the Kresko asset to be repaid.\n     * @param _seizeAmount The calculated amount of collateral assets to be seized.\n     * @param _repayKreskoAsset The address of the Kresko asset to be repaid.\n     * @param _mintedKreskoAssetIndex The index of the Kresko asset in the user's minted assets array.\n     * @param _collateralAssetToSeize The address of the collateral asset to be seized.\n     * @param _depositedCollateralAssetIndex The index of the collateral asset in the account's collateral assets array.\n     */\n    function _liquidateAssets(\n        address _account,\n        uint256 _krAssetDebt,\n        uint256 _repayAmount,\n        uint256 _seizeAmount,\n        address _repayKreskoAsset,\n        uint256 _mintedKreskoAssetIndex,\n        address _collateralAssetToSeize,\n        uint256 _depositedCollateralAssetIndex\n    ) internal returns (uint256) {\n        // Subtract repaid Kresko assets from liquidated user's recorded debt.\n        kreskoAssetDebt[_account][_repayKreskoAsset] = _krAssetDebt - _repayAmount;\n        // If the liquidation repays the user's entire Kresko asset balance, remove it from minted assets array.\n        if (_repayAmount == _krAssetDebt) {\n            mintedKreskoAssets[_account].removeAddress(_repayKreskoAsset, _mintedKreskoAssetIndex);\n        }\n\n        // Get users collateral deposit amount\n        uint256 collateralDeposit = collateralDeposits[_account][_collateralAssetToSeize];\n\n        if (collateralDeposit > _seizeAmount) {\n            collateralDeposits[_account][_collateralAssetToSeize] = collateralDeposit - _seizeAmount;\n        } else {\n            // This clause means user either has collateralDeposits equal or less than the _seizeAmount\n            _seizeAmount = collateralDeposit;\n            // So we set the collateralDeposits to 0\n            collateralDeposits[_account][_collateralAssetToSeize] = 0;\n            // And remove the asset from the deposits array.\n            depositedCollateralAssets[_account].removeAddress(_collateralAssetToSeize, _depositedCollateralAssetIndex);\n        }\n\n        // Return the actual amount seized\n        return _seizeAmount;\n    }\n\n    /**\n     * ==================================================\n     * ============== Public view functions =============\n     * ==================================================\n     */\n\n    /* ==== Collateral ==== */\n    /**\n     * @notice Returns true if the @param _collateralAsset exists in the protocol\n     */\n    function collateralExists(address _collateralAsset) external view returns (bool) {\n        return collateralAssets[_collateralAsset].exists;\n    }\n\n    /**\n     * @notice Gets an array of collateral assets the account has deposited.\n     * @param _account The account to get the deposited collateral assets for.\n     * @return An array of addresses of collateral assets the account has deposited.\n     */\n    function getDepositedCollateralAssets(address _account) external view returns (address[] memory) {\n        return depositedCollateralAssets[_account];\n    }\n\n    /**\n     * @notice Gets an index for the collateral asset the account has deposited.\n     * @param _account The account to get the index for.\n     * @param _collateralAsset The asset lookup address.\n     * @return i = index of the minted collateral asset.\n     */\n    function getDepositedCollateralAssetIndex(address _account, address _collateralAsset)\n        public\n        view\n        returns (uint256 i)\n    {\n        for (i; i < depositedCollateralAssets[_account].length; i++) {\n            if (depositedCollateralAssets[_account][i] == _collateralAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the collateral value of a particular account.\n     * @dev O(# of different deposited collateral assets by account) complexity.\n     * @param _account The account to calculate the collateral value for.\n     * @return The collateral value of a particular account.\n     */\n    function getAccountCollateralValue(address _account) public view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory totalCollateralValue = FixedPoint.Unsigned(0);\n\n        address[] memory assets = depositedCollateralAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            (FixedPoint.Unsigned memory collateralValue, ) = getCollateralValueAndOraclePrice(\n                asset,\n                collateralDeposits[_account][asset],\n                false // Take the collateral factor into consideration.\n            );\n            totalCollateralValue = totalCollateralValue.add(collateralValue);\n        }\n\n        return totalCollateralValue;\n    }\n\n    /**\n     * @notice Gets an account's minimum collateral value for its Kresko Asset debts.\n     * @dev Accounts that have their collateral value under the minimum collateral value are considered unhealthy\n     * and therefore to avoid liquidations users should maintain a collateral value higher than the value returned.\n     * @param _account The account to calculate the minimum collateral value for.\n     * @return The minimum collateral value of a particular account.\n     */\n    function getAccountMinimumCollateralValue(address _account) public view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory minCollateralValue = FixedPoint.Unsigned(0);\n\n        address[] memory assets = mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            uint256 amount = kreskoAssetDebt[_account][asset];\n            minCollateralValue = minCollateralValue.add(getMinimumCollateralValue(asset, amount));\n        }\n\n        return minCollateralValue;\n    }\n\n    /**\n     * @notice Get the minimum collateral value required to keep a individual debt position healthy.\n     * @param _krAsset The address of the Kresko asset.\n     * @param _amount The Kresko Asset debt amount.\n     * @return minCollateralValue is the minimum collateral value required for this Kresko Asset amount.\n     */\n    function getMinimumCollateralValue(address _krAsset, uint256 _amount)\n        public\n        view\n        kreskoAssetExistsMaybeNotMintable(_krAsset)\n        returns (FixedPoint.Unsigned memory minCollateralValue)\n    {\n        // Calculate the Kresko asset's value weighted by its k-factor.\n        FixedPoint.Unsigned memory weightedKreskoAssetValue = getKrAssetValue(_krAsset, _amount, false);\n        // Calculate the minimum collateral required to back this Kresko asset amount.\n        return weightedKreskoAssetValue.mul(minimumCollateralizationRatio);\n    }\n\n    /**\n     * @notice Gets the collateral value for a single collateral asset and amount.\n     * @param _collateralAsset The address of the collateral asset.\n     * @param _amount The amount of the collateral asset to calculate the collateral value for.\n     * @param _ignoreCollateralFactor Boolean indicating if the asset's collateral factor should be ignored.\n     * @return The collateral value for the provided amount of the collateral asset.\n     */\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) public view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory) {\n        CollateralAsset memory collateralAsset = collateralAssets[_collateralAsset];\n\n        FixedPoint.Unsigned memory fixedPointAmount = _toCollateralFixedPointAmount(_collateralAsset, _amount);\n        FixedPoint.Unsigned memory oraclePrice = FixedPoint.Unsigned(uint256(collateralAsset.oracle.latestAnswer()));\n        FixedPoint.Unsigned memory value = fixedPointAmount.mul(oraclePrice);\n\n        if (!_ignoreCollateralFactor) {\n            value = value.mul(collateralAsset.factor);\n        }\n        return (value, oraclePrice);\n    }\n\n    /* ==== Kresko Assets ==== */\n\n    /**\n     * @notice Returns true if the @param _krAsset exists in the protocol\n     */\n    function krAssetExists(address _krAsset) external view returns (bool) {\n        return kreskoAssets[_krAsset].exists;\n    }\n\n    /**\n     * @notice Gets an array of Kresko assets the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @return An array of addresses of Kresko assets the account has minted.\n     */\n    function getMintedKreskoAssets(address _account) external view returns (address[] memory) {\n        return mintedKreskoAssets[_account];\n    }\n\n    /**\n     * @notice Gets an index for the Kresko asset the account has minted.\n     * @param _account The account to get the minted Kresko assets for.\n     * @param _kreskoAsset The asset lookup address.\n     * @return i = index of the minted Kresko asset.\n     */\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) public view returns (uint256 i) {\n        for (i; i < mintedKreskoAssets[_account].length; i++) {\n            if (mintedKreskoAssets[_account][i] == _kreskoAsset) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the Kresko asset value in USD of a particular account.\n     * @param _account The account to calculate the Kresko asset value for.\n     * @return The Kresko asset value of a particular account.\n     */\n    function getAccountKrAssetValue(address _account) public view returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory value = FixedPoint.Unsigned(0);\n\n        address[] memory assets = mintedKreskoAssets[_account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n            value = value.add(getKrAssetValue(asset, kreskoAssetDebt[_account][asset], false));\n        }\n        return value;\n    }\n\n    /**\n     * @notice Gets the USD value for a single Kresko asset and amount.\n     * @param _kreskoAsset The address of the Kresko asset.\n     * @param _amount The amount of the Kresko asset to calculate the value for.\n     * @param _ignoreKFactor Boolean indicating if the asset's k-factor should be ignored.\n     * @return The value for the provided amount of the Kresko asset.\n     */\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKFactor\n    ) public view returns (FixedPoint.Unsigned memory) {\n        KrAsset memory krAsset = kreskoAssets[_kreskoAsset];\n\n        FixedPoint.Unsigned memory oraclePrice = FixedPoint.Unsigned(uint256(krAsset.oracle.latestAnswer()));\n\n        FixedPoint.Unsigned memory value = FixedPoint.Unsigned(_amount).mul(oraclePrice);\n\n        if (!_ignoreKFactor) {\n            value = value.mul(krAsset.kFactor);\n        }\n\n        return value;\n    }\n\n    /* ==== Liquidation ==== */\n\n    /**\n     * @notice Calculates if an account's current collateral value is under its minimum collateral value\n     * @dev Returns true if the account's current collateral value is below the minimum collateral value\n     * required to consider the position healthy.\n     * @param _account The account to check.\n     * @return A boolean indicating if the account can be liquidated.\n     */\n    function isAccountLiquidatable(address _account) public view returns (bool) {\n        // Get the value of the account's current deposited collateral.\n        FixedPoint.Unsigned memory accountCollateralValue = getAccountCollateralValue(_account);\n        // Get the account's current minimum collateral value required to maintain current debts.\n        FixedPoint.Unsigned memory minAccountCollateralValue = getAccountMinimumCollateralValue(_account);\n\n        return accountCollateralValue.isLessThan(minAccountCollateralValue);\n    }\n\n    /**\n     * @dev Calculates the total value that can be liquidated for a liquidation pair\n     * @param _account address to liquidate\n     * @param _repayKreskoAsset address of the kreskoAsset being repaid on behalf of the liquidatee\n     * @param _collateralAssetToSeize address of the collateral asset being seized from the liquidatee\n     * @return maxLiquidatableUSD USD value that can be liquidated, 0 if the pair has no liquidatable value\n     */\n    function calculateMaxLiquidatableValueForAssets(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) public view returns (FixedPoint.Unsigned memory maxLiquidatableUSD) {\n        // Minimum collateral value required for the krAsset position\n        FixedPoint.Unsigned memory minCollateralValue = getMinimumCollateralValue(\n            _repayKreskoAsset,\n            kreskoAssetDebt[_account][_repayKreskoAsset]\n        );\n\n        // Collateral value for this position\n        (FixedPoint.Unsigned memory collateralValueAvailable, ) = getCollateralValueAndOraclePrice(\n            _collateralAssetToSeize,\n            collateralDeposits[_account][_collateralAssetToSeize],\n            false // take cFactor into consideration\n        );\n        if (collateralValueAvailable.isGreaterThanOrEqual(minCollateralValue)) {\n            return FixedPoint.Unsigned(0);\n        } else {\n            // Get the factors of the assets\n            FixedPoint.Unsigned memory kFactor = kreskoAssets[_repayKreskoAsset].kFactor;\n            FixedPoint.Unsigned memory cFactor = collateralAssets[_collateralAssetToSeize].factor;\n\n            // Calculate how much value is under\n            FixedPoint.Unsigned memory valueUnderMin = minCollateralValue.sub(collateralValueAvailable);\n\n            // Get the divisor which calculates the max repayment from the underwater value\n            FixedPoint.Unsigned memory repayDivisor = kFactor.mul(minimumCollateralizationRatio).sub(\n                liquidationIncentiveMultiplier.sub(burnFee).mul(cFactor)\n            );\n\n            // Max repayment value for this pair\n            maxLiquidatableUSD = valueUnderMin.div(repayDivisor);\n\n            // Get the future collateral value that is being used for the liquidation\n            FixedPoint.Unsigned memory collateralValueRepaid = maxLiquidatableUSD.div(\n                kFactor.mul(liquidationIncentiveMultiplier.add(burnFee))\n            );\n\n            // If it's more than whats available get the max value from how much value is available instead.\n            if (collateralValueRepaid.isGreaterThan(collateralValueAvailable)) {\n                // Reverse the divisor formula to achieve the max repayment from available collateral.\n                // We end up here if the user has multiple positions with different risk profiles.\n                maxLiquidatableUSD = collateralValueAvailable.div(collateralValueRepaid.div(valueUnderMin));\n            }\n\n            // Cascade the liquidations if user has multiple assets.\n            // This is desired because pairs with low cFactor and high kFactor have a\n            // higher collateral requirement than positions with high cFactor and low kFactor.\n\n            // Main reason here is keep the liquidations from happening only on pairs that have a high risk profile.\n            if (mintedKreskoAssets[_account].length + depositedCollateralAssets[_account].length > 2) {\n                // A liquidator can abuse this by only liquidating high risk positions\n                // gaining way more of the users collateral than required if the user has a lower risk pair available.\n\n                // To mitigate this practically to zero:\n                // cFactor^4 the collateral available (cFactor = 1 == nothing happens)\n                // Return:\n                // Get the ratio between max liquidatable USD and diminished collateral available\n                // = (higher value -> higher the risk ratio of this pair)\n                // Divide the maxValue by this ratio and a diminishing max value is returned.\n\n                // For a max profit liquidation strategy jumps to other pairs must happen before\n                // the liquidation value of the risky position becomes the most profitable again.\n\n                return\n                    maxLiquidatableUSD.div(maxLiquidatableUSD.div(collateralValueAvailable.mul(cFactor.pow(4)))).mul(\n                        // Include a burnFee surplus in the liquidation\n                        // so the users can repay their debt.\n                        FixedPoint.Unsigned(ONE_HUNDRED_PERCENT).add(burnFee)\n                    );\n            } else {\n                // For an account holding a single market position\n                // the debt is just repaid in full with a single transaction\n                return maxLiquidatableUSD.mul(FixedPoint.Unsigned(ONE_HUNDRED_PERCENT).add(burnFee));\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
        },
        "src/contracts/utils/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * @dev NOTE: Ownership cannot be renounced as {renounceOwnership} is removed from the implementation.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * The ownership is transferred as a 2-step process:\n * Calling {transferOwnership} will set the new owner as _pendingOwner\n * the {pendingOwner} needs to claim the ownership through {claimOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n    address private _pendingOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PendingOwnershipTransfer(address indexed previousOwner, address indexed pendingOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setPendingOwner(newOwner);\n    }\n\n    /// @notice Needs to be called by pending owner to claim ownership.\n    function claimOwnership() public {\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(_owner, _pendingOwner);\n        _owner = _pendingOwner;\n        _pendingOwner = address(0);\n    }\n\n    function _setPendingOwner(address newOwner) private {\n        _pendingOwner = newOwner;\n        emit PendingOwnershipTransfer(_owner, newOwner);\n    }\n\n    uint256[49] private __gap;\n}\n"
        },
        "src/contracts/interfaces/IKreskoAsset.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ninterface IKreskoAsset is IERC20MetadataUpgradeable {\n    /**\n     * @notice returns the operator role hash\n     */\n    function OPERATOR_ROLE() external returns (bytes32);\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by owner.\n     * @param _account The recipient address of the mint.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burns tokens from an address that have been approved to the sender.\n     * @dev Only callable by owner which must have the appropriate allowance for _account.\n     * @param _account The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _account, uint256 _amount) external;\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external returns (bool);\n}\n"
        },
        "src/contracts/interfaces/INonRebasingWrapperToken.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n/**\n * @title A non-rebasing wrapper token.\n * @notice A non-rebasing token that wraps rebasing tokens to present a balance for each user that\n *   does not change from exogenous events.\n */\ninterface INonRebasingWrapperToken is IERC20Upgradeable {\n    // Emitted when underlying tokens have been deposited, minting this token.\n    event DepositedUnderlying(address indexed account, uint256 underlyingDepositAmount, uint256 mintAmount);\n    // Emitted when underlying tokens have been withdrawn, burning this token.\n    event WithdrewUnderlying(address indexed account, uint256 underlyingWithdrawAmount, uint256 burnAmount);\n\n    /// @notice The underlying token that this contract wraps.\n    function underlyingToken() external returns (address);\n\n    /**\n     * @notice Deposits an amount of the underlying token, minting an amount of this token\n     *   according to the deposit amount.\n     * @dev The amount of the underlying deposited that's used in any calculations is\n     *   the difference in this contract's balance after transferring in underlyingDepositAmount.\n     * @param _underlyingDepositAmount The amount of the underlying token to transfer in as a deposit.\n     * @return The amount of this token that was minted for the deposit.\n     */\n    function depositUnderlying(uint256 _underlyingDepositAmount) external returns (uint256);\n\n    /**\n     * @notice Withdraws an underlying token amount corresponding to the provided\n     *   amount of this token, burning the tokens.\n     * @param _nonRebasingWithdrawalAmount Denominated in this token, the amount\n     *   to burn. Used to calculate the amount of underlying tokens that are withdrawn as a result.\n     * @return The amount of the rebasing underlying token withdrawn.\n     */\n    function withdrawUnderlying(uint256 _nonRebasingWithdrawalAmount) external returns (uint256);\n\n    /**\n     * @notice Gets the amount of the underlying tokens an account owns based off their\n     *   balance of this token.\n     * @param _account The account to view the underlying balance of.\n     * @return The amount of underlying tokens the account owns in this contract.\n     */\n    function balanceOfUnderlying(address _account) external view returns (uint256);\n\n    /**\n     * @notice Gets the amount of underlying tokens corresponding to a provided amount of this contract's tokens.\n     * @dev Loss of precision could result in a marginally lower amount returned, but should never\n     *   result in a higher value than intended. Dust from any lower amounts that are withdrawn\n     *   effectively accumulate to the rest of token holders.\n     * @param _nonRebasingAmount The non-rebasing amount of tokens, i.e. denominated in this contract's tokens.\n     * @return The amount of underlying tokens corresponding to nonRebasingAmount of this contract's tokens.\n     */\n    function getUnderlyingAmount(uint256 _nonRebasingAmount) external view returns (uint256);\n}\n"
        },
        "src/contracts/libraries/FixedPoint.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMathUpgradeable for uint256;\n    using SignedSafeMathUpgradeable for int256;\n\n    uint256 internal constant FP_DECIMALS = 18;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 internal constant FP_SCALING_FACTOR = 10**FP_DECIMALS;\n\n    // --------------------------------------- UNSIGNED ---------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED ------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored\n    //   internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or\n     * division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}\n"
        },
        "src/contracts/libraries/Arrays.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.4;\n\n/**\n * @title Library for operations on arrays\n */\nlibrary Arrays {\n    /**\n     * @dev Removes an element by copying the last element to the element to remove's place and removing\n     * the last element.\n     * @param _addresses The address array containing the item to be removed.\n     * @param _elementToRemove The element to be removed.\n     * @param _elementIndex The index of the element to be removed.\n     */\n    function removeAddress(\n        address[] storage _addresses,\n        address _elementToRemove,\n        uint256 _elementIndex\n    ) internal {\n        require(_addresses[_elementIndex] == _elementToRemove, \"Arrays: incorrect removal index\");\n\n        uint256 lastIndex = _addresses.length - 1;\n        // If the index to remove is not the last one, overwrite the element at the index\n        // with the last element.\n        if (_elementIndex != lastIndex) {\n            _addresses[_elementIndex] = _addresses[lastIndex];\n        }\n        // Remove the last element.\n        _addresses.pop();\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/math/SignedSafeMathUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMathUpgradeable {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
        },
        "src/contracts/test/RebasingToken.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../libraries/FixedPoint.sol\";\n\ncontract RebasingToken {\n    using FixedPoint for FixedPoint.Unsigned;\n\n    FixedPoint.Unsigned public rebaseFactor;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) public _allowances;\n\n    constructor(uint256 _rebaseFactor) {\n        setRebaseFactor(_rebaseFactor);\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _allowances[msg.sender][_spender] = _amount;\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool) {\n        return _transfer(_from, _to, _amount);\n    }\n\n    function transfer(address _to, uint256 _amount) external returns (bool) {\n        return _transfer(msg.sender, _to, _amount);\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) private returns (bool) {\n        uint256 nonRebasedAmount = fromRebasedAmount(_amount);\n        if (_from != msg.sender) {\n            _allowances[_from][_to] -= _amount;\n        }\n        require(_balances[_from] >= nonRebasedAmount, \"ERC20: transfer amount exceeds balance\");\n        _balances[_from] -= nonRebasedAmount;\n        _balances[_to] += nonRebasedAmount;\n        return true;\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _balances[_account] += fromRebasedAmount(_amount);\n    }\n\n    function setBalanceOf(address _account, uint256 _amount) external {\n        _balances[_account] = fromRebasedAmount(_amount);\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return toRebasedAmount(_balances[_account]);\n    }\n\n    function toRebasedAmount(uint256 _nonRebasedAmount) private view returns (uint256) {\n        return FixedPoint.Unsigned(_nonRebasedAmount).mul(rebaseFactor).rawValue;\n    }\n\n    function fromRebasedAmount(uint256 _rebasedAmount) private view returns (uint256) {\n        return FixedPoint.Unsigned(_rebasedAmount).div(rebaseFactor).rawValue;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"Test Rebasing Token\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"FOO\";\n    }\n\n    function setRebaseFactor(uint256 _rebaseFactor) public {\n        rebaseFactor = FixedPoint.Unsigned(_rebaseFactor);\n    }\n}\n"
        },
        "src/contracts/test/interfaces/IKresko.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\nimport \"../../libraries/FixedPoint.sol\";\n\ninterface IKresko {\n    /**\n     * @notice Information on a token that is a Kresko asset.\n     * @dev Each Kresko asset has 18 decimals.\n     * @param kFactor The k-factor used for calculating the required collateral value for Kresko asset debt.\n     * @param oracle The oracle that provides the USD price of one Kresko asset.\n     * @param exists Whether the Kresko asset exists within the protocol.\n     * @param mintable Whether the Kresko asset can be minted.\n     */\n    struct KrAsset {\n        FixedPoint.Unsigned kFactor;\n        address oracle;\n        bool exists;\n        bool mintable;\n    }\n\n    struct CollateralAsset {\n        FixedPoint.Unsigned factor;\n        address oracle;\n        address underlyingRebasingToken;\n        uint8 decimals;\n        bool exists;\n    }\n\n    function getMintedKreskoAssets(address user) external view returns (address[] memory);\n\n    function getDepositedCollateralAssets(address user) external view returns (address[] memory);\n\n    function isAccountLiquidatable(address user) external view returns (bool);\n\n    function liquidate(\n        address _account,\n        address _repayKreskoAsset,\n        uint256 _repayAmount,\n        address _collateralAssetToSeize,\n        uint256 _mintedKreskoAssetIndex,\n        uint256 _depositedCollateralAssetIndex,\n        bool _keepKrAssetDebt\n    ) external;\n\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory);\n\n    function calculateMaxLiquidatableValueForAssets(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (FixedPoint.Unsigned memory);\n\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory);\n\n    function depositCollateral(\n        address to,\n        address _collateralAsset,\n        uint256 _amount\n    ) external;\n\n    function mintKreskoAsset(\n        address to,\n        address _kreskoAsset,\n        uint256 _amount\n    ) external;\n\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKfactor\n    ) external view returns (FixedPoint.Unsigned memory);\n\n    function kreskoAssets(address _kreskoAsset) external view returns (KrAsset memory);\n\n    function collateralAssets(address _collateralAsset) external view returns (CollateralAsset memory);\n\n    function withdrawCollateral(\n        address from,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    function kreskoAssetDebt(address, address) external view returns (uint256);\n\n    function getAccountMinimumCollateralValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function getMinimumCollateralValue(address _krAsset, uint256 _amount)\n        external\n        view\n        returns (FixedPoint.Unsigned memory);\n\n    function getMintedKreskoAssetsIndex(address _account, address _kreskoAsset) external view returns (uint256 i);\n\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory);\n}\n"
        },
        "src/contracts/test/ExampleFlashLiquidator.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IWETH10.sol\";\nimport \"./interfaces/IKresko.sol\";\nimport \"../libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract ExampleFlashLiquidator is IERC3156FlashBorrower {\n    using FixedPoint for FixedPoint.Unsigned;\n    bytes32 public immutable CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IWETH10 public weth10;\n    IKresko public kresko;\n    uint256 public flashBalance;\n    address owner;\n\n    constructor(address _weth10, address _kresko) {\n        weth10 = IWETH10(_weth10);\n        kresko = IKresko(_kresko);\n        owner = msg.sender;\n    }\n\n    function flashLiquidate(\n        address _kreskoUser,\n        address _kreskoAssetToRepay,\n        address _rewardCollateral\n    ) external {\n        require(kresko.isAccountLiquidatable(_kreskoUser), \"!liquidatable\");\n\n        // Calculate amount to repay and amount to flashloan\n        (uint256 flashAmount, uint256 repayAmount) = calculateAmountToFlashLoan(\n            _kreskoUser,\n            _kreskoAssetToRepay,\n            _rewardCollateral\n        );\n\n        // Encode data for `onFlashLoan` callback\n        bytes memory data = abi.encode(_kreskoUser, _kreskoAssetToRepay, _rewardCollateral, repayAmount);\n        weth10.flashLoan(this, address(weth10), flashAmount, data);\n    }\n\n    /// @dev Calculates the amount to flash weth\n    /// @dev This amount will allow us to mint the exact amount of kresko asset to repay\n    function calculateAmountToFlashLoan(\n        address _kreskoUser,\n        address _kreskoAssetToRepay,\n        address _rewardCollateral\n    ) public view returns (uint256 amountToFlashLoan, uint256 amountToRepay) {\n        FixedPoint.Unsigned memory maxLiquidationValue = kresko.calculateMaxLiquidatableValueForAssets(\n            _kreskoUser,\n            _kreskoAssetToRepay,\n            _rewardCollateral\n        );\n\n        (FixedPoint.Unsigned memory oneWeth, ) = kresko.getCollateralValueAndOraclePrice(\n            address(weth10),\n            1 ether,\n            false\n        );\n\n        FixedPoint.Unsigned memory krAssetValue = kresko.getKrAssetValue(_kreskoAssetToRepay, 1 ether, false);\n        FixedPoint.Unsigned memory kFactor = kresko.kreskoAssets(_kreskoAssetToRepay).kFactor;\n        FixedPoint.Unsigned memory cFactor = kresko.collateralAssets(address(weth10)).factor;\n        FixedPoint.Unsigned memory MCR = kresko.minimumCollateralizationRatio();\n\n        amountToFlashLoan = maxLiquidationValue.div(oneWeth.mul(cFactor)).mul(MCR).rawValue;\n        uint256 kreskoUserDebtAmount = kresko.kreskoAssetDebt(_kreskoUser, _kreskoAssetToRepay);\n        uint256 maxKrAssetRepayAmount = maxLiquidationValue.mul(kFactor).div(krAssetValue).rawValue;\n\n        amountToRepay = kreskoUserDebtAmount > maxKrAssetRepayAmount ? maxKrAssetRepayAmount : kreskoUserDebtAmount;\n    }\n\n    /// @dev Helper to get the asset indexes for the user\n    /// @notice YOU MOST LIKELY WANNA DO THIS OFFCHAIN IN AURORA DUE TO GAS LIMITS - THIS IS STRICTLY FOR SIMPLICITY.\n    function getAssetIndexes(\n        address _kreskoUser,\n        address _rewardCollateral,\n        address _repayKreskoAsset\n    ) public view returns (uint256 collateralIndex, uint256 krAssetIndex) {\n        address[] memory userCollaterals = kresko.getDepositedCollateralAssets(_kreskoUser);\n        address[] memory userMintedAssets = kresko.getMintedKreskoAssets(_kreskoUser);\n\n        require(userCollaterals.length > 0, \"!collaterals\");\n        require(userMintedAssets.length > 0, \"!mints\");\n\n        for (collateralIndex; collateralIndex < userCollaterals.length; collateralIndex++) {\n            if (userCollaterals[collateralIndex] == _rewardCollateral) break;\n        }\n\n        for (krAssetIndex; krAssetIndex < userCollaterals.length; krAssetIndex++) {\n            if (userMintedAssets[krAssetIndex] == _repayKreskoAsset) break;\n        }\n    }\n\n    /**\n     * @dev Receive a flash loan to liquidate a kresko user (from weth10, not useful for this simple use case)\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(msg.sender == address(weth10), \"nono\");\n\n        // Decode the data we passed through WETH10.\n        (address _kreskoUser, address _repayKreskoAsset, address _rewardCollateral, uint256 _repayAmount) = abi.decode(\n            data,\n            (address, address, address, uint256)\n        );\n\n        uint256 rewardTokenBalBefore = IERC20(_rewardCollateral).balanceOf(address(this));\n\n        flashBalance = amount;\n\n        // Get the collateral indexes\n        (uint256 collateralIndex, uint256 krAssetIndex) = getAssetIndexes(\n            _kreskoUser,\n            _rewardCollateral,\n            _repayKreskoAsset\n        );\n\n        // Deposit our flash balance to Kresko as Collateral\n        kresko.depositCollateral(address(this), address(weth10), flashBalance);\n        // Ensure we are not repaying more than the debt\n\n        // Mint the repayment asset\n        kresko.mintKreskoAsset(address(this), _repayKreskoAsset, _repayAmount);\n\n        // Liqudate the user\n        kresko.liquidate(\n            _kreskoUser,\n            _repayKreskoAsset,\n            _repayAmount,\n            _rewardCollateral,\n            krAssetIndex,\n            collateralIndex,\n            false // do not keep debt - we want the profits after repaying this flashloan\n        );\n\n        // Withdraw our collateral back = flashloan amount\n        kresko.withdrawCollateral(address(this), address(weth10), flashBalance, 0);\n\n        uint256 rewardTokenBalAfter = IERC20(_rewardCollateral).balanceOf(address(this));\n\n        require(rewardTokenBalAfter > rewardTokenBalBefore, \"FAIL: No profits\");\n        return CALLBACK_SUCCESS;\n    }\n\n    function sendProfits(IERC20 _token) external {\n        require(msg.sender == owner, \"nono\");\n        _token.transfer(msg.sender, _token.balanceOf(address(this)));\n    }\n}\n"
        },
        "src/contracts/test/interfaces/IERC3156FlashBorrower.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
        },
        "src/contracts/test/interfaces/IWETH10.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IWETH10 {\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
        },
        "hardhat/console.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
        },
        "src/contracts/uniswap/v2-periphery/interfaces/IWETH.sol": {
            "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
        },
        "src/contracts/uniswap/v2-periphery/interfaces/IERC20.sol": {
            "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
        },
        "src/contracts/uniswap/v2-periphery/interfaces/IUniswapV2Router01.sol": {
            "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
        },
        "src/contracts/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol": {
            "content": "pragma solidity >=0.6.2;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
        },
        "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
            "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
        },
        "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
            "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
        },
        "src/contracts/uniswap/v2-periphery/libraries/UniswapV2OracleLibrary.sol": {
            "content": "pragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(address pair)\n        internal\n        view\n        returns (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        )\n    {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n"
        },
        "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
            "content": "pragma solidity >=0.4.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
        },
        "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
            "content": "pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
        },
        "@openzeppelin/contracts/security/Pausable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
        },
        "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
        },
        "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
        },
        "src/contracts/test/Token.sol": {
            "content": "pragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract Token is ERC20PresetMinterPauser {\n    uint8 private _decimals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _supply,\n        uint8 _dec\n    ) ERC20PresetMinterPauser(_name, _symbol) {\n        mint(msg.sender, _supply);\n        _decimals = _dec;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function mint(address _to, uint256 _amount) public override {\n        // just allow all minting\n        _mint(_to, _amount);\n    }\n}\n"
        },
        "src/contracts/flux/FluxPriceFeed.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @notice Simple data posting on chain of a scalar value, compatible with Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceFeed is AccessControl, AggregatorV2V3Interface {\n    bytes32 public constant VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n    }\n    mapping(uint32 => Transmission) /* aggregator round ID */\n        internal s_transmissions;\n\n    /**\n     * @param _validator the initial validator that can post data to this contract\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param _description short human-readable description of observable this contract's answers pertain to\n     */\n    constructor(\n        address _validator,\n        uint8 _decimals,\n        string memory _description\n    ) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(VALIDATOR_ROLE, _validator);\n        decimals = _decimals;\n        s_description = _description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceFeed 1.0.0\";\n    }\n\n    /*\n     * Transmission logic\n     */\n\n    /**\n     * @notice indicates that a new report was transmitted\n     * @param aggregatorRoundId the round to which this report was assigned\n     * @param answer value posted by validator\n     * @param transmitter address from which the report was transmitted\n     */\n    event NewTransmission(uint32 indexed aggregatorRoundId, int192 answer, address transmitter);\n\n    /**\n     * @notice details about the most recent report\n     * @return _latestAnswer value from latest report\n     * @return _latestTimestamp when the latest report was transmitted\n     */\n    function latestTransmissionDetails() external view returns (int192 _latestAnswer, uint64 _latestTimestamp) {\n        require(msg.sender == tx.origin, \"Only callable by EOA\");\n        return (s_transmissions[latestAggregatorRoundId].answer, s_transmissions[latestAggregatorRoundId].timestamp);\n    }\n\n    /**\n     * @notice transmit is called to post a new report to the contract\n     * @param _answer latest answer\n     */\n    function transmit(int192 _answer) external {\n        require(hasRole(VALIDATOR_ROLE, msg.sender), \"Caller is not a validator\");\n\n        // Check the report contents, and record the result\n        latestAggregatorRoundId++;\n        s_transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp));\n\n        emit NewTransmission(latestAggregatorRoundId, _answer, msg.sender);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return s_transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return s_transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return s_transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal s_description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return s_description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = s_transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = s_transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
        },
        "src/contracts/flux/FluxPriceAggregator.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title Flux first-party price feed oracle aggregator\n * @author fluxprotocol.org\n * @notice Aggregates from multiple first-party price oracles (FluxPriceFeed.sol), compatible with\n *     Chainlink V2 and V3 aggregator interface\n */\ncontract FluxPriceAggregator is AccessControl, AggregatorV2V3Interface, Pausable {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    uint32 public latestAggregatorRoundId;\n\n    // Transmission records the answer from the transmit transaction at\n    // time timestamp\n    struct Transmission {\n        int192 answer; // 192 bits ought to be enough for anyone\n        uint64 timestamp;\n    }\n    mapping(uint32 => Transmission) /* aggregator round ID */\n        internal transmissions;\n\n    uint256 public minDelay = 1 minutes;\n    address[] public oracles;\n\n    /**\n     * @dev Initialize oracles and fetch initial prices\n     * @param _admin the initial admin that can aggregate data from and set the oracles\n     * @param _oracles the oracles to aggregate data from\n     * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n     * @param __description short human-readable description of observable this contract's answers pertain to\n     */\n\n    constructor(\n        address _admin,\n        address[] memory _oracles,\n        uint8 _decimals,\n        string memory __description\n    ) {\n        _setupRole(ADMIN_ROLE, _admin);\n        oracles = _oracles;\n        decimals = _decimals;\n        _description = __description;\n    }\n\n    /*\n     * Versioning\n     */\n    function typeAndVersion() external pure virtual returns (string memory) {\n        return \"FluxPriceAggregator 1.0.0\";\n    }\n\n    /*\n     * Publicly-callable mutative functions\n     */\n\n    /// @notice Update prices, callable by anyone\n    function updatePrices() public whenNotPaused {\n        // require min delay since lastUpdate\n        require(block.timestamp > transmissions[latestAggregatorRoundId].timestamp + minDelay);\n\n        // fetch sum of latestAnswer from oracles\n        int256 sum = 0;\n        for (uint256 i = 0; i < oracles.length; i++) {\n            sum += AggregatorV2V3Interface(oracles[i]).latestAnswer();\n        }\n\n        // calculate average of sum\n        int192 _answer = int192(int256(uint256(sum) / oracles.length));\n\n        // update round\n        latestAggregatorRoundId++;\n        transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp));\n\n        emit AnswerUpdated(_answer, latestAggregatorRoundId, block.timestamp);\n    }\n\n    /*\n     * Admin-only functions\n     */\n\n    /// @notice Changes min delay, only callable by admin\n    function setDelay(uint256 _minDelay) public {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        minDelay = _minDelay;\n    }\n\n    /// @notice Changes oracles, only callable by admin\n    function setOracles(address[] memory _oracles) public {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        oracles = _oracles;\n    }\n\n    /// @notice Pauses or unpauses updating the price, only callable by admin\n    function pause(bool __pause) public {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        if (__pause) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Overrides the price, only callable by admin\n    function setManualAnswer(int192 _answer) public {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not a admin\");\n        latestAggregatorRoundId++;\n        transmissions[latestAggregatorRoundId] = Transmission(_answer, uint64(block.timestamp));\n        emit AnswerUpdated(_answer, latestAggregatorRoundId, block.timestamp);\n    }\n\n    /*\n     * v2 Aggregator interface\n     */\n\n    /**\n     * @notice answer from the most recent report\n     */\n    function latestAnswer() public view virtual override returns (int256) {\n        return transmissions[latestAggregatorRoundId].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which last report was transmitted\n     */\n    function latestTimestamp() public view virtual override returns (uint256) {\n        return transmissions[latestAggregatorRoundId].timestamp;\n    }\n\n    /**\n     * @notice Aggregator round in which last report was transmitted\n     */\n    function latestRound() public view virtual override returns (uint256) {\n        return latestAggregatorRoundId;\n    }\n\n    /**\n     * @notice answer of report from given aggregator round\n     * @param _roundId the aggregator round of the target report\n     */\n    function getAnswer(uint256 _roundId) public view virtual override returns (int256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return transmissions[uint32(_roundId)].answer;\n    }\n\n    /**\n     * @notice timestamp of block in which report from given aggregator round was transmitted\n     * @param _roundId aggregator round of target report\n     */\n    function getTimestamp(uint256 _roundId) public view virtual override returns (uint256) {\n        if (_roundId > 0xFFFFFFFF) {\n            return 0;\n        }\n        return transmissions[uint32(_roundId)].timestamp;\n    }\n\n    /*\n     * v3 Aggregator interface\n     */\n\n    string private constant V3_NO_DATA_ERROR = \"No data present\";\n\n    /**\n     * @return answers are stored in fixed-point format, with this many digits of precision\n     */\n    uint8 public immutable override decimals;\n\n    /**\n     * @notice aggregator contract version\n     */\n    uint256 public constant override version = 1;\n\n    string internal _description;\n\n    /**\n     * @notice human-readable description of observable this contract is reporting on\n     */\n    function description() public view virtual override returns (string memory) {\n        return _description;\n    }\n\n    /**\n     * @notice details for the given aggregator round\n     * @param _roundId target aggregator round. Must fit in uint32\n     * @return roundId _roundId\n     * @return answer answer of report from given _roundId\n     * @return startedAt timestamp of block in which report from given _roundId was transmitted\n     * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n     * @return answeredInRound _roundId\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n        Transmission memory transmission = transmissions[uint32(_roundId)];\n        return (_roundId, transmission.answer, transmission.timestamp, transmission.timestamp, _roundId);\n    }\n\n    /**\n     * @notice aggregator details for the most recently transmitted report\n     * @return roundId aggregator round of latest report\n     * @return answer answer of latest report\n     * @return startedAt timestamp of block containing latest report\n     * @return updatedAt timestamp of block containing latest report\n     * @return answeredInRound aggregator round of latest report\n     */\n    function latestRoundData()\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = latestAggregatorRoundId;\n\n        // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n        // require(roundId != 0, V3_NO_DATA_ERROR);\n\n        Transmission memory transmission = transmissions[uint32(roundId)];\n        return (roundId, transmission.answer, transmission.timestamp, transmission.timestamp, roundId);\n    }\n}\n"
        },
        "src/contracts/KrStaking.sol": {
            "content": "pragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract KrStaking is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256[] rewardDebts;\n    }\n\n    struct PoolInfo {\n        IERC20 depositToken; // Address of LP token contract.\n        uint128 allocPoint; // How many allocation points assigned to this pool.\n        uint128 lastRewardBlock; // Last block number that rewards distribution occurs.\n        uint256[] accRewardPerShares; // Accumulated rewards per share, times 1e12.\n        address[] rewardTokens; // Reward tokens for this pool.\n    }\n\n    struct Reward {\n        uint256 pid;\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n\n    // Reward token -> Tokens per block\n    mapping(address => uint256) public rewardPerBlockFor;\n    uint256 internal rewardTokenAmount;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n\n    // Info of each staked user.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // Total allocation points.\n    uint128 public totalAllocPoint;\n    // The block when rewards start dripping.\n    uint128 public startBlock;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimRewards(address indexed user, address indexed rewardToken, uint256 amount);\n\n    function initialize(\n        address[] calldata _rewardTokens,\n        uint256[] calldata _rewardPerBlocks,\n        IERC20 _depositToken,\n        uint128 _allocPoint\n    ) external initializer {\n        require(_rewardPerBlocks.length == _rewardTokens.length, \"All reward tokens need rewardPerBlock amount\");\n\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        // Set initial reward tokens and allocations\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            rewardPerBlockFor[_rewardTokens[i]] = _rewardPerBlocks[i];\n        }\n        rewardTokenAmount = _rewardTokens.length;\n\n        startBlock = uint128(block.number);\n\n        // Push the initial pool in.\n        poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: startBlock,\n                accRewardPerShares: new uint256[](_rewardTokens.length),\n                rewardTokens: _rewardTokens\n            })\n        );\n\n        totalAllocPoint += _allocPoint;\n    }\n\n    /**** MODIFIERS ****/\n\n    /// @notice Ensures the @param _depositToken does not already have a pool for it\n    modifier ensurePoolDoesNotExist(IERC20 _depositToken) {\n        for (uint256 i; i < poolInfo.length; i++) {\n            require(address(poolInfo[i].depositToken) != address(_depositToken), \"KR: poolExists\");\n        }\n        _;\n    }\n\n    /// @notice Ensures the @param _pid does actually exist\n    modifier ensurePoolExists(uint256 _pid) {\n        require(address(poolInfo[_pid].depositToken) != address(0), \"KR: !poolExists\");\n        _;\n    }\n\n    /**** VIEWS ****/\n\n    /**\n     * @notice View to get pending rewards from a certain pool\n     * @param _pid id of pool in `poolInfo` to check rewards from\n     * @param _user id of user in `userInfo[_pid]`\n     */\n    function pendingRewards(uint256 _pid, address _user) public view returns (Reward memory rewards) {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][_user];\n        uint256 depositTokenSupply = pool.depositToken.balanceOf(address(this));\n\n        uint256 rewardTokensLength = pool.rewardTokens.length;\n        rewards = Reward({pid: _pid, tokens: pool.rewardTokens, amounts: new uint256[](rewardTokensLength)});\n\n        if (depositTokenSupply != 0 && user.amount > 0) {\n            for (uint256 rewardIndex; rewardIndex < rewardTokensLength; rewardIndex++) {\n                uint256 accRewardPerShare = pool.accRewardPerShares[rewardIndex];\n\n                uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n\n                accRewardPerShare += (reward * 1e12) / depositTokenSupply;\n\n                rewards.amounts[rewardIndex] = (user.amount * accRewardPerShare) / 1e12 - user.rewardDebts[rewardIndex];\n                rewards.tokens[rewardIndex] = pool.rewardTokens[rewardIndex];\n            }\n        }\n    }\n\n    /**\n     * @notice View to get pending rewards from all pools for a user\n     * @param _user user to get rewards for\n     */\n    function allPendingRewards(address _user) external view returns (Reward[] memory allRewards) {\n        allRewards = new Reward[](poolInfo.length);\n        for (uint256 pid; pid < poolInfo.length; pid++) {\n            Reward memory poolReward = pendingRewards(pid, _user);\n            allRewards[pid] = poolReward;\n        }\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    function getPidFor(address _token) external view returns (uint256 pid, bool found) {\n        for (pid; pid < poolInfo.length; pid++) {\n            if (address(poolInfo[pid].depositToken) == _token) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    function getDepositAmount(uint256 _pid) external view returns (uint256) {\n        return userInfo[_pid][msg.sender].amount;\n    }\n\n    /**** ADMIN FUNCTIONS ****/\n\n    /**\n     * @notice Adjust reward per block for a particular reward token\n     * @param _rewardToken token to adjust the drip for\n     * @param _rewardPerBlock tokens to drip per block\n     */\n    function setRewardPerBlockFor(address _rewardToken, uint256 _rewardPerBlock)\n        external\n        payable\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        rewardPerBlockFor[_rewardToken] = _rewardPerBlock;\n    }\n\n    /**\n     * @notice Adds a new reward pool\n     * @param _rewardTokens tokens to reward from this pool\n     * @param _depositToken token to deposit for rewards\n     * @param _allocPoint weight of rewards this pool receives\n     */\n    function addPool(\n        address[] calldata _rewardTokens,\n        IERC20 _depositToken,\n        uint128 _allocPoint\n    ) external payable onlyRole(DEFAULT_ADMIN_ROLE) ensurePoolDoesNotExist(_depositToken) {\n        totalAllocPoint += _allocPoint;\n        if (_rewardTokens.length > rewardTokenAmount) {\n            rewardTokenAmount = _rewardTokens.length;\n        }\n        poolInfo.push(\n            PoolInfo({\n                depositToken: _depositToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: uint128(block.number),\n                accRewardPerShares: new uint256[](rewardTokenAmount),\n                rewardTokens: _rewardTokens\n            })\n        );\n    }\n\n    /**\n     * @notice Set new allocations and reward tokens for a pool\n     * @param _pid pool to modify\n     * @param _newAllocPoint new allocation (weight) for rewards\n     * @param _rewardTokens set new reward tokens for this pool\n     */\n    function setPool(\n        uint256 _pid,\n        uint128 _newAllocPoint,\n        address[] calldata _rewardTokens\n    ) external payable onlyRole(DEFAULT_ADMIN_ROLE) ensurePoolExists(_pid) {\n        totalAllocPoint -= poolInfo[_pid].allocPoint + _newAllocPoint;\n        poolInfo[_pid].allocPoint = _newAllocPoint;\n        if (_rewardTokens.length > 0) {\n            poolInfo[_pid].rewardTokens = _rewardTokens;\n        }\n    }\n\n    /** PUBLIC STATE MODIFYING FUNCTIONS */\n\n    /**\n     * @notice Updates all pools to be up-to date\n     * @notice Cannot be updated more than once per block\n     */\n    function massUpdatePools() public payable {\n        for (uint256 pid; pid < poolInfo.length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /**\n     * @notice Updates a pools reward variables to be up-to date\n     * @notice Cannot be updated more than once per block\n     * @param _pid pool to update\n     */\n    function updatePool(uint256 _pid) public payable returns (PoolInfo memory pool) {\n        pool = poolInfo[_pid];\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = pool.depositToken.balanceOf(address(this));\n\n            // Do not drip rewards for 0 supply\n            if (lpSupply > 0) {\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    // Reward per block for the reward token in the index\n                    uint256 rewardPerBlock = rewardPerBlockFor[pool.rewardTokens[rewardIndex]];\n                    uint256 blocks = block.number - pool.lastRewardBlock;\n\n                    // Allocation for this particular pool\n                    uint256 reward = (rewardPerBlock * blocks * pool.allocPoint) / totalAllocPoint;\n\n                    // Increment accumulated rewards per share since block height is increased\n                    pool.accRewardPerShares[rewardIndex] += (reward * 1e12) / lpSupply;\n                }\n            }\n            // No further updates are allowed within same block height\n            pool.lastRewardBlock = uint128(block.number);\n            poolInfo[_pid] = pool;\n        }\n    }\n\n    /**\n     * @notice Deposits tokens for @param _to in a pool for reward allocation\n     * @param _to address that msg.sender deposits tokens for\n     * @param _pid in `poolInfo`\n     * @param _amount amount to deposit\n     */\n    function deposit(\n        address _to,\n        uint256 _pid,\n        uint256 _amount\n    ) external payable nonReentrant ensurePoolExists(_pid) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = userInfo[_pid][_to];\n\n        // Transfer and add to balance\n        if (_amount > 0) {\n            if (user.rewardDebts.length == 0) {\n                user.rewardDebts = new uint256[](pool.rewardTokens.length);\n            }\n            unchecked {\n                pool.depositToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n                user.amount += _amount;\n                // Update rewards paid with possibly increased deposit amount\n                for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n                    user.rewardDebts[rewardIndex] += (_amount * pool.accRewardPerShares[rewardIndex]) / 1e12;\n                }\n            }\n            emit Deposit(_to, _pid, _amount);\n        }\n    }\n\n    /**\n     * @notice Withdraw staked tokens and/or claim rewards.\n     * @notice IF @param _claimRewards = true && @param _amount = 0 will claim only\n     * @param _pid id in `poolInfo`\n     * @param _amount amount to withdraw\n     * @param _claimRewards does claim rewards\n     * @param _claimRewardsTo address to send rewards to\n     */\n    function withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        bool _claimRewards,\n        address _claimRewardsTo\n    ) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        // Send rewards to user\n        if (_claimRewards) {\n            claimRewards(pool, user, _claimRewardsTo);\n        }\n        if (_amount > 0) {\n            // If user tries to withdraw amount > balance, just send the whole balance\n            if (_amount > user.amount) {\n                _amount = user.amount;\n                user.amount = 0;\n            } else {\n                user.amount -= _amount;\n            }\n\n            pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n            emit Withdraw(msg.sender, _pid, _amount);\n        }\n\n        // Update reward debts\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * (pool.accRewardPerShares[rewardIndex])) / 1e12;\n        }\n    }\n\n    /**\n     * @notice Withdraw staked tokens for an user through a trusted operator contract (eg. Kresko Zapper)\n     * @notice IF @param _claimRewards = true && @param _amount = 0 will claim only\n     * @param _for user to withdraw from\n     * @param _pid id in `poolInfo`\n     * @param _amount amount to withdraw\n     * @param _claimRewards does claim rewards\n     * @param _claimRewardsTo address to send rewards to\n     */\n    function withdrawFor(\n        address _for,\n        uint256 _pid,\n        uint256 _amount,\n        bool _claimRewards,\n        address _claimRewardsTo\n    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = userInfo[_pid][_for];\n\n        // Send rewards to user\n        if (_claimRewards) {\n            claimRewards(pool, user, _claimRewardsTo);\n        }\n        if (_amount > 0) {\n            // If user tries to withdraw amount > balance, just send the whole balance\n            if (_amount > user.amount) {\n                _amount = user.amount;\n                user.amount = 0;\n            } else {\n                user.amount -= _amount;\n            }\n\n            pool.depositToken.safeTransfer(address(msg.sender), _amount);\n\n            emit Withdraw(_for, _pid, _amount);\n        }\n\n        // Update reward debts\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = (user.amount * (pool.accRewardPerShares[rewardIndex])) / 1e12;\n        }\n    }\n\n    /**\n     * @notice Emergency function for withdrawing users total staking balance in a pool\n     * @notice Usage is for emergency only as this will ZERO your rewards.\n     * @param _pid pool id to withdraw all deposited tokens from\n     */\n    function emergencyWithdraw(uint256 _pid) external payable nonReentrant {\n        PoolInfo memory pool = updatePool(_pid);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.depositToken.safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            user.rewardDebts[rewardIndex] = 0;\n        }\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    }\n\n    /**\n     * @notice A rescue function for missent msg.value\n     * @notice Since we are using payable functions to save gas on calls\n     */\n    function rescueNative() external payable onlyRole(DEFAULT_ADMIN_ROLE) {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n     * @notice A rescue function for missent tokens / airdrops\n     * @notice THIS CANNOT WITHDRAW ANY POOL TOKENS due `ensurePoolDoesNotExist` modifier.\n     */\n    function rescueNonPoolToken(IERC20 _tokenToRescue, uint256 _amount)\n        external\n        payable\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        ensurePoolDoesNotExist(_tokenToRescue)\n    {\n        _tokenToRescue.safeTransfer(msg.sender, _amount);\n    }\n\n    /** INTERNALS */\n\n    /**\n     * @notice Loops over pools reward tokens and sends them to the user\n     * @param pool pool to send rewards from in `poolInfo`\n     * @param user users info in the @param pool\n     * @param to user to send rewards to\n     */\n    function claimRewards(\n        PoolInfo memory pool,\n        UserInfo memory user,\n        address to\n    ) internal {\n        for (uint256 rewardIndex; rewardIndex < pool.rewardTokens.length; rewardIndex++) {\n            uint256 rewardDebt = user.rewardDebts[rewardIndex];\n            uint256 pending = (user.amount * (pool.accRewardPerShares[rewardIndex])) / 1e12 - rewardDebt;\n\n            if (pending > 0) {\n                IERC20(pool.rewardTokens[rewardIndex]).safeTransfer(to, pending);\n                emit ClaimRewards(to, pool.rewardTokens[rewardIndex], pending);\n            }\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "src/contracts/misc/NonRebasingWrapperToken.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/OwnableUpgradeable.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n/**\n * @title A non-rebasing wrapper token.\n * @notice A non-rebasing token that wraps rebasing tokens to present a balance for each user that\n *   does not change from exogenous events. The logic in Kresko.sol assumes that collateral token\n *   balances do not rebase. This contract is intended to allow Kresko.sol to support rebasing tokens\n *   as collateral, but it can be used in any setting just as a normal token.\n *   Rebasing tokens are tokens whose balances across all holders change due to exogenous reasons\n *   (i.e. not just token transfers, for example Aave's aTokens that adjust balances as they accrue\n *   interest). Such rebasing tokens can be wrapped in this contract, instead representing them as\n *   a token whose balances do not rebase but have an internal exchange rate between the underlying\n *   rebasing token and this non-rebasing wrapper token (e.g. how Compound's cTokens do not rebase but\n *   use an internal exchange rate to represent accrued interest). This is useful to allow protocols\n *   (like Kresko) that have accounting rules that assume deposited tokens are non-rebasing (e.g. so\n *   that a user's collateral in a particular token can be kept track of as an exact quantity of deposited\n *   tokens rather than a percent ownership of a pool of deposited tokens).\n *\n *   Non-rebasing tokens (i.e. this contract) are minted and burned according to the internal exchange rate of\n *   the non-rebasing token to the rebasing token (i.e. the underlying token). In pseudocode to illustrate:\n *\n *     exchangeRate = underlyingToken.balanceOf(address(this)) / totalSupply()\n *     underlyingOwnedByNonRebasingTokenHolder = exchangeRate * balanceOf(nonRebasingTokenHolder)\n */\ncontract NonRebasingWrapperToken is OwnableUpgradeable, ERC20Upgradeable, ReentrancyGuardUpgradeable {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The underlying token that this contract wraps.\n    IERC20Upgradeable public underlyingToken;\n\n    // Emitted when underlying tokens have been deposited, minting this token.\n    event DepositedUnderlying(address indexed account, uint256 underlyingDepositAmount, uint256 mintAmount);\n    // Emitted when underlying tokens have been withdrawn, burning this token.\n    event WithdrewUnderlying(address indexed account, uint256 underlyingWithdrawAmount, uint256 burnAmount);\n\n    /**\n     * @notice Empty constructor, see `initialize`.\n     * @dev Protects against a call to initialize when this contract is called directly without a proxy.\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n        // Intentionally left blank.\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @notice Constructs a non-rebasing wrapper token.\n     * @param _underlyingToken The address of the underlying token this contract wraps.\n     * @param _name The name of this wrapper token.\n     * @param _symbol The symbol of this wrapper token.\n     */\n    function initialize(\n        address _underlyingToken,\n        string memory _name,\n        string memory _symbol\n    ) external initializer {\n        require(isContract(_underlyingToken), \"NRWToken: underlying must be a contract\");\n        __ERC20_init(_name, _symbol);\n        __Ownable_init_unchained();\n        underlyingToken = IERC20Upgradeable(_underlyingToken);\n    }\n\n    /**\n     * @notice Deposits an amount of the underlying token, minting an amount of this token\n     *   according to the deposit amount.\n     * @dev The amount of the underlying deposited that's used in any calculations is\n     *   the difference in this contract's balance after transferring in underlyingDepositAmount.\n     * @param _underlyingDepositAmount The amount of the underlying token to transfer in as a deposit.\n     * @return The amount of this token that was minted for the deposit.\n     */\n    function depositUnderlying(uint256 _underlyingDepositAmount) external returns (uint256) {\n        // Calculate the actual difference in balance of this contract instead of using amount.\n        // This handles cases where a token transfer has a fee.\n        uint256 underlyingBalanceBefore = underlyingToken.balanceOf(address(this));\n        underlyingToken.safeTransferFrom(msg.sender, address(this), _underlyingDepositAmount);\n\n        uint256 underlyingBalanceAfter = underlyingToken.balanceOf(address(this));\n        uint256 depositAmount = underlyingBalanceAfter - underlyingBalanceBefore;\n\n        require(depositAmount > 0, \"NRWToken: deposit amount is zero\");\n\n        uint256 _totalSupply = totalSupply();\n        // If this contract has a total supply of 0 or no prior underlying balance, mint at a 1:1 rate.\n        // In an extreme case, it's possible for this contract to have a total supply > 0 but\n        // underlyingBalanceBefore == 0, e.g. if the rebasing of the underlying token caused a loss\n        // of precision. In this case, there's no super fair option other than just minting at a 1:1 rate.\n        //\n        // In a case where this contract has a total supply > 0 and a prior underlying balance > 0,\n        // the mintAmount is calculated based off the formula used for getting the underlying\n        // amount owed to a holder of this contract's token used by `balanceOfUnderlying`:\n        //   userBalanceOfUnderlying = (userBalanceOf / totalSupply) * contractUnderlyingBalance\n        // Extended to a case for newly minted tokens from a deposit:\n        //   underlyingDeposited = (tokensMinted / (totalSupplyBefore + tokensMinted)) * contractUnderlyingBalanceAfter\n        //\n        //   tokensMinted = (underlyingDeposited * totalSupplyBefore) /\n        //     (contractUnderlyingBalanceAfter - underlyingDeposited)\n        //\n        //   tokensMinted = (underlyingDeposited * totalSupplyBefore) / contractUnderlyingBalanceBefore\n        uint256 mintAmount = _totalSupply == 0 || underlyingBalanceBefore == 0\n            ? depositAmount\n            : (depositAmount * _totalSupply) / underlyingBalanceBefore;\n        _mint(msg.sender, mintAmount);\n\n        emit DepositedUnderlying(msg.sender, depositAmount, mintAmount);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Withdraws an underlying token amount corresponding to the provided\n     *   amount of this token, burning the tokens.\n     * @param _nonRebasingWithdrawalAmount Denominated in this token, the amount\n     *   to burn. Used to calculate the amount of underlying tokens that are withdrawn as a result.\n     * @return The amount of the rebasing underlying token withdrawn.\n     */\n    function withdrawUnderlying(uint256 _nonRebasingWithdrawalAmount) external nonReentrant returns (uint256) {\n        require(_nonRebasingWithdrawalAmount > 0, \"NRWToken: withdraw amount is zero\");\n        require(_nonRebasingWithdrawalAmount <= balanceOf(msg.sender), \"NRWToken: withdraw amount exceeds balance\");\n        // Withdraw the underlying tokens. underlyingAmount will never be\n        // greater than this contract's balance of the underlying token due\n        // to the way getUnderlyingAmount works.\n        uint256 underlyingAmount = getUnderlyingAmount(_nonRebasingWithdrawalAmount);\n        underlyingToken.safeTransfer(msg.sender, underlyingAmount);\n\n        // Burn the balance of non-rebasing tokens.\n        // It's important to do this after the above call to getUnderlyingAmount,\n        // because getUnderlyingAmount relies upon the total supply and _burn will\n        // decrement the total supply.\n        // Note that it would ordinarily be safer to burn prior to transferring funds out,\n        // but because the only external call is to the underlyingToken that is assumed\n        // to be safe, this is okay.\n        _burn(msg.sender, _nonRebasingWithdrawalAmount);\n\n        emit WithdrewUnderlying(msg.sender, underlyingAmount, _nonRebasingWithdrawalAmount);\n\n        return underlyingAmount;\n    }\n\n    /**\n     * @notice Gets the amount of the underlying tokens an account owns based off their\n     *   balance of this token.\n     * @param _account The account to view the underlying balance of.\n     * @return The amount of underlying tokens the account owns in this contract.\n     */\n    function balanceOfUnderlying(address _account) external view returns (uint256) {\n        return getUnderlyingAmount(balanceOf(_account));\n    }\n\n    /**\n     * @notice Gets the amount of underlying tokens corresponding to a provided amount of this contract's tokens.\n     * @dev Loss of precision could result in a marginally lower amount returned, but should never\n     *   result in a higher value than intended. Dust from any lower amounts that are withdrawn\n     *   effectively accumulate to the rest of token holders.\n     * @param _nonRebasingAmount The non-rebasing amount of tokens, i.e. denominated in this contract's tokens.\n     * @return The amount of underlying tokens corresponding to nonRebasingAmount of this contract's tokens.\n     */\n    function getUnderlyingAmount(uint256 _nonRebasingAmount) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0 || _nonRebasingAmount == 0) {\n            return 0;\n        }\n        require(_nonRebasingAmount <= _totalSupply, \"NRWToken: amount exceeds total supply\");\n        uint256 underlyingBalance = underlyingToken.balanceOf(address(this));\n        // Note there is some risk of overflow if _nonRebasingAmount and underlyingBalance\n        // are extremely high - this is only likely to happen if the underlying token\n        // has a very high decimal count.\n        return\n            FixedPoint\n                .Unsigned(_nonRebasingAmount)\n                .mul(FixedPoint.Unsigned(underlyingBalance))\n                .div(FixedPoint.Unsigned(_totalSupply))\n                .rawValue;\n    }\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n    uint256[49] private __gap;\n}\n"
        },
        "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
        },
        "src/contracts/KreskoAsset.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @dev Extension of {ERC20} that restricts token minting and burning\n * to the contract's owner. Tokens can be minted to any address, but\n * can only be burned from the owner's address.\n */\ncontract KreskoAsset is ERC20Upgradeable, AccessControlEnumerableUpgradeable {\n    /**\n     * @notice Empty constructor, see `initialize`.\n     * @dev Protects against a call to initialize when this contract is called directly without a proxy.\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n        // Intentionally left blank.\n    }\n\n    // keccak256(\"kresko.operator.role\")\n    bytes32 public constant OPERATOR_ROLE = 0x8952ae23cc3fea91b9dba0cefa16d18a26ca2bf124b54f42b5d04bce3aacecd2;\n\n    /**\n     * @notice Initializes a KreskoAsset ERC20 token.\n     * @dev Intended to be operated by the Kresko smart contract.\n     * @param _name The name of the KreskoAsset.\n     * @param _symbol The symbol of the KreskoAsset.\n     * @param _owner The owner of this contract.\n     * @param _operator The mint/burn operator.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        address _operator\n    ) external initializer {\n        __ERC20_init(_name, _symbol);\n        __AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setupRole(OPERATOR_ROLE, _operator);\n    }\n\n    /**\n     * @notice Mints tokens to an address.\n     * @dev Only callable by operator.\n     * @param _account The recipient address of the mint.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(address _account, uint256 _amount) external onlyRole(OPERATOR_ROLE) {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burns tokens from an address.\n     * @dev Only callable by operator.\n     * @param _account The address to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(address _account, uint256 _amount) external onlyRole(OPERATOR_ROLE) {\n        _burn(_account, _amount);\n    }\n}\n"
        },
        "src/contracts/KreskoViewer.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"./interfaces/IKresko.sol\";\n\ncontract KreskoViewer {\n    using FixedPoint for FixedPoint.Unsigned;\n\n    IKresko public Kresko;\n\n    struct krAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        uint256 amount;\n        uint256 amountUSD;\n        uint256 index;\n        FixedPoint.Unsigned kFactor;\n        bool mintable;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfoUser {\n        address assetAddress;\n        address oracleAddress;\n        address underlyingRebasingToken;\n        uint256 amount;\n        uint256 amountUSD;\n        FixedPoint.Unsigned cFactor;\n        uint8 decimals;\n        uint256 index;\n        uint256 price;\n        string symbol;\n        string name;\n    }\n\n    struct CollateralAssetInfo {\n        address assetAddress;\n        address oracleAddress;\n        address underlyingRebasingToken;\n        uint256 price;\n        uint256 value;\n        FixedPoint.Unsigned cFactor;\n        uint8 decimals;\n        string symbol;\n        string name;\n    }\n\n    struct krAssetInfo {\n        address oracleAddress;\n        address assetAddress;\n        uint256 price;\n        uint256 value;\n        FixedPoint.Unsigned kFactor;\n        string symbol;\n        string name;\n    }\n\n    struct KreskoUser {\n        krAssetInfoUser[] krAssets;\n        CollateralAssetInfoUser[] collateralAssets;\n        uint256 healthFactor;\n        uint256 debtActualUSD;\n        uint256 debtUSD;\n        uint256 collateralActualUSD;\n        uint256 collateralUSD;\n        uint256 minCollateralUSD;\n        uint256 borrowingPowerUSD;\n    }\n\n    constructor(IKresko _kresko) {\n        Kresko = _kresko;\n    }\n\n    function healthFactorFor(address _account) public view returns (uint256) {\n        uint256 minCollateral = Kresko.getAccountMinimumCollateralValue(_account).rawValue;\n        uint256 userCollateral = Kresko.getAccountCollateralValue(_account).rawValue;\n\n        return (userCollateral * 10**18) / minCollateral;\n    }\n\n    function kreskoUser(address _account) external view returns (KreskoUser memory user) {\n        (krAssetInfoUser[] memory krInfos, uint256 totalDebtUSD) = krAssetInfoFor(_account);\n        (CollateralAssetInfoUser[] memory collateralInfos, uint256 totalCollateralUSD) = collateralAssetInfoFor(\n            _account\n        );\n\n        user = KreskoUser({\n            collateralAssets: collateralInfos,\n            krAssets: krInfos,\n            borrowingPowerUSD: borrowingPowerUSD(_account),\n            healthFactor: healthFactorFor(_account),\n            debtActualUSD: totalDebtUSD,\n            debtUSD: Kresko.getAccountKrAssetValue(_account).rawValue,\n            collateralActualUSD: totalCollateralUSD,\n            collateralUSD: Kresko.getAccountCollateralValue(_account).rawValue,\n            minCollateralUSD: Kresko.getAccountMinimumCollateralValue(_account).rawValue\n        });\n    }\n\n    function krAssetInfoFor(address _account)\n        public\n        view\n        returns (krAssetInfoUser[] memory result, uint256 totalDebtUSD)\n    {\n        address[] memory krAssetAddresses = Kresko.getMintedKreskoAssets(_account);\n        result = new krAssetInfoUser[](krAssetAddresses.length);\n        for (uint256 i; i < krAssetAddresses.length; i++) {\n            address assetAddress = krAssetAddresses[i];\n            IKresko.KrAsset memory krAsset = Kresko.kreskoAssets(assetAddress);\n            uint256 amount = Kresko.kreskoAssetDebt(_account, assetAddress);\n\n            uint256 price = uint256(krAsset.oracle.latestAnswer());\n            uint256 amountUSD = Kresko.getKrAssetValue(assetAddress, amount, true).rawValue;\n\n            string memory symbol = IERC20MetadataUpgradeable(assetAddress).symbol();\n            string memory name = IERC20MetadataUpgradeable(assetAddress).name();\n\n            krAssetInfoUser memory assetInfo = krAssetInfoUser({\n                assetAddress: assetAddress,\n                oracleAddress: address(krAsset.oracle),\n                amount: amount,\n                amountUSD: amountUSD,\n                index: i,\n                kFactor: krAsset.kFactor,\n                mintable: krAsset.mintable,\n                price: price,\n                symbol: symbol,\n                name: name\n            });\n\n            totalDebtUSD += amountUSD;\n            result[i] = assetInfo;\n        }\n    }\n\n    function collateralAssetInfoFor(address _account)\n        public\n        view\n        returns (CollateralAssetInfoUser[] memory result, uint256 totalCollateralUSD)\n    {\n        address[] memory collateralAssetAddresses = Kresko.getDepositedCollateralAssets(_account);\n        result = new CollateralAssetInfoUser[](collateralAssetAddresses.length);\n        for (uint256 i; i < collateralAssetAddresses.length; i++) {\n            address assetAddress = collateralAssetAddresses[i];\n            IKresko.CollateralAsset memory collateralAsset = Kresko.collateralAssets(assetAddress);\n            uint8 decimals = IERC20MetadataUpgradeable(assetAddress).decimals();\n\n            uint256 amount = Kresko.collateralDeposits(_account, assetAddress);\n\n            string memory symbol = IERC20MetadataUpgradeable(assetAddress).symbol();\n            (FixedPoint.Unsigned memory amountUSD, FixedPoint.Unsigned memory price) = Kresko\n                .getCollateralValueAndOraclePrice(assetAddress, amount, true);\n\n            string memory name = IERC20MetadataUpgradeable(assetAddress).name();\n\n            CollateralAssetInfoUser memory assetInfo = CollateralAssetInfoUser({\n                amount: amount,\n                amountUSD: amountUSD.rawValue,\n                oracleAddress: address(collateralAsset.oracle),\n                underlyingRebasingToken: collateralAsset.underlyingRebasingToken,\n                assetAddress: assetAddress,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                index: i,\n                price: price.rawValue,\n                symbol: symbol,\n                name: name\n            });\n\n            totalCollateralUSD += amountUSD.rawValue;\n            result[i] = assetInfo;\n        }\n    }\n\n    function collateralAssetInfos(address[] memory assetAddresses)\n        public\n        view\n        returns (CollateralAssetInfo[] memory result)\n    {\n        result = new CollateralAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n            IKresko.CollateralAsset memory collateralAsset = Kresko.collateralAssets(assetAddress);\n            uint8 decimals = IERC20MetadataUpgradeable(assetAddress).decimals();\n\n            string memory symbol = IERC20MetadataUpgradeable(assetAddress).symbol();\n            (FixedPoint.Unsigned memory value, FixedPoint.Unsigned memory price) = Kresko\n                .getCollateralValueAndOraclePrice(assetAddress, 1 * 10**decimals, false);\n\n            string memory name = IERC20MetadataUpgradeable(assetAddress).name();\n\n            CollateralAssetInfo memory assetInfo = CollateralAssetInfo({\n                value: value.rawValue,\n                oracleAddress: address(collateralAsset.oracle),\n                underlyingRebasingToken: collateralAsset.underlyingRebasingToken,\n                assetAddress: assetAddress,\n                cFactor: collateralAsset.factor,\n                decimals: decimals,\n                price: price.rawValue,\n                symbol: symbol,\n                name: name\n            });\n\n            result[i] = assetInfo;\n        }\n    }\n\n    function getAssetInfos(address[] memory _collateralAssets, address[] memory _krAssets)\n        external\n        view\n        returns (CollateralAssetInfo[] memory collateralAssets, krAssetInfo[] memory krAssets)\n    {\n        collateralAssets = collateralAssetInfos(_collateralAssets);\n        krAssets = krAssetInfos(_krAssets);\n    }\n\n    function krAssetInfos(address[] memory assetAddresses) public view returns (krAssetInfo[] memory result) {\n        result = new krAssetInfo[](assetAddresses.length);\n        for (uint256 i; i < assetAddresses.length; i++) {\n            address assetAddress = assetAddresses[i];\n\n            IKresko.KrAsset memory krAsset = Kresko.kreskoAssets(assetAddress);\n\n            FixedPoint.Unsigned memory value = Kresko.getKrAssetValue(assetAddress, 1 ether, false);\n            uint256 price = uint256(krAsset.oracle.latestAnswer());\n\n            string memory name = IERC20MetadataUpgradeable(assetAddress).name();\n            string memory symbol = IERC20MetadataUpgradeable(assetAddress).symbol();\n\n            krAssetInfo memory assetInfo = krAssetInfo({\n                value: value.rawValue,\n                oracleAddress: address(krAsset.oracle),\n                assetAddress: assetAddress,\n                kFactor: krAsset.kFactor,\n                price: price,\n                symbol: symbol,\n                name: name\n            });\n\n            result[i] = assetInfo;\n        }\n    }\n\n    function borrowingPowerUSD(address _account) public view returns (uint256) {\n        FixedPoint.Unsigned memory minCollateral = Kresko.getAccountMinimumCollateralValue(_account);\n        FixedPoint.Unsigned memory collateral = Kresko.getAccountCollateralValue(_account);\n\n        if (collateral.isLessThan(minCollateral)) {\n            return 0;\n        } else {\n            return collateral.sub(minCollateral).rawValue;\n        }\n    }\n}\n"
        },
        "src/contracts/interfaces/IKresko.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../libraries/FixedPoint.sol\";\nimport \"../flux/interfaces/AggregatorV2V3Interface.sol\";\n\ninterface IKresko {\n    struct CollateralAsset {\n        FixedPoint.Unsigned factor;\n        AggregatorV2V3Interface oracle;\n        address underlyingRebasingToken;\n        uint8 decimals;\n        bool exists;\n    }\n\n    struct KrAsset {\n        FixedPoint.Unsigned kFactor;\n        AggregatorV2V3Interface oracle;\n        bool exists;\n        bool mintable;\n    }\n\n    function depositCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount\n    ) external;\n\n    function depositRebasingCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _rebasingAmount\n    ) external;\n\n    function withdrawCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    function withdrawRebasingCollateral(\n        address _account,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _depositedCollateralAssetIndex\n    ) external;\n\n    function mintKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount\n    ) external;\n\n    function burnKreskoAsset(\n        address _account,\n        address _kreskoAsset,\n        uint256 _amount,\n        uint256 _mintedKreskoAssetIndex\n    ) external;\n\n    function collateralExists(address) external view returns (bool);\n\n    function krAssetExists(address) external view returns (bool);\n\n    function kreskoAssets(address) external view returns (KrAsset memory);\n\n    function collateralAssets(address) external view returns (CollateralAsset memory);\n\n    function getDepositedCollateralAssetIndex(address, address) external view returns (uint256 i);\n\n    function getMintedKreskoAssetsIndex(address, address) external view returns (uint256 i);\n\n    function getMintedKreskoAssets(address user) external view returns (address[] memory);\n\n    function getDepositedCollateralAssets(address user) external view returns (address[] memory);\n\n    function getCollateralValueAndOraclePrice(\n        address _collateralAsset,\n        uint256 _amount,\n        bool _ignoreCollateralFactor\n    ) external view returns (FixedPoint.Unsigned memory, FixedPoint.Unsigned memory);\n\n    function calculateMaxLiquidatableValueForAssets(\n        address _account,\n        address _repayKreskoAsset,\n        address _collateralAssetToSeize\n    ) external view returns (FixedPoint.Unsigned memory);\n\n    function minimumCollateralizationRatio() external view returns (FixedPoint.Unsigned memory);\n\n    function kreskoAssetDebt(address, address) external view returns (uint256);\n\n    function collateralDeposits(address, address) external view returns (uint256);\n\n    function getMinimumCollateralValue(address _krAsset, uint256 _amount)\n        external\n        view\n        returns (FixedPoint.Unsigned memory);\n\n    function getAccountCollateralValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function getAccountMinimumCollateralValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function getAccountKrAssetValue(address _account) external view returns (FixedPoint.Unsigned memory);\n\n    function getKrAssetValue(\n        address _kreskoAsset,\n        uint256 _amount,\n        bool _ignoreKfactor\n    ) external view returns (FixedPoint.Unsigned memory);\n}\n"
        },
        "src/contracts/test/MockWETH10.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\n\ncontract MockWETH10 {\n    uint8 public constant decimals = 18;\n    string public constant name = \"Wrapped Ether\";\n    string public constant symbol = \"WETH\";\n    bytes32 public immutable CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// @dev Current amount of flash-minted WETH10 token.\n    uint256 public flashMinted;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /// @dev Returns the total supply of WETH10 token as the ETH held in this contract.\n    function totalSupply() external view returns (uint256) {\n        return address(this).balance + flashMinted;\n    }\n\n    /// @dev Flash lends `value` WETH10 token to the receiver address.\n    /// By the end of the transaction, `value` WETH10 token will be burned from the receiver.\n    /// The flash-minted WETH10 token is not backed by real ETH\n    /// but can be withdrawn as such up to the ETH balance of this contract.\n    /// Arbitrary data can be passed as a bytes calldata parameter.\n    /// Emits {Approval} event to reflect reduced allowance `value`\n    /// for this contract to spend from receiver account (`receiver`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Requirements:\n    ///   - `value` must be less or equal to type(uint112).max.\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool) {\n        require(token == address(this), \"WETH: flash mint only WETH10\");\n        require(value <= type(uint112).max, \"WETH: individual loan limit exceeded\");\n\n        balanceOf[address(receiver)] += value;\n        require(\n            receiver.onFlashLoan(msg.sender, address(this), value, 0, data) == CALLBACK_SUCCESS,\n            \"WETH: flash loan failed\"\n        );\n\n        uint256 balance = balanceOf[address(receiver)];\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\n        balanceOf[address(receiver)] = balance - value;\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n        balanceOf[msg.sender] = balance - value;\n        balanceOf[to] += value;\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n        balanceOf[from] = balance - value;\n        balanceOf[to] += value;\n        return true;\n    }\n\n    // allow arbitrary values\n    function deposit(uint256 _amount) external {\n        balanceOf[msg.sender] += _amount;\n    }\n\n    function withdraw(uint256 _amount) external {\n        balanceOf[msg.sender] -= _amount;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n    }\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "bytecodeHash": "none",
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 800
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.gasEstimates"
                ],
                "": ["ast"]
            }
        }
    }
}
