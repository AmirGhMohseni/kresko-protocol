{
  "stats": {
    "suites": 80,
    "tests": 244,
    "passes": 241,
    "pending": 3,
    "failures": 0,
    "start": "2022-11-30T20:36:41.832Z",
    "end": "2022-11-30T20:40:00.756Z",
    "duration": 198924,
    "testsRegistered": 244,
    "passPercent": 100,
    "pendingPercent": 1.2295081967213115,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "1e2a00d5-f0a1-41a2-8952-41d9f23a7328",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "06a028f5-f4f3-4dfa-91db-631e16d15cee",
          "title": "Diamond",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/00-init.ts",
          "file": "/src/test/diamond/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 1362,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "6d45facb-1d51-46df-9f49-99100f0de230",
              "parentUUID": "06a028f5-f4f3-4dfa-91db-631e16d15cee",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "33aa77ed-0124-4b33-91f5-dc55db1c819c",
              "parentUUID": "06a028f5-f4f3-4dfa-91db-631e16d15cee",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 24,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "85b907ef-2767-4db3-8125-1a5083257490",
              "parentUUID": "06a028f5-f4f3-4dfa-91db-631e16d15cee",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "a62c908b-d91b-485c-b6df-ac67e2085552",
              "title": "#initialization",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/00-init.ts",
              "file": "/src/test/diamond/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct state",
                  "fullTitle": "Diamond #initialization sets correct state",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.owner()).to.equal(users.deployer.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.initialized()).to.equal(true);",
                  "err": {},
                  "uuid": "a9c2bf63-b105-4731-b72a-17441f649c2f",
                  "parentUUID": "a62c908b-d91b-485c-b6df-ac67e2085552",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets standard facet addresses",
                  "fullTitle": "Diamond #initialization sets standard facet addresses",
                  "timedOut": false,
                  "duration": 18,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetAddressesOnChain = (await hardhat_1.default.Diamond.facets()).map(f => f.facetAddress);\nconst facetAddressesArtifact = this.facets.map(f => f.facetAddress);\n(0, chai_1.expect)(facetAddressesOnChain.length).to.equal(facetAddressesArtifact.length);\n(0, chai_1.expect)(facetAddressesOnChain).to.have.members(facetAddressesArtifact);",
                  "err": {},
                  "uuid": "7c9f3b7d-5e0a-47cb-b81e-f0d0ad01b1fd",
                  "parentUUID": "a62c908b-d91b-485c-b6df-ac67e2085552",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets selectors of standard facets",
                  "fullTitle": "Diamond #initialization sets selectors of standard facets",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetsSelectorsOnChain = (await hardhat_1.default.Diamond.facets()).flatMap(f => f.functionSelectors);\nconst facetSelectorsOnArtifact = this.facets.flatMap(f => f.functionSelectors);\n(0, chai_1.expect)(facetsSelectorsOnChain.length).to.equal(facetSelectorsOnArtifact.length);\n(0, chai_1.expect)(facetsSelectorsOnChain).to.have.members(facetSelectorsOnArtifact);",
                  "err": {},
                  "uuid": "8878cc67-3bdd-4783-bc47-0160ae4c6fa2",
                  "parentUUID": "a62c908b-d91b-485c-b6df-ac67e2085552",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "a9c2bf63-b105-4731-b72a-17441f649c2f",
                "7c9f3b7d-5e0a-47cb-b81e-f0d0ad01b1fd",
                "8878cc67-3bdd-4783-bc47-0160ae4c6fa2"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 42,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "7680e6a4-f8f1-4ee0-9f7c-6df96331d141",
          "title": "Diamond",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/01-ownership.ts",
          "file": "/src/test/diamond/01-ownership.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 4,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nusers = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "92476ed0-c94f-4713-8557-fb446df9a829",
              "parentUUID": "7680e6a4-f8f1-4ee0-9f7c-6df96331d141",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "1b138c6a-3ab1-435a-a3d3-5f90796da6eb",
              "parentUUID": "7680e6a4-f8f1-4ee0-9f7c-6df96331d141",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "d8db3022-bace-476b-9354-88a34e129c1d",
              "parentUUID": "7680e6a4-f8f1-4ee0-9f7c-6df96331d141",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "9b2247d3-ab60-491c-ab03-e972759ebfbd",
              "title": "#ownership",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/01-ownership.ts",
              "file": "/src/test/diamond/01-ownership.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct owner",
                  "fullTitle": "Diamond #ownership sets correct owner",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.owner()).to.equal(addr.deployer);",
                  "err": {},
                  "uuid": "4dfaaec4-65ce-40f6-82b0-3f18bc11fadb",
                  "parentUUID": "9b2247d3-ab60-491c-ab03-e972759ebfbd",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets correct default admin role",
                  "fullTitle": "Diamond #ownership sets correct default admin role",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(test_1.Role.ADMIN, addr.deployer)).to.equal(true);",
                  "err": {},
                  "uuid": "58f2a81a-f5c9-4869-8027-4bd2c9218318",
                  "parentUUID": "9b2247d3-ab60-491c-ab03-e972759ebfbd",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets a new pending owner",
                  "fullTitle": "Diamond #ownership sets a new pending owner",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const pendingOwner = users.userOne;\nawait hardhat_1.default.Diamond.transferOwnership(pendingOwner.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.pendingOwner()).to.equal(pendingOwner.address);",
                  "err": {},
                  "uuid": "1d731130-122e-4829-807d-a25f0e7027d0",
                  "parentUUID": "9b2247d3-ab60-491c-ab03-e972759ebfbd",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets the pending owner as new owner",
                  "fullTitle": "Diamond #ownership sets the pending owner as new owner",
                  "timedOut": false,
                  "duration": 18,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const pendingOwner = users.userOne;\nawait hardhat_1.default.Diamond.transferOwnership(pendingOwner.address);\nawait hardhat_1.default.Diamond.connect(pendingOwner).acceptOwnership();\n(0, chai_1.expect)(await hardhat_1.default.Diamond.owner()).to.equal(pendingOwner.address);",
                  "err": {},
                  "uuid": "c94f021b-71c4-49d8-9cec-4eef7ec79be1",
                  "parentUUID": "9b2247d3-ab60-491c-ab03-e972759ebfbd",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4dfaaec4-65ce-40f6-82b0-3f18bc11fadb",
                "58f2a81a-f5c9-4869-8027-4bd2c9218318",
                "1d731130-122e-4829-807d-a25f0e7027d0",
                "c94f021b-71c4-49d8-9cec-4eef7ec79be1"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 34,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "4a4983b9-e546-4f4b-adb3-7038bb2e1966",
          "title": "Diamond",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/02-upgrades.ts",
          "file": "/src/test/diamond/02-upgrades.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 5,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nusers = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "82dfceb4-15e1-4675-866b-6623e04920cc",
              "parentUUID": "4a4983b9-e546-4f4b-adb3-7038bb2e1966",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before all\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "5704be5b-a1ab-417b-b1fa-dde746a21547",
              "parentUUID": "4a4983b9-e546-4f4b-adb3-7038bb2e1966",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Diamond\"",
              "fullTitle": "Diamond \"before each\" hook in \"Diamond\"",
              "timedOut": false,
              "duration": 23,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "94e6a00f-77d0-48a7-9ea0-2eb973546cd4",
              "parentUUID": "4a4983b9-e546-4f4b-adb3-7038bb2e1966",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
              "title": "#upgrades",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/diamond/02-upgrades.ts",
              "file": "/src/test/diamond/02-upgrades.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can add a new facet",
                  "fullTitle": "Diamond #upgrades can add a new facet",
                  "timedOut": false,
                  "duration": 872,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const Factory = await smock_1.smock.mock(\"SmockFacet\");\nconst SmockFacet = await Factory.deploy();\nconst [SmockInitializer] = await hardhat_1.default.deploy(\"SmockInit\");\nconst signatures = hardhat_1.default.getSignatures(types_2.SmockFacet__factory.abi);\nconst Cut = {\n    facetAddress: SmockFacet.address,\n    functionSelectors: signatures,\n    action: types_1.FacetCutAction.Add,\n};\nconst initData = await SmockInitializer.populateTransaction.initialize(addr.userOne);\nawait hardhat_1.default.Diamond.diamondCut([Cut], initData.to, initData.data);\nconst TEST_OPERATOR_ROLE = hardhat_1.default.ethers.utils.id(\"kresko.test.operator\");\nconst isTestOperator = await hardhat_1.default.Diamond.hasRole(TEST_OPERATOR_ROLE, addr.userOne);\n// Succesfully added the new operator through the initialization contract\n(0, chai_1.expect)(isTestOperator).to.equal(true);\nconst Facet = await hardhat_1.default.ethers.getContractAt(types_2.SmockFacet__factory.abi, hardhat_1.default.Diamond.address);\n// Ensure facet has it's own storage\nconst operatorFromNewStorage = await Facet.operator(); // Retrieved from SmockStorage\n(0, chai_1.expect)(operatorFromNewStorage).to.equal(addr.userOne);",
                  "err": {},
                  "uuid": "bd7a9cd5-98e5-404f-bf16-bc65ba313438",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can remove a facet",
                  "fullTitle": "Diamond #upgrades can remove a facet",
                  "timedOut": false,
                  "duration": 291,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const NewFacet = await (0, add_facet_1.addFacet)({\n    name: \"SmockFacet\",\n    initializerName: \"SmockInit\",\n    initializerArgs: addr.userOne,\n});\nconst facetsBefore = await hardhat_1.default.Diamond.facets();\n(0, chai_1.expect)(facetsBefore.filter(f => f.facetAddress === NewFacet.address).length).to.equal(1);\nawait (0, remove_facet_1.removeFacet)({ name: \"SmockFacet\" });\nconst facetsAfter = await hardhat_1.default.Diamond.facets();\n(0, chai_1.expect)(facetsBefore.length - facetsAfter.length).to.equal(1);\n(0, chai_1.expect)(facetsAfter).to.not.deep.contain(NewFacet.address);",
                  "err": {},
                  "uuid": "a07bf650-c00c-4293-b68a-414318059e6b",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can remove a function",
                  "fullTitle": "Diamond #upgrades can remove a function",
                  "timedOut": false,
                  "duration": 50,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Delete acceptOwnership from DiamondOwnershipFacet\n// Check there is no pending owner\nlet pendingOwner = await hardhat_1.default.Diamond.pendingOwner();\n(0, chai_1.expect)(pendingOwner).to.equal(addr.ZERO);\n// Transfer to eg. wrong address\nconst wrongOwner = addr.nonadmin;\nawait hardhat_1.default.Diamond.transferOwnership(wrongOwner);\n// Ensure\npendingOwner = await hardhat_1.default.Diamond.pendingOwner();\n(0, chai_1.expect)(pendingOwner).to.equal(wrongOwner);\n// Fragment and signature for acceptOwnersip\nconst functionFragment = hardhat_1.default.Diamond.interface.functions[\"acceptOwnership()\"];\nconst signature = hardhat_1.default.ethers.utils.Interface.getSighash(functionFragment);\nconst facetAddress = await hardhat_1.default.Diamond.facetAddress(signature);\nconst functions = await hardhat_1.default.Diamond.facetFunctionSelectors(facetAddress);\nconst Cut = {\n    facetAddress: addr.ZERO,\n    action: types_1.FacetCutAction.Remove,\n    functionSelectors: [signature],\n};\n// We will set a correct owner with delegatecall into the Diamond itself with the cut transaction\nconst correctOwner = addr.userOne;\nconst initData = await hardhat_1.default.Diamond.populateTransaction.transferOwnership(correctOwner);\nconst tx = await hardhat_1.default.Diamond.diamondCut([Cut], initData.to, initData.data);\nawait tx.wait();\n// Ensure rest of the functions remain\nconst functionsAfterCut = await hardhat_1.default.Diamond.facetFunctionSelectors(facetAddress);\n(0, chai_1.expect)(functionsAfterCut.length).to.equal(functions.length - 1);\n// Ensure delegatecall did set the correct pending owner with the cut\nconst filter = hardhat_1.default.Diamond.filters[\"PendingOwnershipTransfer(address,address)\"](addr.deployer, correctOwner);\nconst [event] = await hardhat_1.default.Diamond.queryFilter(filter);\nconst { previousOwner, newOwner } = event.args;\n(0, chai_1.expect)(previousOwner).to.equal(addr.deployer);\n(0, chai_1.expect)(newOwner).to.equal(correctOwner);\n// Ensure there is no function to accept the ownership\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.nonadmin).acceptOwnership()).to.be.revertedWith(test_1.Error.DIAMOND_INVALID_FUNCTION_SIGNATURE);",
                  "err": {},
                  "uuid": "e6df0ae4-712d-4a68-aee4-a0df82da4676",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can replace a function",
                  "fullTitle": "Diamond #upgrades can replace a function",
                  "timedOut": false,
                  "duration": 86,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Same as above but instead replace the function\n// Check there is no pending owner\nlet pendingOwner = await hardhat_1.default.Diamond.pendingOwner();\n(0, chai_1.expect)(pendingOwner).to.equal(addr.ZERO);\n// Transfer to eg. wrong address\nconst wrongOwner = addr.nonadmin;\nawait hardhat_1.default.Diamond.transferOwnership(wrongOwner);\n// Ensure\npendingOwner = await hardhat_1.default.Diamond.pendingOwner();\n(0, chai_1.expect)(pendingOwner).to.equal(wrongOwner);\n// Fragment and signature for acceptOwnersip\nconst functionFragment = hardhat_1.default.Diamond.interface.functions[\"acceptOwnership()\"];\nconst signature = hardhat_1.default.ethers.utils.Interface.getSighash(functionFragment);\nconst OldOwnershipFacet = await hardhat_1.default.Diamond.facetAddress(signature);\nconst [NewOwnershipFacet, allOwnershipFacetSignatures] = await hardhat_1.default.deploy(\"DiamondOwnershipFacet2\", {\n    contract: \"DiamondOwnershipFacet\",\n    from: addr.deployer,\n});\n// Only replace a single function, we could replace all of them\nconst Cut = {\n    facetAddress: NewOwnershipFacet.address,\n    action: types_1.FacetCutAction.Replace,\n    functionSelectors: [signature],\n};\n// We will set a correct owner with delegatecall into the Diamond itself with the cut transaction\nconst correctOwner = addr.userOne;\nconst initData = await hardhat_1.default.Diamond.populateTransaction.transferOwnership(correctOwner);\nconst tx = await hardhat_1.default.Diamond.diamondCut([Cut], initData.to, initData.data);\nawait tx.wait();\n// Ensure function exists and revert is for invalid address instead of missing function\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.nonadmin).acceptOwnership()).to.be.revertedWith(test_1.Error.DIAMOND_INVALID_PENDING_OWNER);\n// Ensure one function is contained in the new facet\nconst functionsNewFacet = await hardhat_1.default.Diamond.facetFunctionSelectors(NewOwnershipFacet.address);\n(0, chai_1.expect)(functionsNewFacet.length).to.equal(1);\n(0, chai_1.expect)(functionsNewFacet).to.have.members([signature]);\n// Ensure rest are in the previous one\nconst functionsOldFacet = await hardhat_1.default.Diamond.facetFunctionSelectors(OldOwnershipFacet);\n(0, chai_1.expect)(functionsOldFacet).to.not.have.members([signature]);\n(0, chai_1.expect)(functionsOldFacet.length).to.equal(allOwnershipFacetSignatures.length - 1);\n// Ensure correct owner can now accept the ownership\n(0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).acceptOwnership());\nconst currentOwner = await hardhat_1.default.Diamond.owner();\n(0, chai_1.expect)(currentOwner).to.equal(correctOwner);",
                  "err": {},
                  "uuid": "150df52d-598f-42ab-99ef-eb68307b0e1d",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can upgrade state",
                  "fullTitle": "Diamond #upgrades can upgrade state",
                  "timedOut": false,
                  "duration": 708,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.initialized()).to.equal(true);\nconst Factory = await smock_1.smock.mock(\"SmockInit\");\nconst SmockInit = await Factory.deploy();\nconst tx = await SmockInit.populateTransaction.upgradeState();\nawait hardhat_1.default.Diamond.upgradeState(tx.to, tx.data);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.initialized()).to.equal(false);",
                  "err": {},
                  "uuid": "6f93c4da-8701-4ae2-8e70-7d60137632d6",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can preserve old state when extending storage layout",
                  "fullTitle": "Diamond #upgrades can preserve old state when extending storage layout",
                  "timedOut": false,
                  "duration": 1151,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.initialized()).to.equal(true);\n// Add the first facet\nconst Factory = await smock_1.smock.mock(\"SmockFacet\");\nconst SmockFacet = await Factory.deploy();\nconst [SmockInitializer] = await hardhat_1.default.deploy(\"SmockInit\");\nconst signatures = hardhat_1.default.getSignatures(types_2.SmockFacet__factory.abi);\nconst Cut = {\n    facetAddress: SmockFacet.address,\n    functionSelectors: signatures,\n    action: types_1.FacetCutAction.Add,\n};\nconst initData = await SmockInitializer.populateTransaction.initialize(addr.userOne);\nawait hardhat_1.default.Diamond.diamondCut([Cut], initData.to, initData.data);\nconst Diamond = await hardhat_1.default.ethers.getContractAt(\"SmockFacet\", hardhat_1.default.Diamond.address);\nconst isInitialized = await Diamond.smockInitialized();\n(0, chai_1.expect)(isInitialized).to.equal(true);\n// Add facet with extended state\n// Add the first facet\nconst Factory2 = await smock_1.smock.mock(\"SmockFacet2\");\nconst SmockFacet2 = await Factory2.deploy();\nconst signatures2 = hardhat_1.default.getSignatures(types_2.SmockFacet2__factory.abi);\nconst Cut2 = {\n    facetAddress: SmockFacet2.address,\n    functionSelectors: signatures2,\n    action: types_1.FacetCutAction.Add,\n};\n// Initializer only sets the new extended value, does not touch old storage\nconst initData2 = await SmockFacet2.populateTransaction.initialize();\nawait hardhat_1.default.Diamond.diamondCut([Cut2], initData2.to, initData2.data);\n// Here we have appended the storage layout with the `extended` bool property.\nconst DiamondExtended = await hardhat_1.default.ethers.getContractAt(\"SmockFacet2\", hardhat_1.default.Diamond.address);\nconst initializedAfterExtend = await DiamondExtended.getOldStructValueFromExtended();\nconst extendedValue = await DiamondExtended.getNewStructValueFromExtended();\n// Old values remain\n(0, chai_1.expect)(initializedAfterExtend).to.equal(true);\n// And we get new ones\n(0, chai_1.expect)(extendedValue).to.equal(true);",
                  "err": {},
                  "uuid": "d589d8bc-a4f6-43ca-a33e-8c5d353b59b5",
                  "parentUUID": "804b7a21-635a-4f19-9cdb-c68ab72727d6",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bd7a9cd5-98e5-404f-bf16-bc65ba313438",
                "a07bf650-c00c-4293-b68a-414318059e6b",
                "e6df0ae4-712d-4a68-aee4-a0df82da4676",
                "150df52d-598f-42ab-99ef-eb68307b0e1d",
                "6f93c4da-8701-4ae2-8e70-7d60137632d6",
                "d589d8bc-a4f6-43ca-a33e-8c5d353b59b5"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 3158,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "cd7dc0cf-a946-4d13-ab32-43fd4aa15672",
          "title": "KreskoAsset",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/00-init.ts",
          "file": "/src/test/krasset/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before all\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "47592b20-6971-41cc-8bec-34da79de0aee",
              "parentUUID": "cd7dc0cf-a946-4d13-ab32-43fd4aa15672",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();",
              "err": {},
              "uuid": "d5ba9e5a-fff1-49ea-9826-c52a20b88a66",
              "parentUUID": "cd7dc0cf-a946-4d13-ab32-43fd4aa15672",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 19,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "3d4a4009-1770-4f30-b23f-81a29af5b60b",
              "parentUUID": "cd7dc0cf-a946-4d13-ab32-43fd4aa15672",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
              "title": "#initialization - anchor",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/00-init.ts",
              "file": "/src/test/krasset/00-init.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#initialization - anchor\"",
                  "fullTitle": "KreskoAsset #initialization - anchor \"before each\" hook in \"#initialization - anchor\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const deployment = this.krAssets.find(k => k.deployArgs.name === name);\nKreskoAsset = deployment.contract;\nKreskoAssetAnchor = deployment.anchor;",
                  "err": {},
                  "uuid": "26c1a0fd-49d8-47c2-8589-b26d1678aee5",
                  "parentUUID": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cant initialize twice",
                  "fullTitle": "KreskoAsset #initialization - anchor cant initialize twice",
                  "timedOut": false,
                  "duration": 12,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(KreskoAsset.initialize(name, symbol, 18, addr.deployer, hardhat_1.default.Diamond.address)).to.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);",
                  "err": {},
                  "uuid": "d3e8da2f-3137-4f6b-a980-e2087e62e2f4",
                  "parentUUID": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cant initialize implementation",
                  "fullTitle": "KreskoAsset #initialization - anchor cant initialize implementation",
                  "timedOut": false,
                  "duration": 25,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const deployment = await hardhat_1.default.deployments.get(symbol);\nconst implementationAddress = deployment.implementation;\nconst KreskoAssetImpl = await hardhat_1.default.ethers.getContractAt(\"KreskoAsset\", implementationAddress);\nawait (0, chai_1.expect)(KreskoAssetImpl.initialize(name, symbol, 18, addr.deployer, hardhat_1.default.Diamond.address)).to.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);",
                  "err": {},
                  "uuid": "50fc6fe3-86b3-4f2b-b44e-4868106c3dfd",
                  "parentUUID": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets correct state",
                  "fullTitle": "KreskoAsset #initialization - anchor sets correct state",
                  "timedOut": false,
                  "duration": 21,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await KreskoAsset.name()).to.equal(name);\n(0, chai_1.expect)(await KreskoAsset.symbol()).to.equal(symbol);\n(0, chai_1.expect)(await KreskoAsset.kresko()).to.equal(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(await KreskoAsset.hasRole(test_1.Role.ADMIN, addr.deployer)).to.equal(true);\n(0, chai_1.expect)(await KreskoAsset.hasRole(test_1.Role.OPERATOR, hardhat_1.default.Diamond.address)).to.equal(true);\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.isRebased()).to.equal(false);\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, chai_1.expect)(rebaseInfo.denominator).to.equal(0);\n(0, chai_1.expect)(rebaseInfo.positive).to.equal(false);",
                  "err": {},
                  "uuid": "29894c3e-c217-403d-abe6-c053f6cc31f0",
                  "parentUUID": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can reinitialize metadata",
                  "fullTitle": "KreskoAsset #initialization - anchor can reinitialize metadata",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const newName = \"foo\";\nconst newSymbol = \"bar\";\nawait (0, chai_1.expect)(KreskoAsset.updateMetaData(newName, newSymbol, 2)).to.not.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);\n(0, chai_1.expect)(await KreskoAsset.name()).to.equal(newName);\n(0, chai_1.expect)(await KreskoAsset.symbol()).to.equal(newSymbol);",
                  "err": {},
                  "uuid": "ca391279-e01d-483b-b4f2-8df4b1513af3",
                  "parentUUID": "6d03a302-3e34-4760-8bd4-e462fe5a2eb0",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d3e8da2f-3137-4f6b-a980-e2087e62e2f4",
                "50fc6fe3-86b3-4f2b-b44e-4868106c3dfd",
                "29894c3e-c217-403d-abe6-c053f6cc31f0",
                "ca391279-e01d-483b-b4f2-8df4b1513af3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 74,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
              "title": "#initialization - wrapped",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/00-init.ts",
              "file": "/src/test/krasset/00-init.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#initialization - wrapped\"",
                  "fullTitle": "KreskoAsset #initialization - wrapped \"before each\" hook in \"#initialization - wrapped\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const deployment = hardhat_1.default.krAssets.find(k => k.deployArgs.name === name);\nKreskoAsset = deployment.contract;\nKreskoAssetAnchor = deployment.anchor;",
                  "err": {},
                  "uuid": "5423d517-f234-4e43-870b-94d753a34253",
                  "parentUUID": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cant initialize twice",
                  "fullTitle": "KreskoAsset #initialization - wrapped cant initialize twice",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(KreskoAssetAnchor.initialize(KreskoAsset.address, name, symbol, addr.deployer)).to.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);",
                  "err": {},
                  "uuid": "cfd5111d-8ee3-44c6-a7d8-2c48735cdc8c",
                  "parentUUID": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cant initialize implementation",
                  "fullTitle": "KreskoAsset #initialization - wrapped cant initialize implementation",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const deployment = await hardhat_1.default.deployments.get(shared_1.anchorTokenPrefix + symbol);\nconst implementationAddress = deployment.implementation;\nconst KreskoAssetAnchorImpl = await hardhat_1.default.ethers.getContractAt(\"KreskoAssetAnchor\", implementationAddress);\nawait (0, chai_1.expect)(KreskoAssetAnchorImpl.initialize(KreskoAsset.address, name, symbol, addr.deployer)).to.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);",
                  "err": {},
                  "uuid": "6bac9f6e-d79f-426b-80f0-e194235077ce",
                  "parentUUID": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can reinitialize metadata",
                  "fullTitle": "KreskoAsset #initialization - wrapped can reinitialize metadata",
                  "timedOut": false,
                  "duration": 14,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const newName = \"foo\";\nconst newSymbol = \"bar\";\nawait (0, chai_1.expect)(KreskoAssetAnchor.updateMetaData(newName, newSymbol, 2)).to.not.be.revertedWith(test_1.Error.ALREADY_INITIALIZED_OZ);\n(0, chai_1.expect)(await KreskoAssetAnchor.name()).to.equal(newName);\n(0, chai_1.expect)(await KreskoAssetAnchor.symbol()).to.equal(newSymbol);",
                  "err": {},
                  "uuid": "94eb131e-e0f1-4ecf-a10e-41051ddb54a7",
                  "parentUUID": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "sets correct state",
                  "fullTitle": "KreskoAsset #initialization - wrapped sets correct state",
                  "timedOut": false,
                  "duration": 30,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await KreskoAssetAnchor.name()).to.equal(name);\n(0, chai_1.expect)(await KreskoAssetAnchor.symbol()).to.equal(shared_1.anchorTokenPrefix + symbol);\n(0, chai_1.expect)(await KreskoAssetAnchor.asset()).to.equal(KreskoAsset.address);\n(0, chai_1.expect)(await KreskoAssetAnchor.hasRole(test_1.Role.ADMIN, addr.deployer)).to.equal(true);\n(0, chai_1.expect)(await KreskoAssetAnchor.hasRole(test_1.Role.OPERATOR, hardhat_1.default.Diamond.address)).to.equal(true);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(await KreskoAsset.totalSupply());\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, chai_1.expect)(rebaseInfo.denominator).to.equal(0);\n(0, chai_1.expect)(rebaseInfo.positive).to.equal(false);",
                  "err": {},
                  "uuid": "2526fd7f-710c-4875-b221-a056b3d3b1a8",
                  "parentUUID": "aaff4cac-3997-4b84-8ba7-98a9a0b46340",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "cfd5111d-8ee3-44c6-a7d8-2c48735cdc8c",
                "6bac9f6e-d79f-426b-80f0-e194235077ce",
                "94eb131e-e0f1-4ecf-a10e-41051ddb54a7",
                "2526fd7f-710c-4875-b221-a056b3d3b1a8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 75,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "7a6cf4f0-8e82-492f-b372-55c284b5cea7",
          "title": "KreskoAsset",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/01-erc20.ts",
          "file": "/src/test/krasset/01-erc20.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before all\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "7acac1ed-bea3-4858-b565-9f94ffa65461",
              "parentUUID": "7a6cf4f0-8e82-492f-b372-55c284b5cea7",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before all\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 2,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "771909a1-4a5c-46b4-bbca-09728325766f",
              "parentUUID": "7a6cf4f0-8e82-492f-b372-55c284b5cea7",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "fcdb3b92-9820-4763-b68e-13f8b23e6b37",
              "parentUUID": "7a6cf4f0-8e82-492f-b372-55c284b5cea7",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 18,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "this.owner = users.deployer;\nthis.krAsset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === test_1.defaultKrAssetArgs.symbol);\nthis.mintAmount = 125;\nawait this.krAsset.contract.grantRole(test_1.Role.OPERATOR, this.owner.address);",
              "err": {},
              "uuid": "0f613da8-6481-48a9-888e-7a3ecdeb82bc",
              "parentUUID": "7a6cf4f0-8e82-492f-b372-55c284b5cea7",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "a4609292-2a84-476a-a145-e887b11c89ad",
              "title": "#mint",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/01-erc20.ts",
              "file": "/src/test/krasset/01-erc20.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow the owner to mint to their own address",
                  "fullTitle": "KreskoAsset #mint should allow the owner to mint to their own address",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(0);\nawait this.krAsset.contract.connect(this.owner).mint(this.owner.address, this.mintAmount);\n// Check total supply and owner's balances increased\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "5c31437d-9d23-4d28-90ba-7381bfc6cad4",
                  "parentUUID": "a4609292-2a84-476a-a145-e887b11c89ad",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the asset owner to mint to another address",
                  "fullTitle": "KreskoAsset #mint should allow the asset owner to mint to another address",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(0);\nawait this.krAsset.contract.connect(this.owner).mint(users.userOne.address, this.mintAmount);\n// Check total supply and user's balances increased\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "77ff7bcb-3e1d-4745-81c9-302113ef6892",
                  "parentUUID": "a4609292-2a84-476a-a145-e887b11c89ad",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow non-owner addresses to mint tokens",
                  "fullTitle": "KreskoAsset #mint should not allow non-owner addresses to mint tokens",
                  "timedOut": false,
                  "duration": 44,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(0);\nawait (0, chai_1.expect)(this.krAsset.contract.connect(users.userOne).mint(this.owner.address, this.mintAmount)).to.be.revertedWith(`AccessControl: account ${users.userOne.address.toLowerCase()} is missing role 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd`);\n// Check total supply and all account balances unchanged\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(0);",
                  "err": {},
                  "uuid": "4970c990-5fc5-4b3a-af24-3f3bd470eb7d",
                  "parentUUID": "a4609292-2a84-476a-a145-e887b11c89ad",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow admin to mint tokens",
                  "fullTitle": "KreskoAsset #mint should not allow admin to mint tokens",
                  "timedOut": false,
                  "duration": 37,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(this.krAsset.contract.connect(users.admin).mint(this.owner.address, this.mintAmount)).to.be.revertedWith(`AccessControl: account ${users.admin.address.toLowerCase()} is missing role 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd`);",
                  "err": {},
                  "uuid": "5155d289-1545-40f3-8e9d-5d68b5cf9b53",
                  "parentUUID": "a4609292-2a84-476a-a145-e887b11c89ad",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5c31437d-9d23-4d28-90ba-7381bfc6cad4",
                "77ff7bcb-3e1d-4745-81c9-302113ef6892",
                "4970c990-5fc5-4b3a-af24-3f3bd470eb7d",
                "5155d289-1545-40f3-8e9d-5d68b5cf9b53"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 127,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "7893140b-3a40-4814-b024-5466c4122af9",
              "title": "#burn",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/01-erc20.ts",
              "file": "/src/test/krasset/01-erc20.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#burn\"",
                  "fullTitle": "KreskoAsset #burn \"before each\" hook in \"#burn\"",
                  "timedOut": false,
                  "duration": 12,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "this.mintAmount = 250;\nawait this.krAsset.contract.connect(this.owner).mint(users.userOne.address, this.mintAmount);",
                  "err": {},
                  "uuid": "3fda879f-3e12-4834-a471-a55c1608e360",
                  "parentUUID": "7893140b-3a40-4814-b024-5466c4122af9",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow the owner to burn tokens from user's address (without token allowance)",
                  "fullTitle": "KreskoAsset #burn should allow the owner to burn tokens from user's address (without token allowance)",
                  "timedOut": false,
                  "duration": 62,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\nawait this.krAsset.contract.connect(this.owner).burn(users.userOne.address, this.mintAmount);\n// Check total supply and user's balances decreased\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(0);\n// Confirm that owner doesn't hold any tokens\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(0);",
                  "err": {},
                  "uuid": "7f54f438-e05a-4b6e-a7ef-b50e7099226a",
                  "parentUUID": "7893140b-3a40-4814-b024-5466c4122af9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the operator to burn tokens from user's address without changing existing allowances",
                  "fullTitle": "KreskoAsset #burn should allow the operator to burn tokens from user's address without changing existing allowances",
                  "timedOut": false,
                  "duration": 67,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.krAsset.contract.connect(this.owner).approve(users.userOne.address, this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.allowance(this.owner.address, users.userOne.address)).to.equal(this.mintAmount);\nawait this.krAsset.contract.connect(this.owner).burn(users.userOne.address, this.mintAmount);\n// Check total supply and user's balances decreased\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(0);\n// Confirm that owner doesn't hold any tokens\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(this.owner.address)).to.equal(0);\n// Confirm that token allowances are unchanged\n(0, chai_1.expect)(await this.krAsset.contract.allowance(this.owner.address, users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "8601a81d-2d1a-4850-ad13-3de95b03c1fc",
                  "parentUUID": "7893140b-3a40-4814-b024-5466c4122af9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow the operator to burn more tokens than user holds",
                  "fullTitle": "KreskoAsset #burn should not allow the operator to burn more tokens than user holds",
                  "timedOut": false,
                  "duration": 20,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const userBalance = await this.krAsset.contract.balanceOf(users.userOne.address);\nconst overUserBalance = Number(userBalance) + 1;\n// gh-actions fix\nif (process.env.TESTCI) {\n    await (0, chai_1.expect)(this.krAsset.contract.connect(this.owner).burn(users.userOne.address, overUserBalance)).to\n        .be.reverted;\n}\nelse {\n    await (0, chai_1.expect)(this.krAsset.contract.connect(this.owner).burn(users.userOne.address, overUserBalance)).to\n        .be.reverted;\n}\n// Check total supply and user's balances are unchanged\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "4c6026b3-885f-4f6d-aa39-daf7a78274a0",
                  "parentUUID": "7893140b-3a40-4814-b024-5466c4122af9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow non-operator addresses to burn tokens",
                  "fullTitle": "KreskoAsset #burn should not allow non-operator addresses to burn tokens",
                  "timedOut": false,
                  "duration": 35,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, chai_1.expect)(this.krAsset.contract.connect(users.userTwo).burn(users.userOne.address, this.mintAmount)).to.be.revertedWith(`AccessControl: account ${users.userTwo.address.toLowerCase()} is missing role 0x112e48a576fb3a75acc75d9fcf6e0bc670b27b1dbcd2463502e10e68cf57d6fd`);\n// Check total supply and user's balances unchanged\n(0, chai_1.expect)(await this.krAsset.contract.totalSupply()).to.equal(this.mintAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(users.userOne.address)).to.equal(this.mintAmount);",
                  "err": {},
                  "uuid": "61c944bb-8436-43dc-bff6-7a13fef25cf5",
                  "parentUUID": "7893140b-3a40-4814-b024-5466c4122af9",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "7f54f438-e05a-4b6e-a7ef-b50e7099226a",
                "8601a81d-2d1a-4850-ad13-3de95b03c1fc",
                "4c6026b3-885f-4f6d-aa39-daf7a78274a0",
                "61c944bb-8436-43dc-bff6-7a13fef25cf5"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 184,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "72bcfafa-1bf7-4d32-838a-6315bca3697d",
          "title": "KreskoAsset",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/02-krasset.ts",
          "file": "/src/test/krasset/02-krasset.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before all\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 4,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nusers = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "c5cec2de-5271-4565-a58e-1f2acbc41a9b",
              "parentUUID": "72bcfafa-1bf7-4d32-838a-6315bca3697d",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before all\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "550eb35e-acc7-400e-be1a-2e54478e3c50",
              "parentUUID": "72bcfafa-1bf7-4d32-838a-6315bca3697d",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 21,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "e1880911-621f-4802-952e-77c75185d7b4",
              "parentUUID": "72bcfafa-1bf7-4d32-838a-6315bca3697d",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAsset\"",
              "fullTitle": "KreskoAsset \"before each\" hook in \"KreskoAsset\"",
              "timedOut": false,
              "duration": 17,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "KreskoAsset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === test_1.defaultKrAssetArgs.symbol).contract;\n// Grant minting rights for test deployer\nawait KreskoAsset.grantRole(test_1.Role.OPERATOR, addr.deployer);",
              "err": {},
              "uuid": "3155ce4c-8814-493d-9afc-bf2434a0a281",
              "parentUUID": "72bcfafa-1bf7-4d32-838a-6315bca3697d",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "235799c1-5d4c-46c4-9f8c-d24ad4d21a70",
              "title": "#rebase",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/02-krasset.ts",
              "file": "/src/test/krasset/02-krasset.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can set a positive rebase",
                  "fullTitle": "KreskoAsset #rebase can set a positive rebase",
                  "timedOut": false,
                  "duration": 20,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = hardhat_1.default.toBig(\"1.525\");\nconst positive = true;\nawait (0, chai_1.expect)(KreskoAsset.rebase(denominator, positive)).to.not.be.reverted;\n(0, chai_1.expect)(await KreskoAsset.isRebased()).to.equal(true);\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, chai_1.expect)(rebaseInfo.denominator).equal(denominator);\n(0, chai_1.expect)(rebaseInfo.positive).equal(true);",
                  "err": {},
                  "uuid": "7148f462-f524-41f4-a59b-5290d10acc30",
                  "parentUUID": "235799c1-5d4c-46c4-9f8c-d24ad4d21a70",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can set a negative rebase",
                  "fullTitle": "KreskoAsset #rebase can set a negative rebase",
                  "timedOut": false,
                  "duration": 25,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = hardhat_1.default.toBig(\"1.525\");\nconst positive = false;\nawait (0, chai_1.expect)(KreskoAsset.rebase(denominator, positive)).to.not.be.reverted;\n(0, chai_1.expect)(await KreskoAsset.isRebased()).to.equal(true);\nconst rebaseInfo = await KreskoAsset.rebaseInfo();\n(0, chai_1.expect)(rebaseInfo.denominator).equal(denominator);\n(0, chai_1.expect)(rebaseInfo.positive).equal(false);",
                  "err": {},
                  "uuid": "5cd1daa0-0195-41d1-8771-33bd676e3baf",
                  "parentUUID": "235799c1-5d4c-46c4-9f8c-d24ad4d21a70",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can be disabled by setting the denominator to 1 ether",
                  "fullTitle": "KreskoAsset #rebase can be disabled by setting the denominator to 1 ether",
                  "timedOut": false,
                  "duration": 53,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const denominator = hardhat_1.default.toBig(1);\nconst positive = false;\nawait (0, chai_1.expect)(KreskoAsset.rebase(denominator, positive)).to.not.be.reverted;\n(0, chai_1.expect)(await KreskoAsset.isRebased()).to.equal(false);",
                  "err": {},
                  "uuid": "90ee464a-d866-4ce1-ae4f-db5963cdb5b8",
                  "parentUUID": "235799c1-5d4c-46c4-9f8c-d24ad4d21a70",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                  "title": "#balance + supply",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/02-krasset.ts",
                  "file": "/src/test/krasset/02-krasset.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "has no effect when not enabled",
                      "fullTitle": "KreskoAsset #rebase #balance + supply has no effect when not enabled",
                      "timedOut": false,
                      "duration": 15,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAsset.isRebased()).to.equal(false);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);",
                      "err": {},
                      "uuid": "4833d253-fbca-4c00-aa7a-63b43aa58d8c",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase @ 2",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase @ 2",
                      "timedOut": false,
                      "duration": 29,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 2;\nconst positive = true;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.mul(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "eb0c43b2-b41f-4f30-83d5-0d5b3753ed23",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase @ 3",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase @ 3",
                      "timedOut": false,
                      "duration": 33,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 3;\nconst positive = true;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.mul(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "2cb0cdf4-84cd-4bd7-a02c-5c7c7f877dae",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "increases balance and supply with positive rebase  @ 100",
                      "fullTitle": "KreskoAsset #rebase #balance + supply increases balance and supply with positive rebase  @ 100",
                      "timedOut": false,
                      "duration": 42,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 100;\nconst positive = true;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.mul(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.mul(denominator));",
                      "err": {},
                      "uuid": "082450de-2f61-4343-8bfc-93d8605c542b",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 2",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 2",
                      "timedOut": false,
                      "duration": 35,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 2;\nconst positive = false;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.div(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "a63a1cd8-2926-4324-879e-73170f4f98d8",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 3",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 3",
                      "timedOut": false,
                      "duration": 31,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 3;\nconst positive = false;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.div(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "4148ced2-ec23-4672-a33c-0ec91adc6270",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "reduces balance and supply with negative rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #balance + supply reduces balance and supply with negative rebase @ 100",
                      "timedOut": false,
                      "duration": 31,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const denominator = 100;\nconst positive = false;\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount.div(denominator));\n(0, chai_1.expect)(await KreskoAsset.totalSupply()).to.equal(test_1.defaultMintAmount.div(denominator));",
                      "err": {},
                      "uuid": "2917ccd8-549a-4f4b-a172-e6727258b05b",
                      "parentUUID": "fde29711-c678-45fb-9e1a-0afe9fc2e07f",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "4833d253-fbca-4c00-aa7a-63b43aa58d8c",
                    "eb0c43b2-b41f-4f30-83d5-0d5b3753ed23",
                    "2cb0cdf4-84cd-4bd7-a02c-5c7c7f877dae",
                    "082450de-2f61-4343-8bfc-93d8605c542b",
                    "a63a1cd8-2926-4324-879e-73170f4f98d8",
                    "4148ced2-ec23-4672-a33c-0ec91adc6270",
                    "2917ccd8-549a-4f4b-a172-e6727258b05b"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 216,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                  "title": "#transfer",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/02-krasset.ts",
                  "file": "/src/test/krasset/02-krasset.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "has default transfer behaviour after positive rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transfer behaviour after positive rebase",
                      "timedOut": false,
                      "duration": 65,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.mul(denominator);\nawait KreskoAsset.transfer(addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));",
                      "err": {},
                      "uuid": "8485a67a-3e13-42a2-89cd-53ed8343082c",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transfer behaviour after negative rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transfer behaviour after negative rebase",
                      "timedOut": false,
                      "duration": 63,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.div(denominator);\nawait KreskoAsset.transfer(addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));",
                      "err": {},
                      "uuid": "1e106799-e229-4fe4-b73b-c337b3a4b4cb",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after positive rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after positive rebase",
                      "timedOut": false,
                      "duration": 150,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nawait KreskoAsset.approve(addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.mul(denominator);\nawait KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, chai_1.expect)(KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount)).to.be.revertedWith(test_1.Error.NOT_ENOUGH_ALLOWANCE);\n(0, chai_1.expect)(await KreskoAsset.allowance(addr.deployer, addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "c083b520-d0d3-4d7b-9ff8-30b9b1b8a595",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after positive rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after positive rebase @ 100",
                      "timedOut": false,
                      "duration": 137,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 100;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nawait KreskoAsset.approve(addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.mul(denominator);\nawait KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, chai_1.expect)(KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount)).to.be.revertedWith(test_1.Error.NOT_ENOUGH_ALLOWANCE);\n(0, chai_1.expect)(await KreskoAsset.allowance(addr.deployer, addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "7750fccf-8c17-420d-91b1-e9c6cb210b39",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after negative rebase",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after negative rebase",
                      "timedOut": false,
                      "duration": 140,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nawait KreskoAsset.approve(addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.div(denominator);\nawait KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, chai_1.expect)(KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount)).to.be.revertedWith(test_1.Error.NOT_ENOUGH_ALLOWANCE);\n(0, chai_1.expect)(await KreskoAsset.allowance(addr.deployer, addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "0d742c94-d6dc-4e82-a5fb-bc6a1138e026",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "has default transferFrom behaviour after negative rebase @ 100",
                      "fullTitle": "KreskoAsset #rebase #transfer has default transferFrom behaviour after negative rebase @ 100",
                      "timedOut": false,
                      "duration": 140,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const transferAmount = hardhat_1.default.toBig(1);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAsset.mint(addr.userOne, test_1.defaultMintAmount);\nconst denominator = 100;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nawait KreskoAsset.approve(addr.userOne, transferAmount);\nconst rebaseInfodDefaultMintAMount = test_1.defaultMintAmount.div(denominator);\nawait KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.userOne)).to.equal(rebaseInfodDefaultMintAMount.add(transferAmount));\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebaseInfodDefaultMintAMount.sub(transferAmount));\nawait (0, chai_1.expect)(KreskoAsset.connect(users.userOne).transferFrom(addr.deployer, addr.userOne, transferAmount)).to.be.revertedWith(test_1.Error.NOT_ENOUGH_ALLOWANCE);\n(0, chai_1.expect)(await KreskoAsset.allowance(addr.deployer, addr.userOne)).to.equal(0);",
                      "err": {},
                      "uuid": "f0502143-28c9-43cc-a41d-e7db2366b178",
                      "parentUUID": "1eb77c3b-df1d-4ee9-bab5-78f75241def7",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "8485a67a-3e13-42a2-89cd-53ed8343082c",
                    "1e106799-e229-4fe4-b73b-c337b3a4b4cb",
                    "c083b520-d0d3-4d7b-9ff8-30b9b1b8a595",
                    "7750fccf-8c17-420d-91b1-e9c6cb210b39",
                    "0d742c94-d6dc-4e82-a5fb-bc6a1138e026",
                    "f0502143-28c9-43cc-a41d-e7db2366b178"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 695,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [
                "7148f462-f524-41f4-a59b-5290d10acc30",
                "5cd1daa0-0195-41d1-8771-33bd676e3baf",
                "90ee464a-d866-4ce1-ae4f-db5963cdb5b8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 98,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "385d6419-d243-4b0a-8a8a-408f49fb864c",
          "title": "KreskoAssetAnchor",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
          "file": "/src/test/krasset/03-krasset-anchor.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"KreskoAssetAnchor\"",
              "fullTitle": "KreskoAssetAnchor \"before all\" hook in \"KreskoAssetAnchor\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "bf288a23-437f-4209-bdcf-7e70870e3783",
              "parentUUID": "385d6419-d243-4b0a-8a8a-408f49fb864c",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAssetAnchor\"",
              "fullTitle": "KreskoAssetAnchor \"before each\" hook in \"KreskoAssetAnchor\"",
              "timedOut": false,
              "duration": 18,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "fa70df38-201b-474e-8296-83e0279525e1",
              "parentUUID": "385d6419-d243-4b0a-8a8a-408f49fb864c",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"KreskoAssetAnchor\"",
              "fullTitle": "KreskoAssetAnchor \"before each\" hook in \"KreskoAssetAnchor\"",
              "timedOut": false,
              "duration": 43,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nconst asset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === test_1.defaultKrAssetArgs.symbol);\nKreskoAsset = asset.contract;\nKreskoAssetAnchor = asset.anchor;\n// Grant minting rights for test deployer\nawait Promise.all([\n    KreskoAsset.grantRole(test_1.Role.OPERATOR, addr.deployer),\n    KreskoAssetAnchor.grantRole(test_1.Role.OPERATOR, addr.deployer),\n    KreskoAsset.approve(KreskoAssetAnchor.address, hardhat_1.default.ethers.constants.MaxUint256),\n]);",
              "err": {},
              "uuid": "23b80c88-1c56-4817-b94f-50e7d10be6d8",
              "parentUUID": "385d6419-d243-4b0a-8a8a-408f49fb864c",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "564c7966-c402-4ee2-9681-44a4a95697c2",
              "title": "#minting and burning",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
              "file": "/src/test/krasset/03-krasset-anchor.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "tracks the supply of underlying",
                  "fullTitle": "KreskoAssetAnchor #minting and burning tracks the supply of underlying",
                  "timedOut": false,
                  "duration": 37,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalSupply()).to.equal(0);\nawait KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(test_1.defaultMintAmount.add(test_1.defaultMintAmount));\n(0, chai_1.expect)(await KreskoAssetAnchor.totalSupply()).to.equal(0);",
                  "err": {},
                  "uuid": "cc26193b-4d06-4143-826b-c8d47678ea73",
                  "parentUUID": "564c7966-c402-4ee2-9681-44a4a95697c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "mints 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning mints 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 117,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(KreskoAssetAnchor.address)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);",
                  "err": {},
                  "uuid": "7b2b83d9-76ae-4bcb-b702-8fe1db6839bb",
                  "parentUUID": "564c7966-c402-4ee2-9681-44a4a95697c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "deposits 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning deposits 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 111,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(KreskoAssetAnchor.address)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);",
                  "err": {},
                  "uuid": "81bc81b5-c38a-42c6-bab5-97a71d8627ee",
                  "parentUUID": "564c7966-c402-4ee2-9681-44a4a95697c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "redeems 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning redeems 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 234,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\nawait KreskoAssetAnchor.redeem(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(KreskoAssetAnchor.address)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);",
                  "err": {},
                  "uuid": "b1cd1dc4-567b-4cf0-aa39-892c765bd846",
                  "parentUUID": "564c7966-c402-4ee2-9681-44a4a95697c2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "withdraws 1:1 with no rebases",
                  "fullTitle": "KreskoAssetAnchor #minting and burning withdraws 1:1 with no rebases",
                  "timedOut": false,
                  "duration": 223,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\nawait KreskoAssetAnchor.withdraw(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(KreskoAssetAnchor.address)).to.equal(0);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);",
                  "err": {},
                  "uuid": "af6d3b54-4c8b-4f08-8310-e85b706d1d4f",
                  "parentUUID": "564c7966-c402-4ee2-9681-44a4a95697c2",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [
                {
                  "uuid": "688a5523-ab86-4f1e-8b85-466d6edb9427",
                  "title": "#rebases",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
                  "file": "/src/test/krasset/03-krasset-anchor.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                      "title": "#conversions",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/krasset/03-krasset-anchor.ts",
                      "file": "/src/test/krasset/03-krasset-anchor.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "mints 1:1 and redeems 1:2 after 1:2 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 1:2 after 1:2 rebase",
                          "timedOut": false,
                          "duration": 268,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.mul(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.redeem(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "a4fa89ba-371d-411f-97ca-89a79f29869c",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 1:2 after 1:2 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 1:2 after 1:2 rebase",
                          "timedOut": false,
                          "duration": 269,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 2;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.mul(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.withdraw(rebasedAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "6ef3640f-26e0-41a2-829c-da163cffd5a9",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 1:6 after 1:6 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 1:6 after 1:6 rebase",
                          "timedOut": false,
                          "duration": 268,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 6;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.mul(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.redeem(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "b5c9347a-73dc-418b-ada2-5c1cbe9cc09a",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 1:6 after 1:6 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 1:6 after 1:6 rebase",
                          "timedOut": false,
                          "duration": 265,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 6;\nconst positive = true;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.mul(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.withdraw(rebasedAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "ddd5884d-b3d8-474e-bb87-81418abb9d59",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 2:1 after 2:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 2:1 after 2:1 rebase",
                          "timedOut": false,
                          "duration": 255,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.div(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.redeem(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "7aa01239-4856-4778-a453-366b9332d765",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 2:1 after 2:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 2:1 after 2:1 rebase",
                          "timedOut": false,
                          "duration": 248,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 2;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.div(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.withdraw(rebasedAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "5498f3d6-8fca-490c-a9a1-dbde242d3a87",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "mints 1:1 and redeems 6:1 after 6:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions mints 1:1 and redeems 6:1 after 6:1 rebase",
                          "timedOut": false,
                          "duration": 260,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.mint(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 6;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.div(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.redeem(test_1.defaultMintAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "f608b0a1-a9b8-41a6-8635-e3fdc48db186",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "deposits 1:1 and withdraws 6:1 after 6:1 rebase",
                          "fullTitle": "KreskoAssetAnchor #minting and burning #rebases #conversions deposits 1:1 and withdraws 6:1 after 6:1 rebase",
                          "timedOut": false,
                          "duration": 269,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await KreskoAsset.mint(addr.deployer, test_1.defaultMintAmount);\nawait KreskoAssetAnchor.deposit(test_1.defaultMintAmount, addr.deployer);\nconst denominator = 6;\nconst positive = false;\nawait KreskoAsset.rebase(hardhat_1.default.toBig(denominator), positive);\nconst rebasedAmount = test_1.defaultMintAmount.div(denominator);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(test_1.defaultMintAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.totalAssets()).to.equal(rebasedAmount);\nawait KreskoAssetAnchor.withdraw(rebasedAmount, addr.deployer, addr.deployer);\n(0, chai_1.expect)(await KreskoAsset.balanceOf(addr.deployer)).to.equal(rebasedAmount);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(addr.deployer)).to.equal(0);\n(0, chai_1.expect)(await KreskoAssetAnchor.balanceOf(KreskoAsset.address)).to.equal(0);",
                          "err": {},
                          "uuid": "64202565-cf99-43fd-80da-39ae0b8f8d65",
                          "parentUUID": "507b72ce-226d-45b2-ac15-e7262e18bdaf",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "a4fa89ba-371d-411f-97ca-89a79f29869c",
                        "6ef3640f-26e0-41a2-829c-da163cffd5a9",
                        "b5c9347a-73dc-418b-ada2-5c1cbe9cc09a",
                        "ddd5884d-b3d8-474e-bb87-81418abb9d59",
                        "7aa01239-4856-4778-a453-366b9332d765",
                        "5498f3d6-8fca-490c-a9a1-dbde242d3a87",
                        "f608b0a1-a9b8-41a6-8635-e3fdc48db186",
                        "64202565-cf99-43fd-80da-39ae0b8f8d65"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 2102,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [
                "cc26193b-4d06-4143-826b-c8d47678ea73",
                "7b2b83d9-76ae-4bcb-b702-8fe1db6839bb",
                "81bc81b5-c38a-42c6-bab5-97a71d8627ee",
                "b1cd1dc4-567b-4cf0-aa39-892c765bd846",
                "af6d3b54-4c8b-4f08-8310-e85b706d1d4f"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 722,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "0fb3c0f1-5b21-4dcd-80c2-a658b8bc45a7",
          "title": "Minter",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/00-init.ts",
          "file": "/src/test/minter/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "b09e6bff-c5f2-4f6c-8b23-ee685e8a04b6",
              "parentUUID": "0fb3c0f1-5b21-4dcd-80c2-a658b8bc45a7",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 19,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "36473de2-aa27-415d-815b-6763053f7d6d",
              "parentUUID": "0fb3c0f1-5b21-4dcd-80c2-a658b8bc45a7",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "f135a59c-c4b4-44c3-b5d3-2b6844906bae",
              "title": "#initialization",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/00-init.ts",
              "file": "/src/test/minter/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "sets correct initial state",
                  "fullTitle": "Minter #initialization sets correct initial state",
                  "timedOut": false,
                  "duration": 22,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await hardhat_1.default.Diamond.minterInitializations()).to.equal(1);\nconst { args } = await (0, shared_1.getMinterInitializer)(hardhat_1.default);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(test_1.Role.OPERATOR, args.operator)).to.equal(true);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(test_1.Role.SAFETY_COUNCIL, hardhat_1.default.Multisig.address)).to.equal(true);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.feeRecipient()).to.equal(args.feeRecipient);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.liquidationIncentiveMultiplier()).rawValue).to.equal(args.liquidationIncentiveMultiplier);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.minimumCollateralizationRatio()).rawValue).to.equal(args.minimumCollateralizationRatio);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.minimumDebtValue()).rawValue).to.equal(args.minimumDebtValue);",
                  "err": {},
                  "uuid": "53cce2b5-cede-4b04-81dd-db09c81a38f8",
                  "parentUUID": "f135a59c-c4b4-44c3-b5d3-2b6844906bae",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cant initialize twice",
                  "fullTitle": "Minter #initialization cant initialize twice",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const initializer = await (0, shared_1.getMinterInitializer)(hardhat_1.default);\nconst initializerContract = await hardhat_1.default.ethers.getContract(initializer.name);\nconst tx = await initializerContract.populateTransaction.initialize(initializer.args);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.upgradeState(tx.to, tx.data)).to.be.revertedWith(test_1.Error.ALREADY_INITIALIZED);",
                  "err": {},
                  "uuid": "e9e43f13-7582-4da6-9bc3-bff248ab64b2",
                  "parentUUID": "f135a59c-c4b4-44c3-b5d3-2b6844906bae",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "configures all facets correctly",
                  "fullTitle": "Minter #initialization configures all facets correctly",
                  "timedOut": false,
                  "duration": 52,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const facetsOnChain = (await hardhat_1.default.Diamond.facets()).map(([facetAddress, functionSelectors]) => ({\n    facetAddress,\n    functionSelectors,\n}));\n(0, chai_1.expect)(facetsOnChain).to.have.deep.members(hardhat_1.default.DiamondDeployment.facets.map(f => ({\n    facetAddress: f.facetAddress,\n    functionSelectors: f.functionSelectors,\n})));",
                  "err": {},
                  "uuid": "3bc0c7de-167e-4843-9860-50b0753c4540",
                  "parentUUID": "f135a59c-c4b4-44c3-b5d3-2b6844906bae",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "53cce2b5-cede-4b04-81dd-db09c81a38f8",
                "e9e43f13-7582-4da6-9bc3-bff248ab64b2",
                "3bc0c7de-167e-4843-9860-50b0753c4540"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 97,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "2729b319-89e0-4625-b260-2827165e7853",
          "title": "Minter",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/01-configuration.ts",
          "file": "/src/test/minter/01-configuration.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "e71de357-af2b-4d0e-800e-204025c200fb",
              "parentUUID": "2729b319-89e0-4625-b260-2827165e7853",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "728a9306-4271-4e85-880d-f045f1773f03",
              "parentUUID": "2729b319-89e0-4625-b260-2827165e7853",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "bdc75197-3cda-4fa7-97e1-625ef99000c4",
              "parentUUID": "2729b319-89e0-4625-b260-2827165e7853",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
              "title": "#configuration",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/01-configuration.ts",
              "file": "/src/test/minter/01-configuration.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can modify all parameters",
                  "fullTitle": "Minter #configuration can modify all parameters",
                  "timedOut": false,
                  "duration": 38,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const Diamond = hardhat_1.default.Diamond.connect(users.operator);\nconst update = (0, test_1.getNewMinterParams)(users.operator.address);\nawait (0, chai_1.expect)(Diamond.updateLiquidationIncentiveMultiplier(update.liquidationIncentiveMultiplier)).to.not.be\n    .reverted;\nawait (0, chai_1.expect)(Diamond.updateMinimumCollateralizationRatio(update.minimumCollateralizationRatio)).to.not.be\n    .reverted;\nawait (0, chai_1.expect)(Diamond.updateMinimumDebtValue(update.minimumDebtValue)).to.not.be.reverted;\nawait (0, chai_1.expect)(Diamond.updateLiquidationThreshold(update.liquidationThreshold)).to.not.be.reverted;\nawait (0, chai_1.expect)(Diamond.updateFeeRecipient(update.feeRecipient)).to.not.be.reverted;\nconst { liquidationIncentiveMultiplier, minimumCollateralizationRatio, minimumDebtValue, liquidationThreshold, feeRecipient, } = await hardhat_1.default.Diamond.getAllParams();\n(0, chai_1.expect)(update.liquidationIncentiveMultiplier.toBigInt()).to.equal(liquidationIncentiveMultiplier.rawValue);\n(0, chai_1.expect)(update.minimumCollateralizationRatio.toBigInt()).to.equal(minimumCollateralizationRatio.rawValue);\n(0, chai_1.expect)(update.minimumDebtValue.toBigInt()).to.equal(minimumDebtValue.rawValue);\n(0, chai_1.expect)(update.liquidationThreshold.toBigInt()).to.equal(liquidationThreshold.rawValue);\n(0, chai_1.expect)(update.feeRecipient).to.equal(feeRecipient);",
                  "err": {},
                  "uuid": "f5b27d08-8feb-44ba-a3b8-6da74f18b77b",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can add a collateral asset",
                  "fullTitle": "Minter #configuration can add a collateral asset",
                  "timedOut": false,
                  "duration": 1890,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { contract } = await (0, collaterals_1.addMockCollateralAsset)(test_1.defaultCollateralArgs);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.collateralExists(contract.address)).to.equal(true);\nconst [, oraclePrice] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(contract.address, hardhat_1.default.toBig(1), true);\n(0, chai_1.expect)(Number(oraclePrice)).to.equal(hardhat_1.default.toBig(test_1.defaultCollateralArgs.price, 8));",
                  "err": {},
                  "uuid": "27e0da0c-3113-439a-94ec-ebb430d2365d",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can add a kresko asset",
                  "fullTitle": "Minter #configuration can add a kresko asset",
                  "timedOut": false,
                  "duration": 2138,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { contract, kresko } = await (0, krassets_1.addMockKreskoAsset)();\nconst values = await kresko();\nconst kreskoPriceAnswer = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getKrAssetValue(contract.address, hardhat_1.default.toBig(1), true)).rawValue, 8);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.krAssetExists(contract.address)).to.equal(true);\n(0, chai_1.expect)(values.exists).to.equal(true);\n(0, chai_1.expect)(Number(values.kFactor)).to.equal(Number((0, lib_1.toFixedPoint)(test_1.defaultKrAssetArgs.factor)));\n(0, chai_1.expect)(kreskoPriceAnswer).to.equal(test_1.defaultKrAssetArgs.price);\n(0, chai_1.expect)(hardhat_1.default.fromBig(values.supplyLimit)).to.equal(test_1.defaultKrAssetArgs.supplyLimit);\n(0, chai_1.expect)(hardhat_1.default.fromBig(values.closeFee.rawValue)).to.equal(test_1.defaultKrAssetArgs.closeFee);\n(0, chai_1.expect)(hardhat_1.default.fromBig(values.openFee.rawValue)).to.equal(test_1.defaultKrAssetArgs.openFee);",
                  "err": {},
                  "uuid": "6408c75d-0834-4521-8c95-f28b699c082f",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update AMM oracle",
                  "fullTitle": "Minter #configuration can update AMM oracle",
                  "timedOut": false,
                  "duration": 32,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ammOracle = await smock_1.smock.fake(\"UniswapV2Oracle\");\nawait hardhat_1.default.Diamond.updateAMMOracle(ammOracle.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.ammOracle()).to.equal(ammOracle.address);",
                  "err": {},
                  "uuid": "36a341c6-45ad-4ae6-92f5-1aab34f90473",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update external oracle decimals",
                  "fullTitle": "Minter #configuration can update external oracle decimals",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const decimals = 8;\nawait hardhat_1.default.Diamond.updateExtOracleDecimals(decimals);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.extOracleDecimals()).to.equal(decimals);",
                  "err": {},
                  "uuid": "17c8996f-6c90-4184-8491-7e416d2e16a7",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can update values of a kresko asset",
                  "fullTitle": "Minter #configuration can update values of a kresko asset",
                  "timedOut": false,
                  "duration": 3129,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { contract, anchor, priceAggregator } = await (0, krassets_1.addMockKreskoAsset)();\nconst oracleAnswer = hardhat_1.default.fromBig(await priceAggregator.latestAnswer(), 8);\nconst kreskoAnswer = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getKrAssetValue(contract.address, hardhat_1.default.toBig(1), true)).rawValue, 8);\n(0, chai_1.expect)(oracleAnswer).to.equal(kreskoAnswer);\n(0, chai_1.expect)(oracleAnswer).to.equal(test_1.defaultKrAssetArgs.price);\nconst update = {\n    factor: (0, lib_1.toFixedPoint)(1.2),\n    supplyLimit: 12000,\n    price: 20,\n    closeFee: (0, lib_1.toFixedPoint)(0.02),\n    openFee: (0, lib_1.toFixedPoint)(0.02),\n};\nconst [newPriceFeed] = await (0, test_1.getMockOracleFor)(await contract.name(), update.price);\nawait hardhat_1.default.Diamond.connect(users.operator).updateKreskoAsset(contract.address, anchor.address, update.factor, newPriceFeed.address, hardhat_1.default.toBig(update.supplyLimit), update.closeFee, update.openFee);\nconst newValues = await hardhat_1.default.Diamond.kreskoAsset(contract.address);\nconst updatedOracleAnswer = hardhat_1.default.fromBig(await newPriceFeed.latestAnswer(), 8);\nconst newKreskoAnswer = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getKrAssetValue(contract.address, hardhat_1.default.toBig(1), true)).rawValue, 8);\n(0, chai_1.expect)(newValues.exists).to.equal(true);\n(0, chai_1.expect)(Number(newValues.kFactor)).to.equal(Number(update.factor));\n(0, chai_1.expect)(hardhat_1.default.fromBig(newValues.supplyLimit)).to.equal(update.supplyLimit);\n(0, chai_1.expect)(updatedOracleAnswer).to.equal(newKreskoAnswer);\n(0, chai_1.expect)(updatedOracleAnswer).to.equal(update.price);",
                  "err": {},
                  "uuid": "ca5a7e74-4ddb-4d74-bf65-e61a9c92ead8",
                  "parentUUID": "e175b0d2-a6bb-405e-836d-e9bde36e45f5",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "f5b27d08-8feb-44ba-a3b8-6da74f18b77b",
                "27e0da0c-3113-439a-94ec-ebb430d2365d",
                "6408c75d-0834-4521-8c95-f28b699c082f",
                "36a341c6-45ad-4ae6-92f5-1aab34f90473",
                "17c8996f-6c90-4184-8491-7e416d2e16a7",
                "ca5a7e74-4ddb-4d74-bf65-e61a9c92ead8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 7236,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "e0041008-257e-4b41-8b9a-2025ab816aca",
          "title": "Minter",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
          "file": "/src/test/minter/02-deposit-withdraw.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 6,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "35acd896-44f5-42d2-8a28-209f20eeb9f4",
              "parentUUID": "e0041008-257e-4b41-8b9a-2025ab816aca",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "441c4fa4-80a4-4e15-ac68-031778b53165",
              "parentUUID": "e0041008-257e-4b41-8b9a-2025ab816aca",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 21,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "0519a652-b95d-42a1-933c-7a0e51f5a930",
              "parentUUID": "e0041008-257e-4b41-8b9a-2025ab816aca",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 5,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "this.collateral = this.collaterals.find(c => c.deployArgs.name === _test_utils_1.defaultCollateralArgs.name);\nthis.initialBalance = (0, lib_1.toBig)(100000);\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [users.userOne.address]: this.initialBalance,\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [users.userOne.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(users.userOne.address)).to.equal(this.initialBalance);\nthis.depositArgs = {\n    user: users.userOne,\n    asset: this.collateral,\n    amount: (0, lib_1.toBig)(10000),\n};",
              "err": {},
              "uuid": "c20d808b-891b-48eb-b1a2-744ec0809048",
              "parentUUID": "e0041008-257e-4b41-8b9a-2025ab816aca",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "6ffe1ef0-b049-4b73-9abc-b743083734e0",
              "title": "#collateral",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
              "file": "/src/test/minter/02-deposit-withdraw.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                  "title": "#deposit",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow an account to deposit whitelisted collateral",
                      "fullTitle": "Minter #collateral #deposit should allow an account to deposit whitelisted collateral",
                      "timedOut": false,
                      "duration": 33,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Account has no deposited assets\nconst depositedCollateralAssetsBefore = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsBefore).to.deep.equal([]);\n// Deposit collateral\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount)).not.to.be.reverted;\n// Account now has deposited assets\nconst depositedCollateralAssetsAfter = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsAfter).to.deep.equal([this.collateral.address]);\n// Account's collateral deposit balances have increased\n(0, chai_1.expect)(await hardhat_1.default.Diamond.collateralDeposits(this.depositArgs.user.address, this.collateral.address)).to.equal(this.depositArgs.amount);\n// Kresko contract's collateral balance has increased\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address)).to.equal(this.depositArgs.amount);\n// Account's collateral balance has decreased\n(0, chai_1.expect)((0, lib_1.fromBig)(await this.collateral.contract.balanceOf(users.userOne.address))).to.equal((0, lib_1.fromBig)(this.initialBalance) - (0, lib_1.fromBig)(this.depositArgs.amount));",
                      "err": {},
                      "uuid": "6f60028c-68f4-409f-8012-968f9abd13a0",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an arbitrary account to deposit whitelisted collateral on behalf of another account",
                      "fullTitle": "Minter #collateral #deposit should allow an arbitrary account to deposit whitelisted collateral on behalf of another account",
                      "timedOut": false,
                      "duration": 37,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Load arbitrary user with sufficient collateral for testing purposes\nconst arbitraryUser = users.userThree;\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [arbitraryUser.address]: this.initialBalance,\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [arbitraryUser.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\n// Initially, the array of the user's deposited collateral assets should be empty.\nconst depositedCollateralAssetsBefore = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsBefore).to.deep.equal([]);\n// Deposit collateral\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount)).not.to.be.reverted;\n// Confirm the array of the user's deposited collateral assets has been pushed to.\nconst depositedCollateralAssetsAfter = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsAfter).to.deep.equal([this.collateral.address]);\n// Confirm the amount deposited is recorded for the user.\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(this.depositArgs.user.address, this.collateral.address);\n(0, chai_1.expect)(amountDeposited).to.equal(this.depositArgs.amount);\n// Confirm the amount as been transferred from the user into Kresko.sol\nconst kreskoBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(kreskoBalance).to.equal(this.depositArgs.amount);\n// Confirm the depositor's (arbitraryUser) wallet balance has been adjusted accordingly\nconst depositorBalanceAfter = await this.collateral.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)((0, lib_1.fromBig)(depositorBalanceAfter)).to.equal((0, lib_1.fromBig)(this.initialBalance) - (0, lib_1.fromBig)(this.depositArgs.amount));",
                      "err": {},
                      "uuid": "630082a8-1177-4291-830c-b99071b50c15",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an account to deposit more collateral to an existing deposit",
                      "fullTitle": "Minter #collateral #deposit should allow an account to deposit more collateral to an existing deposit",
                      "timedOut": false,
                      "duration": 39,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Deposit first batch of collateral\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount)).not.to.be.reverted;\n// Deposit second batch of collateral\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount)).not.to.be.reverted;\n// Confirm the array of the user's deposited collateral assets hasn't been double-pushed to.\nconst depositedCollateralAssetsAfter = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsAfter).to.deep.equal([this.collateral.address]);\n// Confirm the amount deposited is recorded for the user.\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(this.depositArgs.user.address, this.collateral.address);\n(0, chai_1.expect)(amountDeposited).to.equal(this.depositArgs.amount.add(this.depositArgs.amount));",
                      "err": {},
                      "uuid": "8cb01e5a-e0a9-44f2-8509-e205858072f2",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow an account to have deposited multiple collateral assets",
                      "fullTitle": "Minter #collateral #deposit should allow an account to have deposited multiple collateral assets",
                      "timedOut": false,
                      "duration": 1893,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Load user account with a different type of collateral\nconst collateralArgs = {\n    name: \"SecondCollateral\",\n    price: _test_utils_1.defaultOraclePrice,\n    factor: 1,\n    decimals: _test_utils_1.defaultDecimals,\n};\nconst { contract, mocks } = await (0, collaterals_1.addMockCollateralAsset)(collateralArgs);\nawait mocks.contract.setVariable(\"_balances\", {\n    [users.userOne.address]: this.initialBalance,\n});\nawait mocks.contract.setVariable(\"_allowances\", {\n    [users.userOne.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\n// Deposit batch of first collateral type\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount)).not.to.be.reverted;\n// Deposit batch of second collateral type\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, contract.address, this.depositArgs.amount)).not.to.be.reverted;\n// Confirm the array of the user's deposited collateral assets contains both collateral assets\nconst depositedCollateralAssetsAfter = await hardhat_1.default.Diamond.getDepositedCollateralAssets(this.depositArgs.user.address);\n(0, chai_1.expect)(depositedCollateralAssetsAfter).to.deep.equal([this.collateral.address, contract.address]);",
                      "err": {},
                      "uuid": "6d896a86-7cc5-4bf4-a2ed-77663dd85fc1",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit CollateralDeposited event",
                      "fullTitle": "Minter #collateral #deposit should emit CollateralDeposited event",
                      "timedOut": false,
                      "duration": 17,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tx = await hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, this.depositArgs.amount);\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, this.depositArgs.user), \"CollateralDeposited\");\n(0, chai_1.expect)(event.account).to.equal(this.depositArgs.user.address);\n(0, chai_1.expect)(event.collateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)(event.amount).to.equal(this.depositArgs.amount);",
                      "err": {},
                      "uuid": "b98b9020-c82c-4e38-beb9-f828516b590b",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if depositing collateral that has not been whitelisted",
                      "fullTitle": "Minter #collateral #deposit should revert if depositing collateral that has not been whitelisted",
                      "timedOut": false,
                      "duration": 9,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, \"0x0000000000000000000000000000000000000001\", this.depositArgs.amount)).to.be.revertedWith(errors_1.Error.COLLATERAL_DOESNT_EXIST);",
                      "err": {},
                      "uuid": "3fe3ed98-b600-46ec-9325-db67ca3247f2",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if depositing an amount of 0",
                      "fullTitle": "Minter #collateral #deposit should revert if depositing an amount of 0",
                      "timedOut": false,
                      "duration": 13,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.address, 0)).to.be.revertedWith(errors_1.Error.ZERO_DEPOSIT);",
                      "err": {},
                      "uuid": "288f2481-55cf-4b02-8c60-6735d59446cd",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should revert if collateral is not depositable",
                      "fullTitle": "Minter #collateral #deposit should revert if collateral is not depositable",
                      "timedOut": false,
                      "duration": 67,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { deployer, devTwo, extOne } = await hardhat_1.default.ethers.getNamedSigners();\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, true, 0], [deployer, devTwo, extOne]);\nconst isDepositPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isDepositPaused).to.equal(true);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.contract.address, 0)).to.be.revertedWith(errors_1.Error.ZERO_DEPOSIT);",
                      "err": {},
                      "uuid": "68da5824-3a2d-4f4c-88b3-d456bab28fac",
                      "parentUUID": "a6e4b7d4-d092-49e4-898d-4577d2bcb873",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "6f60028c-68f4-409f-8012-968f9abd13a0",
                    "630082a8-1177-4291-830c-b99071b50c15",
                    "8cb01e5a-e0a9-44f2-8509-e205858072f2",
                    "6d896a86-7cc5-4bf4-a2ed-77663dd85fc1",
                    "b98b9020-c82c-4e38-beb9-f828516b590b",
                    "3fe3ed98-b600-46ec-9325-db67ca3247f2",
                    "288f2481-55cf-4b02-8c60-6735d59446cd",
                    "68da5824-3a2d-4f4c-88b3-d456bab28fac"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 2108,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "adf3a42a-b25c-4c0d-a941-58a509bcf148",
                  "title": "#withdraw",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#withdraw\"",
                      "fullTitle": "Minter #collateral #withdraw \"before each\" hook in \"#withdraw\"",
                      "timedOut": false,
                      "duration": 16,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Deposit collateral\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(this.depositArgs.user).depositCollateral(this.depositArgs.user.address, this.collateral.contract.address, this.depositArgs.amount)).not.to.be.reverted;\nthis.collateral = this.collaterals[0];\nthis.depositAmount = this.depositArgs.amount;",
                      "err": {},
                      "uuid": "3d65ec4a-71ba-4f8a-8553-19616f4088d4",
                      "parentUUID": "adf3a42a-b25c-4c0d-a941-58a509bcf148",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                      "title": "when the account's minimum collateral value is 0",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should allow an account to withdraw their entire deposit",
                          "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 should allow an account to withdraw their entire deposit",
                          "timedOut": false,
                          "duration": 51,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const depositedCollateralAssets = await hardhat_1.default.Diamond.getDepositedCollateralAssets(users.userOne.address);\n(0, chai_1.expect)(depositedCollateralAssets).to.deep.equal([this.collateral.address]);\nawait hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, this.depositAmount, 0);\n// Ensure that the collateral asset is removed from the account's deposited collateral\n// assets array.\nconst depositedCollateralAssetsPostWithdraw = await hardhat_1.default.Diamond.getDepositedCollateralAssets(users.userOne.address);\n(0, chai_1.expect)(depositedCollateralAssetsPostWithdraw).to.deep.equal([]);\n// Ensure the change in the user's deposit is recorded.\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n(0, chai_1.expect)(amountDeposited).to.equal(0);\n// Ensure the amount transferred is correct\nconst kreskoBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(kreskoBalance).to.equal(0);\nconst userOneBalance = await this.collateral.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userOneBalance).to.equal(this.initialBalance);",
                          "err": {},
                          "uuid": "ddcb5d6c-233f-4c48-9619-3ed0f2476e8a",
                          "parentUUID": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should allow an account to withdraw a portion of their deposit",
                          "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 should allow an account to withdraw a portion of their deposit",
                          "timedOut": false,
                          "duration": 39,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const withdrawAmount = this.depositAmount.div(2);\nawait hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, withdrawAmount, 0);\n// Ensure the change in the user's deposit is recorded.\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n(0, chai_1.expect)(amountDeposited).to.equal(this.depositAmount.sub(withdrawAmount));\n// Ensure that the collateral asset is still in the account's deposited collateral\n// assets array.\nconst depositedCollateralAssets = await hardhat_1.default.Diamond.getDepositedCollateralAssets(users.userOne.address);\n(0, chai_1.expect)(depositedCollateralAssets).to.deep.equal([this.collateral.address]);\nconst kreskoBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(kreskoBalance).to.equal(this.depositAmount.sub(withdrawAmount));\nconst userOneBalance = await this.collateral.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userOneBalance).to.equal(this.initialBalance.sub(amountDeposited));",
                          "err": {},
                          "uuid": "8350e655-1d10-423a-b2e1-04d65cd870f9",
                          "parentUUID": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should allow trusted address to withdraw another accounts deposit",
                          "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 should allow trusted address to withdraw another accounts deposit",
                          "timedOut": false,
                          "duration": 49,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Grant userThree the MANAGER role\nawait hardhat_1.default.Diamond.connect(users.deployer).grantRole(_test_utils_1.Role.MANAGER, users.userThree.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(_test_utils_1.Role.MANAGER, users.userThree.address)).to.equal(true);\nconst collateralBefore = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).withdrawCollateral(users.userOne.address, this.collateral.address, this.depositAmount, 0)).to.not.be.reverted;\nconst collateralAfter = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n// Ensure that collateral was withdrawn\n(0, chai_1.expect)(collateralAfter).to.equal(collateralBefore.sub(this.depositAmount));",
                          "err": {},
                          "uuid": "3153d98b-2e91-4bbf-bbb1-917db95b77af",
                          "parentUUID": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should emit CollateralWithdrawn event",
                          "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 should emit CollateralWithdrawn event",
                          "timedOut": false,
                          "duration": 28,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const tx = await hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, this.depositAmount, 0);\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"CollateralWithdrawn\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.collateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)(event.amount).to.equal(this.depositAmount);",
                          "err": {},
                          "uuid": "3948b9f5-e739-49d1-893d-e13fad497707",
                          "parentUUID": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should not allow untrusted address to withdraw another accounts deposit",
                          "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 should not allow untrusted address to withdraw another accounts deposit",
                          "timedOut": false,
                          "duration": 33,
                          "state": "passed",
                          "speed": "fast",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).withdrawCollateral(users.userOne.address, this.collateral.address, this.initialBalance, 0)).to.be.revertedWith(`AccessControl: account ${users.userThree.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                          "err": {},
                          "uuid": "5e788e15-6985-46ea-85b2-4453e8972e91",
                          "parentUUID": "da8a6d3c-c19e-43ce-b36c-1c8ac47835b6",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [
                        {
                          "uuid": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                          "title": "when the account's minimum collateral value is > 0",
                          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                          "file": "/src/test/minter/02-deposit-withdraw.ts",
                          "beforeHooks": [
                            {
                              "title": "\"before each\" hook in \"when the account's minimum collateral value is > 0\"",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 \"before each\" hook in \"when the account's minimum collateral value is > 0\"",
                              "timedOut": false,
                              "duration": 58,
                              "state": null,
                              "speed": null,
                              "pass": false,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "this.krAsset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === _test_utils_1.defaultKrAssetArgs.symbol);\n// userOne mints some kr assets\nthis.mintAmount = (0, lib_1.toBig)(100);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, this.mintAmount);\n// Mint amount differs from deposited amount due to open fee\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\nthis.initialUserOneDeposited = amountDeposited;\nthis.mcr = await hardhat_1.default.Diamond.minimumCollateralizationRatio();",
                              "err": {},
                              "uuid": "dc5940fd-d5d5-40be-875e-4e90ab373f82",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": true,
                              "skipped": false
                            }
                          ],
                          "afterHooks": [],
                          "tests": [
                            {
                              "title": "should allow an account to withdraw their deposit if it does not violate the health factor",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should allow an account to withdraw their deposit if it does not violate the health factor",
                              "timedOut": false,
                              "duration": 121,
                              "state": "passed",
                              "speed": "slow",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = (0, lib_1.toBig)(10);\n// Ensure that the withdrawal would not put the account's collateral value\n// less than the account's minimum collateral value:\nconst accountMinCollateralValue = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, this.mcr);\nconst accountCollateralValue = await hardhat_1.default.Diamond.getAccountCollateralValue(users.userOne.address);\nconst [withdrawnCollateralValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.collateral.address, withdrawAmount, false);\n(0, chai_1.expect)(accountCollateralValue.rawValue\n    .sub(withdrawnCollateralValue.rawValue)\n    .gte(accountMinCollateralValue.rawValue)).to.be.true;\nawait hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, withdrawAmount, 0);\n// Ensure that the collateral asset is still in the account's deposited collateral\n// assets array.\nconst depositedCollateralAssets = await hardhat_1.default.Diamond.getDepositedCollateralAssets(users.userOne.address);\n(0, chai_1.expect)(depositedCollateralAssets).to.deep.equal([this.collateral.address]);\n// Ensure the change in the user's deposit is recorded.\nconst amountDeposited = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n(0, chai_1.expect)(amountDeposited).to.equal(this.depositAmount.sub(withdrawAmount));\n// Check the balances of the contract and user\nconst kreskoBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(kreskoBalance).to.equal(this.depositAmount.sub(withdrawAmount));\nconst userOneBalance = await this.collateral.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userOneBalance).to.equal(this.initialBalance.sub(this.depositAmount.sub(withdrawAmount)));\n// Ensure the account's minimum collateral value is <= the account collateral value\n// These are FixedPoint.Unsigned, be sure to use `rawValue` when appropriate!\nconst accountMinCollateralValueAfter = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, this.mcr);\nconst accountCollateralValueAfter = await hardhat_1.default.Diamond.getAccountCollateralValue(users.userOne.address);\n(0, chai_1.expect)(accountMinCollateralValueAfter.rawValue.lte(accountCollateralValueAfter.rawValue)).to.be\n    .true;",
                              "err": {},
                              "uuid": "824e011f-ffa4-4d85-8735-c818091cd5ed",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should allow withdraws that exceed deposits and only send the user total deposit available",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should allow withdraws that exceed deposits and only send the user total deposit available",
                              "timedOut": false,
                              "duration": 99,
                              "state": "passed",
                              "speed": "slow",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const user = users.userFour;\nawait this.collateral.setBalance(user, ethers_1.BigNumber.from(0));\nawait this.collateral.setBalance(user, (0, lib_1.toBig)(1000));\nawait this.collateral.contract\n    .connect(user)\n    .approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: (0, lib_1.toBig)(1000),\n    user,\n});\nawait (0, collaterals_1.withdrawCollateral)({\n    asset: this.collateral,\n    amount: (0, lib_1.toBig)(1010),\n    user,\n});\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(user.address)).to.equal((0, lib_1.toBig)(1000));",
                              "err": {},
                              "uuid": "dfa4e97b-1011-480d-ba61-2e5a78d46169",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if withdrawing an amount of 0",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if withdrawing an amount of 0",
                              "timedOut": false,
                              "duration": 16,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, 0, withdrawAmount)).to.be.revertedWith(errors_1.Error.ZERO_WITHDRAW);",
                              "err": {},
                              "uuid": "fae223d3-2d93-4399-b347-0dd52aab6cd8",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if the withdrawal violates the health factor",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if the withdrawal violates the health factor",
                              "timedOut": false,
                              "duration": 68,
                              "state": "passed",
                              "speed": "medium",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "// userOne has a debt position, so attempting to withdraw the entire collateral deposit should be impossible\nconst withdrawAmount = this.initialBalance;\n// Ensure that the withdrawal would in fact put the account's collateral value\n// less than the account's minimum collateral value:\nconst accountMinCollateralValue = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, this.mcr);\nconst accountCollateralValue = await hardhat_1.default.Diamond.getAccountCollateralValue(users.userOne.address);\nconst [withdrawnCollateralValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.collateral.address, withdrawAmount, false);\n(0, chai_1.expect)(accountCollateralValue.rawValue\n    .sub(withdrawnCollateralValue.rawValue)\n    .lt(accountMinCollateralValue.rawValue)).to.be.true;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, withdrawAmount, 0)).to.be.revertedWith(errors_1.Error.COLLATERAL_INSUFFICIENT_AMOUNT);",
                              "err": {},
                              "uuid": "f5fc469d-6142-4e60-9ef0-409675f6fd7c",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": false,
                              "skipped": false
                            },
                            {
                              "title": "should revert if the depositedCollateralAssetIndex is incorrect",
                              "fullTitle": "Minter #collateral #withdraw when the account's minimum collateral value is 0 when the account's minimum collateral value is > 0 should revert if the depositedCollateralAssetIndex is incorrect",
                              "timedOut": false,
                              "duration": 9,
                              "state": "passed",
                              "speed": "fast",
                              "pass": true,
                              "fail": false,
                              "pending": false,
                              "context": null,
                              "code": "const withdrawAmount = this.depositAmount.div(2);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).withdrawCollateral(users.userOne.address, this.collateral.address, withdrawAmount, 1)).to.be.revertedWith(errors_1.Error.ARRAY_OUT_OF_BOUNDS);",
                              "err": {},
                              "uuid": "fe43bc4a-3e1c-494a-96ef-14dc715ed8f7",
                              "parentUUID": "138f79f4-e8f1-4145-ba95-e40a258e0672",
                              "isHook": false,
                              "skipped": false
                            }
                          ],
                          "suites": [],
                          "passes": [
                            "824e011f-ffa4-4d85-8735-c818091cd5ed",
                            "dfa4e97b-1011-480d-ba61-2e5a78d46169",
                            "fae223d3-2d93-4399-b347-0dd52aab6cd8",
                            "f5fc469d-6142-4e60-9ef0-409675f6fd7c",
                            "fe43bc4a-3e1c-494a-96ef-14dc715ed8f7"
                          ],
                          "failures": [],
                          "pending": [],
                          "skipped": [],
                          "duration": 313,
                          "root": false,
                          "rootEmpty": false,
                          "_timeout": 15000
                        }
                      ],
                      "passes": [
                        "ddcb5d6c-233f-4c48-9619-3ed0f2476e8a",
                        "8350e655-1d10-423a-b2e1-04d65cd870f9",
                        "3153d98b-2e91-4bbf-bbb1-917db95b77af",
                        "3948b9f5-e739-49d1-893d-e13fad497707",
                        "5e788e15-6985-46ea-85b2-4453e8972e91"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 200,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "8f058c09-d11f-434a-97e4-0d379c39c777",
                  "title": "#deposit - rebase events",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#deposit - rebase events\"",
                      "fullTitle": "Minter #collateral #deposit - rebase events \"before each\" hook in \"#deposit - rebase events\"",
                      "timedOut": false,
                      "duration": 125,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "arbitraryUser = hardhat_1.default.users.userThree;\narbitraryUserDiamond = hardhat_1.default.Diamond.connect(arbitraryUser);\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [arbitraryUser.address]: this.initialBalance,\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [arbitraryUser.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\nthis.krAsset = this.krAssets.find(k => k.deployArgs.name === _test_utils_1.defaultKrAssetArgs.name);\n// grant operator role to deployer for rebases\nawait this.krAsset.contract.grantRole(_test_utils_1.Role.OPERATOR, users.deployer.address);\nconst assetInfo = await this.krAsset.kresko();\n// Add krAsset as a collateral with anchor and cFactor of 1\nawait hardhat_1.default.Diamond.connect(users.operator).addCollateralAsset(this.krAsset.contract.address, this.krAsset.anchor.address, hardhat_1.default.toBig(1), assetInfo.oracle);\n// Allowance for Kresko\nawait this.krAsset.contract\n    .connect(arbitraryUser)\n    .approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\n// Deposit some collateral\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.collateral.address, this.depositArgs.amount);\n// Mint some krAssets\nawait arbitraryUserDiamond.mintKreskoAsset(arbitraryUser.address, this.krAsset.address, mintAmount);\n// Deposit all debt on tests\nthis.krAssetCollateralAmount = await arbitraryUserDiamond.kreskoAssetDebt(arbitraryUser.address, this.krAsset.address);",
                      "err": {},
                      "uuid": "8d11c213-8931-43d0-9523-001cddea1f99",
                      "parentUUID": "8f058c09-d11f-434a-97e4-0d379c39c777",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                      "title": "deposit amounts are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when deposit is made before positive rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made before positive rebase",
                          "timedOut": false,
                          "duration": 64,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst expectedDepositsAfter = this.krAssetCollateralAmount.mul(denominator);\nconst depositsBefore = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsBefore).to.not.bignumber.equal(finalDeposits);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(expectedDepositsAfter);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "2d717e37-e66a-46d4-aa77-06ef841b1a35",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made before negative rebase",
                          "timedOut": false,
                          "duration": 59,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst depositAmountAfterRebase = this.krAssetCollateralAmount.div(denominator);\n// Deposit\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst depositsBefore = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsBefore).to.not.bignumber.equal(finalDeposits);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(depositAmountAfterRebase);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "8d14b6c3-eacf-4364-90a5-18c503b2d9d8",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an positiveing rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 60,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\nconst depositsBefore = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\n// Get collateral deposits after\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, chai_1.expect)(depositsBefore).to.not.bignumber.equal(finalDeposits);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(depositAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "319c0e79-48cc-40a1-849f-75cda06d86ac",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made after an negative rebase",
                          "timedOut": false,
                          "duration": 60,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\nconst depositsBefore = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\n// Get collateral deposits after\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, chai_1.expect)(depositsBefore).to.not.bignumber.equal(finalDeposits);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(depositAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "b3fbc6ac-48e7-4e5e-8136-bacff265221a",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a positiveing rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 85,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get deposits after\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(halfDepositAfterRebase);\n// Deposit second time\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositAfterRebase);\n// Get deposits after\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(fullDepositAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "907fd1f6-3592-4263-9be7-da2cf63b2ef5",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit amounts are calculated correctly when deposit is made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 93,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositBeforeRebase);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get deposits after\nconst depositsAfterRebase = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsAfterRebase).to.bignumber.equal(halfDepositAfterRebase);\n// Deposit second time\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositAfterRebase);\n// Get deposits after\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalDeposits).to.bignumber.equal(fullDepositAmount);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(0);",
                          "err": {},
                          "uuid": "a6e5ff49-0bd7-471e-95a5-22876d02c070",
                          "parentUUID": "3061eb55-938b-4c97-8c22-c3303b34ae29",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "2d717e37-e66a-46d4-aa77-06ef841b1a35",
                        "8d14b6c3-eacf-4364-90a5-18c503b2d9d8",
                        "319c0e79-48cc-40a1-849f-75cda06d86ac",
                        "b3fbc6ac-48e7-4e5e-8136-bacff265221a",
                        "907fd1f6-3592-4263-9be7-da2cf63b2ef5",
                        "a6e5ff49-0bd7-471e-95a5-22876d02c070"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 421,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                      "title": "deposit usd values are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when deposit is made before positiveing rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made before positiveing rebase",
                          "timedOut": false,
                          "duration": 84,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst valueBefore = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\nthis.krAsset.setPrice(newPrice);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get collateral value of account after\nconst valueAfter = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(valueBefore.rawValue).to.bignumber.equal(valueAfter.rawValue);",
                          "err": {},
                          "uuid": "1957af97-1224-40c8-8504-353ff4ffa98a",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made before negative rebase",
                          "timedOut": false,
                          "duration": 80,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "await arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst valueBefore = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\nthis.krAsset.setPrice(newPrice);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get collateral value of account after\nconst valueAfter = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(valueBefore.rawValue).to.bignumber.equal(valueAfter.rawValue);",
                          "err": {},
                          "uuid": "4b28c8e1-e23c-4db2-b43b-b19344ad8b5a",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an positiveing rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 66,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\n// Get expected value before rebase and deposit\nconst [expectedValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, this.krAssetCollateralAmount, false);\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit rebased amount after\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\n// Get collateral value of account after\nconst [valueAfter] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, depositAmount, false);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfter.rawValue);",
                          "err": {},
                          "uuid": "2141db54-012f-4856-b9ae-52ee4e55a51c",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made after an negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made after an negative rebase",
                          "timedOut": false,
                          "duration": 60,
                          "state": "passed",
                          "speed": "medium",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\n// Get expected value before rebase and deposit\nconst [expectedValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, this.krAssetCollateralAmount, false);\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit rebased amount after\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\n// Get collateral value of account after\nconst [valueAfter] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, depositAmount, false);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfter.rawValue);",
                          "err": {},
                          "uuid": "46c79453-8f48-484d-ab6c-cf635752a665",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a positiveing rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 106,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositBeforeRebase);\nconst [expectedValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, halfDepositBeforeRebase, false);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get value after\nconst [valueAfterRebase] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, halfDepositAfterRebase, false);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfterRebase.rawValue);\n// Calculate added value since price adjusted in the rebase\nconst [expectedValueAfterSecondDeposit] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, fullDepositAmount, false);\n// Deposit more\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositAfterRebase);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(finalValue.rawValue).to.bignumber.equal(expectedValueAfterSecondDeposit.rawValue);",
                          "err": {},
                          "uuid": "c4e7588a-cef8-448f-8e3e-703a1b5d20b0",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when deposit is made before and after a negative rebase",
                          "fullTitle": "Minter #collateral #deposit - rebase events deposit usd values are calculated correctly when deposit is made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 101,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\n// Deposit half before, half after\nconst halfDepositBeforeRebase = this.krAssetCollateralAmount.div(2);\nconst halfDepositAfterRebase = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositBeforeRebase);\nconst [expectedValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, halfDepositBeforeRebase, false);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get value after\nconst [valueAfterRebase] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, halfDepositAfterRebase, false);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfterRebase.rawValue);\n// Calculate added value since price adjusted in the rebase\nconst [expectedValueAfterSecondDeposit] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.krAsset.address, fullDepositAmount, false);\n// Deposit more\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, halfDepositAfterRebase);\n// Get deposits after\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(finalValue.rawValue).to.bignumber.equal(expectedValueAfterSecondDeposit.rawValue);",
                          "err": {},
                          "uuid": "26e46a9f-b743-4b2b-875e-6867bf1e14c7",
                          "parentUUID": "f8a4b02a-8ed0-4e90-86c7-8770d1086e67",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "1957af97-1224-40c8-8504-353ff4ffa98a",
                        "4b28c8e1-e23c-4db2-b43b-b19344ad8b5a",
                        "2141db54-012f-4856-b9ae-52ee4e55a51c",
                        "46c79453-8f48-484d-ab6c-cf635752a665",
                        "c4e7588a-cef8-448f-8e3e-703a1b5d20b0",
                        "26e46a9f-b743-4b2b-875e-6867bf1e14c7"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 497,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "a34e6f23-0d61-4f6f-8520-13ab6c4602d5",
                  "title": "#withdraw - rebase events",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                  "file": "/src/test/minter/02-deposit-withdraw.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#withdraw - rebase events\"",
                      "fullTitle": "Minter #collateral #withdraw - rebase events \"before each\" hook in \"#withdraw - rebase events\"",
                      "timedOut": false,
                      "duration": 124,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "arbitraryUser = users.userThree;\narbitraryUserDiamond = hardhat_1.default.Diamond.connect(arbitraryUser);\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [arbitraryUser.address]: this.initialBalance,\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [arbitraryUser.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\nthis.krAsset = this.krAssets.find(k => k.deployArgs.name === _test_utils_1.defaultKrAssetArgs.name);\n// grant operator role to deployer for rebases\nawait this.krAsset.contract.grantRole(_test_utils_1.Role.OPERATOR, users.deployer.address);\nconst assetInfo = await this.krAsset.kresko();\n// Add krAsset as a collateral with anchor and cFactor of 1\nawait hardhat_1.default.Diamond.connect(users.operator).addCollateralAsset(this.krAsset.contract.address, this.krAsset.anchor.address, hardhat_1.default.toBig(1), assetInfo.oracle);\n// Allowance for Kresko\nawait this.krAsset.contract\n    .connect(arbitraryUser)\n    .approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\n// Deposit some collateral\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.collateral.address, this.depositArgs.amount);\n// Mint some krAssets\nawait arbitraryUserDiamond.mintKreskoAsset(arbitraryUser.address, this.krAsset.address, mintAmount);\n// Deposit all debt on tests\nthis.krAssetCollateralAmount = await arbitraryUserDiamond.kreskoAssetDebt(arbitraryUser.address, this.krAsset.address);",
                      "err": {},
                      "uuid": "6f7bd2fe-490c-47d2-b71e-7833d29c03bc",
                      "parentUUID": "a34e6f23-0d61-4f6f-8520-13ab6c4602d5",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "cce580b6-4995-40e4-801b-3aade235d1a5",
                      "title": "withdraw amounts are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when withdrawing a deposit made before positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made before positiveing rebase",
                          "timedOut": false,
                          "duration": 123,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Deposit collateral before rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "027adeef-d6ad-493d-9230-8f618ee614d4",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made before negative rebase",
                          "timedOut": false,
                          "duration": 132,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit collateral before rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is adjusted by the rebase\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "7f11b865-715f-4d00-b029-8c6168fe8ded",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after an positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 121,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Get collateral deposits after\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "694d5c0f-5fbe-4b5a-870f-806be977ab51",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after an negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made after an negative rebase",
                          "timedOut": false,
                          "duration": 138,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Get collateral deposits after\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral balance is what was deposited as no rebases occured after\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(rebasedDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "ea321a95-d900-45d5-bfb1-f922a3a8659f",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 151,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Deposit half before, half (rebase adjusted) after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Deposit before the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, firstDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Get deposits before\nconst depositsFirst = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(depositsFirst).to.bignumber.equal(firstDepositAmount);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, secondDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure deposit balance matches expected\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(fullDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, fullDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "c71d96a9-594e-479f-89d3-2cf656a2d468",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a deposit made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 164,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Deposit half before, half (rebase adjusted) after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).div(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit before the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, firstDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Get deposits before\nconst depositsFirst = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(depositsFirst).to.bignumber.equal(firstDepositAmount);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit after the rebase\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, secondDepositAmount);\n// Get collateral deposits after\nconst depositsAfter = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\n// Ensure deposit balance matches expected\n(0, chai_1.expect)(depositsAfter).to.bignumber.equal(fullDepositAmount);\n// Withdraw rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, fullDepositAmount, cIndex);\nconst finalDeposits = await hardhat_1.default.Diamond.collateralDeposits(arbitraryUser.address, this.krAsset.address);\nconst finalBalance = await this.krAsset.contract.balanceOf(arbitraryUser.address);\n(0, chai_1.expect)(finalDeposits).to.equal(0);\n(0, chai_1.expect)(finalBalance).to.bignumber.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "b401592d-ed76-4065-93e6-f6323fcbfcef",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a non-rebased collateral after a rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw amounts are calculated correctly when withdrawing a non-rebased collateral after a rebase",
                          "timedOut": false,
                          "duration": 99,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\nconst withdrawAmount = (0, lib_1.toBig)(10);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst nrcBalanceBefore = await this.collateral.contract.balanceOf(arbitraryUser.address);\nconst expectedNrcBalanceAfter = nrcBalanceBefore.add(withdrawAmount);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.collateral.address);\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.collateral.address, withdrawAmount, cIndex);\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(expectedNrcBalanceAfter);",
                          "err": {},
                          "uuid": "0ef7434c-3327-4d45-999e-c6140f70d883",
                          "parentUUID": "cce580b6-4995-40e4-801b-3aade235d1a5",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "027adeef-d6ad-493d-9230-8f618ee614d4",
                        "7f11b865-715f-4d00-b029-8c6168fe8ded",
                        "694d5c0f-5fbe-4b5a-870f-806be977ab51",
                        "ea321a95-d900-45d5-bfb1-f922a3a8659f",
                        "c71d96a9-594e-479f-89d3-2cf656a2d468",
                        "b401592d-ed76-4065-93e6-f6323fcbfcef",
                        "0ef7434c-3327-4d45-999e-c6140f70d883"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 928,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                      "title": "withdraw usd values are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/02-deposit-withdraw.ts",
                      "file": "/src/test/minter/02-deposit-withdraw.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when withdrawing a deposit made before positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a deposit made before positiveing rebase",
                          "timedOut": false,
                          "duration": 132,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "d5cc3ba5-6f18-4b92-9c18-7ab59abbcb69",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a deposit made before negative rebase",
                          "timedOut": false,
                          "duration": 123,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\nconst rebasedDepositAmount = this.krAssetCollateralAmount.div(denominator);\n// Deposit\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Withdraw the full rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, rebasedDepositAmount, cIndex);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(rebasedDepositAmount);",
                          "err": {},
                          "uuid": "fe84ff5e-100a-4a5a-bbd5-a30603358130",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrwaing a deposit made after an positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrwaing a deposit made after an positiveing rebase",
                          "timedOut": false,
                          "duration": 116,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\nconst depositAmount = this.krAssetCollateralAmount.mul(denominator);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit rebased amount after\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Withdraw the full rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, depositAmount, cIndex);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(depositAmount);",
                          "err": {},
                          "uuid": "27e77cd5-f270-4137-a548-e0b143465f57",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made after an negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a deposit made after an negative rebase",
                          "timedOut": false,
                          "duration": 117,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\nconst depositAmount = this.krAssetCollateralAmount.div(denominator);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Deposit rebased amount after\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, depositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Withdraw the full rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, depositAmount, cIndex);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(depositAmount);",
                          "err": {},
                          "uuid": "76a27a03-c469-474d-93b4-903da05fd5f8",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a positiveing rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a deposit made before and after a positiveing rebase",
                          "timedOut": false,
                          "duration": 606,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\n// Deposit half before, half after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(2).mul(denominator);\nconst fullDepositAmount = this.krAssetCollateralAmount.mul(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, firstDepositAmount);\nconst [expectedValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get value after\nconst [valueAfterRebase] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfterRebase.rawValue);\n// Deposit more\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, secondDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Withdraw the full rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, fullDepositAmount, cIndex);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "af815a90-23a2-4eb9-833d-e56adb92cbf0",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a deposit made before and after a negative rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a deposit made before and after a negative rebase",
                          "timedOut": false,
                          "duration": 183,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) * denominator;\n// Deposit half before, half after\nconst firstDepositAmount = this.krAssetCollateralAmount.div(2);\nconst secondDepositAmount = this.krAssetCollateralAmount.div(denominator).div(2);\nconst fullDepositAmount = this.krAssetCollateralAmount.div(denominator);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, firstDepositAmount);\nconst [expectedValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Get value after\nconst [valueAfterRebase] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n// Ensure that the collateral value stays the same\n(0, chai_1.expect)(expectedValue.rawValue).to.bignumber.equal(valueAfterRebase.rawValue);\n// Deposit more\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, secondDepositAmount);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.krAsset.address);\n// Withdraw the full rebased amount\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.krAsset.address, fullDepositAmount, cIndex);\n// Get value\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.krAsset.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(0);\n(0, chai_1.expect)(await this.krAsset.contract.balanceOf(arbitraryUser.address)).to.bignumber.equal(fullDepositAmount);",
                          "err": {},
                          "uuid": "ddf6cd5c-2189-48db-8e63-87df4276eb6e",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when withdrawing a non-rebased collateral after a rebase",
                          "fullTitle": "Minter #collateral #withdraw - rebase events withdraw usd values are calculated correctly when withdrawing a non-rebased collateral after a rebase",
                          "timedOut": false,
                          "duration": 154,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst newPrice = (0, lib_1.fromBig)(await this.krAsset.getPrice(), 8) / denominator;\nconst withdrawAmount = (0, lib_1.toBig)(10);\nawait arbitraryUserDiamond.depositCollateral(arbitraryUser.address, this.krAsset.address, this.krAssetCollateralAmount);\nconst accountValueBefore = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\nconst [nrcValueBefore] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.collateral.address);\nconst [withdrawValue] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.collateral.address, withdrawAmount, false);\nconst expectedNrcValueAfter = nrcValueBefore.rawValue.sub(withdrawValue.rawValue);\n// Rebase the asset according to params\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst cIndex = await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(arbitraryUser.address, this.collateral.address);\nawait arbitraryUserDiamond.withdrawCollateral(arbitraryUser.address, this.collateral.address, withdrawAmount, cIndex);\nconst finalAccountValue = await hardhat_1.default.Diamond.getAccountCollateralValue(arbitraryUser.address);\nconst [finalValue] = await hardhat_1.default.Diamond.getAccountSingleCollateralValueAndRealValue(arbitraryUser.address, this.collateral.address);\n(0, chai_1.expect)(finalValue.rawValue).to.equal(expectedNrcValueAfter);\n(0, chai_1.expect)(finalAccountValue.rawValue).to.bignumber.equal(accountValueBefore.rawValue.sub(withdrawValue.rawValue));",
                          "err": {},
                          "uuid": "6d55a05d-5564-411d-ba86-a27cce0ae749",
                          "parentUUID": "a5bd76e2-1d5d-4ec2-99f3-cc40521b7cbe",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "d5cc3ba5-6f18-4b92-9c18-7ab59abbcb69",
                        "fe84ff5e-100a-4a5a-bbd5-a30603358130",
                        "27e77cd5-f270-4137-a548-e0b143465f57",
                        "76a27a03-c469-474d-93b4-903da05fd5f8",
                        "af815a90-23a2-4eb9-833d-e56adb92cbf0",
                        "ddf6cd5c-2189-48db-8e63-87df4276eb6e",
                        "6d55a05d-5564-411d-ba86-a27cce0ae749"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 1431,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "4c67c208-06d2-4db5-a513-49059c8353f4",
          "title": "Minter",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/03-liquidation.ts",
          "file": "/src/test/minter/03-liquidation.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "0cf0844f-b22a-4528-a890-c2fe7a654371",
              "parentUUID": "4c67c208-06d2-4db5-a513-49059c8353f4",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 24,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "18c55d40-3350-4799-b770-38a1426e5995",
              "parentUUID": "4c67c208-06d2-4db5-a513-49059c8353f4",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 160,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = hardhat_1.default.users;\n// -------------------------------- Set up mock assets --------------------------------\nconst collateralArgs = {\n    name: \"CollateralAsset\",\n    price: 10,\n    factor: 1,\n    decimals: 18,\n};\nthis.collateral = hardhat_1.default.collaterals.find(c => c.deployArgs.name === _test_utils_1.defaultCollateralArgs.name);\nthis.collateral = await this.collateral.update(collateralArgs);\nthis.collateral.setPrice(collateralArgs.price);\nawait this.collateral.update(collateralArgs);\n// Set up mock KreskoAsset\nconst krAssetArgs = {\n    name: \"KreskoAsset\",\n    price: 11,\n    factor: 1,\n    supplyLimit: 1000000,\n    closeFee: _test_utils_1.defaultCloseFee,\n    openFee: _test_utils_1.defaultOpenFee,\n};\nthis.krAsset = hardhat_1.default.krAssets.find(c => c.deployArgs.name === _test_utils_1.defaultKrAssetArgs.name);\nthis.krAsset.setPrice(krAssetArgs.price);\n// grant operator role to deployer for rebases\nawait this.krAsset.contract.grantRole(_test_utils_1.Role.OPERATOR, hardhat_1.default.users.deployer.address);\nconst assetInfo = await this.krAsset.kresko();\n// Add krAsset as a collateral with anchor and cFactor of 1\nawait hardhat_1.default.Diamond.connect(hardhat_1.default.users.operator).addCollateralAsset(this.krAsset.contract.address, this.krAsset.anchor.address, hardhat_1.default.toBig(1), assetInfo.oracle);\n// -------------------------------- Set up userOne deposit/debt --------------------------------\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [hardhat_1.default.users.liquidator.address]: hardhat_1.default.toBig(100000000),\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [hardhat_1.default.users.liquidator.address]: {\n        [hardhat_1.default.Diamond.address]: hardhat_1.default.toBig(100000000),\n    },\n});\n// Deposit collateral\nthis.defaultDepositAmount = 20; // 20 * $10 = $200 in collateral asset value\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [hardhat_1.default.users.userOne.address]: hardhat_1.default.toBig(this.defaultDepositAmount),\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [hardhat_1.default.users.userOne.address]: {\n        [hardhat_1.default.Diamond.address]: hardhat_1.default.toBig(this.defaultDepositAmount),\n    },\n});\nawait (0, collaterals_1.depositCollateral)({\n    user: hardhat_1.default.users.userOne,\n    amount: this.defaultDepositAmount,\n    asset: this.collateral,\n});\n// // Mint KrAsset\nthis.defaultMintAmount = 10; // 10 * $11 = $110 in debt value\nawait (0, krassets_1.mintKrAsset)({\n    user: hardhat_1.default.users.userOne,\n    amount: this.defaultMintAmount,\n    asset: this.krAsset,\n});",
              "err": {},
              "uuid": "89c4d56d-8b92-4ebb-966c-ea6ab5d94545",
              "parentUUID": "4c67c208-06d2-4db5-a513-49059c8353f4",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "2d36f8c0-27f3-452e-ac2d-87af4de7de02",
              "title": "#liquidation",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/03-liquidation.ts",
              "file": "/src/test/minter/03-liquidation.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "d14d7537-6037-4ec8-826c-1688d1340ad7",
                  "title": "#isAccountLiquidatable",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/03-liquidation.ts",
                  "file": "/src/test/minter/03-liquidation.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should identify accounts below their liquidation threshold",
                      "fullTitle": "Minter #liquidation #isAccountLiquidatable should identify accounts below their liquidation threshold",
                      "timedOut": false,
                      "duration": 67,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Confirm that current amount is under min collateral value\nconst liquidationThreshold = await hardhat_1.default.Diamond.liquidationThreshold();\nconst minCollateralUSD = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, liquidationThreshold);\n(0, chai_1.expect)(this.defaultDepositAmount * this.collateral.deployArgs.price >\n    hardhat_1.default.fromBig(minCollateralUSD.rawValue, 8));\n// The account should be NOT liquidatable as collateral value ($200) >= min collateral value ($154)\nconst initialCanLiquidate = await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address);\n(0, chai_1.expect)(initialCanLiquidate).to.equal(false);\n// Update collateral price to $7.5\nconst newCollateralPrice = 7.5;\nthis.collateral.setPrice(newCollateralPrice);\nconst [, newCollateralOraclePrice] = await hardhat_1.default.Diamond.getCollateralValueAndOraclePrice(this.collateral.address, hardhat_1.default.toBig(1), true);\n(0, chai_1.expect)(hardhat_1.default.fromBig(newCollateralOraclePrice.rawValue, 8)).to.equal(newCollateralPrice);\n// The account should be liquidatable as collateral value ($140) < min collateral value ($154)\nconst secondaryCanLiquidate = await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address);\n(0, chai_1.expect)(secondaryCanLiquidate).to.equal(true);",
                      "err": {},
                      "uuid": "d988ab65-ca4f-4a7a-b116-d34a4ba1a1df",
                      "parentUUID": "d14d7537-6037-4ec8-826c-1688d1340ad7",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "d988ab65-ca4f-4a7a-b116-d34a4ba1a1df"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 67,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                  "title": "#liquidate",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/03-liquidation.ts",
                  "file": "/src/test/minter/03-liquidation.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#liquidate\"",
                      "fullTitle": "Minter #liquidation #liquidate \"before each\" hook in \"#liquidate\"",
                      "timedOut": false,
                      "duration": 0,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Grant userTwo tokens to use for liquidation\nawait this.krAsset.mocks.contract.setVariable(\"_balances\", {\n    [hardhat_1.default.users.userTwo.address]: hardhat_1.default.toBig(10000),\n});\n// Update collateral price from $10 to $7.5\nconst newCollateralPrice = 7.5;\nthis.collateral.setPrice(newCollateralPrice);",
                      "err": {},
                      "uuid": "894795e6-7a31-4072-97ab-c1cf2e703bb8",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow unhealthy accounts to be liquidated",
                      "fullTitle": "Minter #liquidation #liquidate should allow unhealthy accounts to be liquidated",
                      "timedOut": false,
                      "duration": 207,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Confirm we can liquidate this account\nconst canLiquidate = await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address);\n(0, chai_1.expect)(canLiquidate).to.equal(true);\n// Fetch pre-liquidation state for users and contracts\nconst beforeUserOneCollateralAmount = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\nconst beforeUserOneDebtAmount = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\nconst beforeUserTwoCollateralBalance = await this.collateral.contract.balanceOf(users.userTwo.address);\nconst beforeUserTwoKreskoAssetBalance = await this.krAsset.contract.balanceOf(users.userTwo.address);\nconst beforeKreskoCollateralBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n// Liquidate userOne\nconst maxLiq = await hardhat_1.default.Diamond.calculateMaxLiquidatableValueForAssets(users.userOne.address, this.krAsset.address, this.collateral.address);\nconst maxRepayAmount = hardhat_1.default.toBig(Number(maxLiq.rawValue.div(await this.krAsset.getPrice())));\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nawait hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, maxRepayAmount, this.collateral.address, mintedKreskoAssetIndex, depositedCollateralAssetIndex);\n// Confirm that the liquidated user's debt amount has decreased by the repaid amount\nconst afterUserOneDebtAmount = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(afterUserOneDebtAmount.eq(beforeUserOneDebtAmount.sub(maxRepayAmount)));\n// Confirm that some of the liquidated user's collateral has been seized\nconst afterUserOneCollateralAmount = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n(0, chai_1.expect)(afterUserOneCollateralAmount.lt(beforeUserOneCollateralAmount));\n// Confirm that userTwo's kresko asset balance has decreased by the repaid amount\nconst afterUserTwoKreskoAssetBalance = await this.krAsset.contract.balanceOf(users.userTwo.address);\n(0, chai_1.expect)(afterUserTwoKreskoAssetBalance.eq(beforeUserTwoKreskoAssetBalance.sub(maxRepayAmount)));\n// Confirm that userTwo has received some collateral from the contract\nconst afterUserTwoCollateralBalance = await this.collateral.contract.balanceOf(users.userTwo.address);\n(0, chai_1.expect)(afterUserTwoCollateralBalance).gt(beforeUserTwoCollateralBalance);\n// Confirm that Kresko contract's collateral balance has decreased.\nconst afterKreskoCollateralBalance = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(afterKreskoCollateralBalance).lt(beforeKreskoCollateralBalance);",
                      "err": {},
                      "uuid": "e1d8fcb3-80c8-4782-86c9-cf7186d368df",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit LiquidationOccurred event",
                      "fullTitle": "Minter #liquidation #liquidate should emit LiquidationOccurred event",
                      "timedOut": false,
                      "duration": 94,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Attempt liquidation\nconst repayAmount = 10; // userTwo holds Kresko assets that can be used to repay userOne's loan\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nconst tx = await hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, mintedKreskoAssetIndex, depositedCollateralAssetIndex);\nconst event = await (0, lib_1.getInternalEvent)(tx, typechain_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userTwo), \"LiquidationOccurred\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.liquidator).to.equal(users.userTwo.address);\n(0, chai_1.expect)(event.repayKreskoAsset).to.equal(this.krAsset.address);\n(0, chai_1.expect)(event.repayAmount).to.equal(repayAmount);\n(0, chai_1.expect)(event.seizedCollateralAsset).to.equal(this.collateral.address);",
                      "err": {},
                      "uuid": "62598b6f-1d54-43d0-883f-95ed56590e94",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations of healthy accounts",
                      "fullTitle": "Minter #liquidation #liquidate should not allow liquidations of healthy accounts",
                      "timedOut": false,
                      "duration": 80,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Update collateral price from $5 to $10\nconst newCollateralPrice = 10;\nthis.collateral.setPrice(newCollateralPrice);\n// Confirm that the account has sufficient collateral to not be liquidated\nconst liquidationThreshold = await hardhat_1.default.Diamond.liquidationThreshold();\nconst minimumCollateralUSDValueRequired = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, liquidationThreshold);\nconst currUserOneCollateralAmount = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n(0, chai_1.expect)(hardhat_1.default.fromBig(currUserOneCollateralAmount) * newCollateralPrice >\n    hardhat_1.default.fromBig(minimumCollateralUSDValueRequired.rawValue, 8));\nconst canLiquidate = await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address);\n(0, chai_1.expect)(canLiquidate).to.equal(false);\nconst repayAmount = 10;\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, mintedKreskoAssetIndex, depositedCollateralAssetIndex)).to.be.revertedWith(errors_1.Error.NOT_LIQUIDATABLE);",
                      "err": {},
                      "uuid": "b1a09791-16f3-45c4-8500-dd7a31e22644",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations if repayment amount is 0",
                      "fullTitle": "Minter #liquidation #liquidate should not allow liquidations if repayment amount is 0",
                      "timedOut": false,
                      "duration": 9,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Liquidation should fail\nconst repayAmount = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, 0, 0)).to.be.revertedWith(errors_1.Error.ZERO_REPAY);",
                      "err": {},
                      "uuid": "f2780816-34d6-4a4b-9390-02517d464c81",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations with krAsset amount greater than krAsset debt of user",
                      "fullTitle": "Minter #liquidation #liquidate should not allow liquidations with krAsset amount greater than krAsset debt of user",
                      "timedOut": false,
                      "duration": 80,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Get user's debt for this kresko asset\nconst krAssetDebtUserOne = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n// Ensure we are repaying more than debt\nconst repayAmount = krAssetDebtUserOne.add(hardhat_1.default.toBig(1));\n// Liquidation should fail\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, 0, 0)).to.be.revertedWith(errors_1.Error.KRASSET_BURN_AMOUNT_OVERFLOW);",
                      "err": {},
                      "uuid": "9c77c81c-2637-4d97-aed4-a1ad4eec46ff",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations with USD value greater than the USD value required for regaining healthy position",
                      "fullTitle": "Minter #liquidation #liquidate should not allow liquidations with USD value greater than the USD value required for regaining healthy position",
                      "timedOut": false,
                      "duration": 102,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const maxLiquidation = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.calculateMaxLiquidatableValueForAssets(users.userOne.address, this.krAsset.address, this.collateral.address)).rawValue, 8);\nconst repaymentAmount = hardhat_1.default.toBig((maxLiquidation + 1) / this.krAsset.deployArgs.price);\n// Ensure liquidation cannot happen\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repaymentAmount, this.collateral.address, 0, 0)).to.be.revertedWith(errors_1.Error.LIQUIDATION_OVERFLOW);",
                      "err": {},
                      "uuid": "3a01d819-040e-4528-9f6e-497db190a47e",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidations when account is under MCR but not under liquidation threshold",
                      "fullTitle": "Minter #liquidation #liquidate should not allow liquidations when account is under MCR but not under liquidation threshold",
                      "timedOut": false,
                      "duration": 98,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "this.collateral.setPrice(this.collateral.deployArgs.price);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address)).to.be.false;\nconst minCollateralUSD = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, await hardhat_1.default.Diamond.minimumCollateralizationRatio());\nconst liquidationThresholdUSD = await hardhat_1.default.Diamond.getAccountMinimumCollateralValueAtRatio(users.userOne.address, await hardhat_1.default.Diamond.liquidationThreshold());\nthis.collateral.setPrice(this.collateral.deployArgs.price * 0.775);\nconst accountCollateralValue = await hardhat_1.default.Diamond.getAccountCollateralValue(users.userOne.address);\n(0, chai_1.expect)(accountCollateralValue.rawValue.lt(minCollateralUSD.rawValue)).to.be.true;\n(0, chai_1.expect)(accountCollateralValue.rawValue.gt(liquidationThresholdUSD.rawValue)).to.be.true;\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(users.userOne.address)).to.be.false;",
                      "err": {},
                      "uuid": "17bd1594-d1a4-4440-90e4-c97b20ccd069",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations without liquidator approval of Kresko assets to Kresko.sol contract",
                      "fullTitle": "Minter #liquidation #liquidate should allow liquidations without liquidator approval of Kresko assets to Kresko.sol contract",
                      "timedOut": false,
                      "duration": 103,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Check that liquidator's token approval to Kresko.sol contract is 0\n(0, chai_1.expect)(await this.krAsset.contract.allowance(users.userTwo.address, hardhat_1.default.Diamond.address)).to.equal(0);\n// Liquidation should succeed despite lack of token approval\nconst repayAmount = 10;\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nawait hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, mintedKreskoAssetIndex, depositedCollateralAssetIndex);\n// Confirm that liquidator's token approval is still 0\n(0, chai_1.expect)(await this.krAsset.contract.allowance(users.userTwo.address, hardhat_1.default.Diamond.address)).to.equal(0);",
                      "err": {},
                      "uuid": "e0c62660-80c8-4a0e-9000-f59d64c0e5b1",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not change liquidator's existing token approvals during a successful liquidation",
                      "fullTitle": "Minter #liquidation #liquidate should not change liquidator's existing token approvals during a successful liquidation",
                      "timedOut": false,
                      "duration": 122,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Liquidator increases contract's token approval\nconst repayAmount = 10;\nawait this.krAsset.contract.connect(users.userTwo).approve(hardhat_1.default.Diamond.address, repayAmount);\n(0, chai_1.expect)(await this.krAsset.contract.allowance(users.userTwo.address, hardhat_1.default.Diamond.address)).to.equal(repayAmount);\nconst mintedKreskoAssetIndex = 0;\nconst depositedCollateralAssetIndex = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userTwo).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, mintedKreskoAssetIndex, depositedCollateralAssetIndex)).not.to.be.reverted;\n// Confirm that liquidator's token approval is unchanged\n(0, chai_1.expect)(await this.krAsset.contract.allowance(users.userTwo.address, hardhat_1.default.Diamond.address)).to.equal(repayAmount);",
                      "err": {},
                      "uuid": "06713f86-22d0-47fe-8fb1-bfb359c6dfe8",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow borrowers to liquidate themselves",
                      "fullTitle": "Minter #liquidation #liquidate should not allow borrowers to liquidate themselves",
                      "timedOut": false,
                      "duration": 10,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Liquidation should fail\nconst repayAmount = 5;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).liquidate(users.userOne.address, this.krAsset.address, repayAmount, this.collateral.address, 0, 0)).to.be.revertedWith(errors_1.Error.SELF_LIQUIDATION);",
                      "err": {},
                      "uuid": "fde427f9-4ba7-442d-af0a-404ab469796c",
                      "parentUUID": "184be816-d8a4-4f48-9a0b-4df2617895e0",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "e1d8fcb3-80c8-4782-86c9-cf7186d368df",
                    "62598b6f-1d54-43d0-883f-95ed56590e94",
                    "b1a09791-16f3-45c4-8500-dd7a31e22644",
                    "f2780816-34d6-4a4b-9390-02517d464c81",
                    "9c77c81c-2637-4d97-aed4-a1ad4eec46ff",
                    "3a01d819-040e-4528-9f6e-497db190a47e",
                    "17bd1594-d1a4-4440-90e4-c97b20ccd069",
                    "e0c62660-80c8-4a0e-9000-f59d64c0e5b1",
                    "06713f86-22d0-47fe-8fb1-bfb359c6dfe8",
                    "fde427f9-4ba7-442d-af0a-404ab469796c"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 905,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                  "title": "#liquidate - rebasing events",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/03-liquidation.ts",
                  "file": "/src/test/minter/03-liquidation.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#liquidate - rebasing events\"",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events \"before each\" hook in \"#liquidate - rebasing events\"",
                      "timedOut": false,
                      "duration": 785,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "userToLiquidate = hardhat_1.default.users.userThree;\nuserToLiquidateTwo = hardhat_1.default.users.userFour;\nthis.collateral.setPrice(collateralPrice);\nthis.krAsset.setPrice(krAssetPrice);\n// Deposit collateral for liquidator\nawait (0, collaterals_1.depositCollateral)({\n    user: users.liquidator,\n    asset: this.collateral,\n    amount: liquidatorAmounts.collateralDeposits,\n});\nawait (0, _test_utils_1.leverageKrAsset)(userToLiquidate, this.krAsset, this.collateral, userToLiquidateAmounts.krAssetCollateralDeposits);\nawait (0, _test_utils_1.leverageKrAsset)(userToLiquidateTwo, this.krAsset, this.collateral, userToLiquidateAmounts.krAssetCollateralDeposits);\n// 1.5 = collateral value === debt value * MCR\n(0, chai_1.expect)(await (0, _test_utils_1.getHealthFactor)(userToLiquidate)).to.lessThanOrEqual(1.51);\n(0, chai_1.expect)(await (0, _test_utils_1.getHealthFactor)(userToLiquidateTwo)).to.lessThanOrEqual(1.51);\n// not liquidatable\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.false;\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidateTwo.address)).to.be.false;",
                      "err": {},
                      "uuid": "74989790-f36a-4182-954b-78aeedeff4f8",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should not allow liquidation of healthy accounts after a positive rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should not allow liquidation of healthy accounts after a positive rebase",
                      "timedOut": false,
                      "duration": 105,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasePrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) / denominator;\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.false;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(hardhat_1.default.users.liquidator).liquidate(userToLiquidate.address, this.krAsset.address, 1, this.collateral.address, await hardhat_1.default.Diamond.getMintedKreskoAssetsIndex(userToLiquidate.address, this.krAsset.address), await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(userToLiquidate.address, this.collateral.address))).to.be.revertedWith(errors_1.Error.NOT_LIQUIDATABLE);",
                      "err": {},
                      "uuid": "065c22e5-fdda-4a8d-98e2-a37d296e92c1",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow liquidation of healthy accounts after a negative rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should not allow liquidation of healthy accounts after a negative rebase",
                      "timedOut": false,
                      "duration": 94,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasePrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) * denominator;\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.false;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(hardhat_1.default.users.liquidator).liquidate(userToLiquidate.address, this.krAsset.address, 1, this.collateral.address, await hardhat_1.default.Diamond.getMintedKreskoAssetsIndex(userToLiquidate.address, this.krAsset.address), await hardhat_1.default.Diamond.getDepositedCollateralAssetIndex(userToLiquidate.address, this.collateral.address))).to.be.revertedWith(errors_1.Error.NOT_LIQUIDATABLE);",
                      "err": {},
                      "uuid": "2501fb8c-ecba-42ce-8a66-0ac4e262a570",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations of unhealthy accounts after a positive rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should allow liquidations of unhealthy accounts after a positive rebase",
                      "timedOut": false,
                      "duration": 393,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasePrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) / denominator;\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.false;\nthis.collateral.setPrice(rebasePrice * 2);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.true;\nawait (0, chai_1.expect)((0, liquidations_1.liquidate)(userToLiquidate, this.krAsset, this.collateral)).to.not.be.reverted;",
                      "err": {},
                      "uuid": "a82098e7-6331-40f7-b97a-8a9c71a12b9a",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow liquidations of unhealthy accounts after a negative rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should allow liquidations of unhealthy accounts after a negative rebase",
                      "timedOut": false,
                      "duration": 415,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasePrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) * denominator;\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.false;\nthis.krAsset.setPrice(rebasePrice * 2);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)).to.be.true;\nawait (0, chai_1.expect)((0, liquidations_1.liquidate)(userToLiquidate, this.krAsset, this.collateral)).to.not.be.reverted;",
                      "err": {},
                      "uuid": "a3f5b20b-9979-4295-8130-e50c42dd82da",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate correct amount of krAssets after a positive rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should liquidate correct amount of krAssets after a positive rebase",
                      "timedOut": false,
                      "duration": 4569,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Change price to make user position unhealthy\nconst startingPrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8);\nconst newPrice = startingPrice * 2;\nthis.krAsset.setPrice(newPrice);\nconst results = {\n    collateralSeized: 0,\n    debtRepaid: 0,\n    userOneValueAfter: 0,\n    userOneHFAfter: 0,\n    collateralSeizedRebase: 0,\n    debtRepaidRebase: 0,\n    userTwoValueAfter: 0,\n    userTwoHFAfter: 0,\n};\n// Get values for a liquidation that happens before rebase\nwhile (await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)) {\n    const values = await (0, liquidations_1.liquidate)(userToLiquidate, this.krAsset, this.krAsset);\n    results.collateralSeized += values.collateralSeized;\n    results.debtRepaid += values.debtRepaid;\n}\nresults.userOneValueAfter = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getAccountCollateralValue(userToLiquidate.address)).rawValue, 8);\nresults.userOneHFAfter = await (0, _test_utils_1.getHealthFactor)(userToLiquidate);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst rebasePrice = newPrice / denominator;\n// Rebase\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidateTwo.address)).to.be.true;\n// Get values for a liquidation that happens after a rebase\nwhile (await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidateTwo.address)) {\n    const values = await (0, liquidations_1.liquidate)(userToLiquidateTwo, this.krAsset, this.krAsset);\n    results.collateralSeizedRebase += values.collateralSeized;\n    results.debtRepaidRebase += values.debtRepaid;\n}\nresults.userTwoValueAfter = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getAccountCollateralValue(userToLiquidateTwo.address)).rawValue, 8);\nresults.userTwoHFAfter = await (0, _test_utils_1.getHealthFactor)(userToLiquidateTwo);\n(0, chai_1.expect)(results.userTwoHFAfter).to.closeTo(results.userOneHFAfter, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.collateralSeized * denominator).to.closeTo(results.collateralSeizedRebase, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.debtRepaid * denominator).to.closeTo(results.debtRepaidRebase, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.userOneValueAfter).to.closeTo(results.userTwoValueAfter, INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "1bddc7ee-9e73-4d4d-8a2b-46fdf773a706",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should liquidate correct amount of assets after a negative rebase",
                      "fullTitle": "Minter #liquidation #liquidate - rebasing events should liquidate correct amount of assets after a negative rebase",
                      "timedOut": false,
                      "duration": 4549,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Change price to make user position unhealthy\nconst startingPrice = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8);\nconst newPrice = startingPrice * 2;\nthis.krAsset.setPrice(newPrice);\nconst results = {\n    collateralSeized: 0,\n    debtRepaid: 0,\n    userOneValueAfter: 0,\n    userOneHFAfter: 0,\n    collateralSeizedRebase: 0,\n    debtRepaidRebase: 0,\n    userTwoValueAfter: 0,\n    userTwoHFAfter: 0,\n};\n// Get values for a liquidation that happens before rebase\nwhile (await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidate.address)) {\n    const values = await (0, liquidations_1.liquidate)(userToLiquidate, this.krAsset, this.krAsset);\n    results.collateralSeized += values.collateralSeized;\n    results.debtRepaid += values.debtRepaid;\n}\nresults.userOneValueAfter = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getAccountCollateralValue(userToLiquidate.address)).rawValue, 8);\nresults.userOneHFAfter = await (0, _test_utils_1.getHealthFactor)(userToLiquidate);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst rebasePrice = newPrice * denominator;\n// Rebase\nthis.krAsset.setPrice(rebasePrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidateTwo.address)).to.be.true;\n// Get values for a liquidation that happens after a rebase\nwhile (await hardhat_1.default.Diamond.isAccountLiquidatable(userToLiquidateTwo.address)) {\n    const values = await (0, liquidations_1.liquidate)(userToLiquidateTwo, this.krAsset, this.krAsset);\n    results.collateralSeizedRebase += values.collateralSeized;\n    results.debtRepaidRebase += values.debtRepaid;\n}\nresults.userTwoValueAfter = hardhat_1.default.fromBig((await hardhat_1.default.Diamond.getAccountCollateralValue(userToLiquidateTwo.address)).rawValue, 8);\nresults.userTwoHFAfter = await (0, _test_utils_1.getHealthFactor)(userToLiquidateTwo);\n(0, chai_1.expect)(results.userTwoHFAfter).to.closeTo(results.userOneHFAfter, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.collateralSeized / denominator).to.closeTo(results.collateralSeizedRebase, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.debtRepaid / denominator).to.closeTo(results.debtRepaidRebase, INTEREST_RATE_DELTA);\n(0, chai_1.expect)(results.userOneValueAfter).to.closeTo(results.userTwoValueAfter, INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "cffad486-070a-4cd5-b04e-3521985d524e",
                      "parentUUID": "8e6d1e5b-b9f8-4ecd-a491-1d4cbb136146",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "065c22e5-fdda-4a8d-98e2-a37d296e92c1",
                    "2501fb8c-ecba-42ce-8a66-0ac4e262a570",
                    "a82098e7-6331-40f7-b97a-8a9c71a12b9a",
                    "a3f5b20b-9979-4295-8130-e50c42dd82da",
                    "1bddc7ee-9e73-4d4d-8a2b-46fdf773a706",
                    "cffad486-070a-4cd5-b04e-3521985d524e"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 10125,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "b81058f4-871f-4bcc-a035-95325faef247",
          "title": "Minter",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
          "file": "/src/test/minter/04-mint-repay.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 4,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();",
              "err": {},
              "uuid": "6d25c6f1-0942-4322-8c6d-586b9e438c96",
              "parentUUID": "b81058f4-871f-4bcc-a035-95325faef247",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Minter\"",
              "fullTitle": "Minter \"before all\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "b307b717-99bd-4d9c-af31-57fed71bf2d0",
              "parentUUID": "b81058f4-871f-4bcc-a035-95325faef247",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 18,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "a97575b7-a351-4cad-aac9-6d056c1e7a6a",
              "parentUUID": "b81058f4-871f-4bcc-a035-95325faef247",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Minter\"",
              "fullTitle": "Minter \"before each\" hook in \"Minter\"",
              "timedOut": false,
              "duration": 49,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "this.collateral = this.collaterals.find(c => c.deployArgs.name === _test_utils_1.defaultCollateralArgs.name);\nthis.krAsset = this.krAssets.find(c => c.deployArgs.name === _test_utils_1.defaultKrAssetArgs.name);\nawait this.krAsset.contract.grantRole(_test_utils_1.Role.OPERATOR, users.deployer.address);\nthis.krAsset.setPrice(this.krAsset.deployArgs.price);\nthis.krAsset.setMarketOpen(this.krAsset.deployArgs.marketOpen);\n// Load account with collateral\nthis.initialBalance = (0, lib_1.toBig)(100000);\nawait this.collateral.setBalance(users.userOne, this.initialBalance);\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [users.userOne.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\nthis.collateral.setPrice(this.collateral.deployArgs.price);\n// User deposits 10,000 collateral\nawait (0, collaterals_1.depositCollateral)({ amount: 10000, user: users.userOne, asset: this.collateral });",
              "err": {},
              "uuid": "35557bb1-b2d0-4553-8b7e-1a0ccdbd5680",
              "parentUUID": "b81058f4-871f-4bcc-a035-95325faef247",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "d3648a59-479b-4cc3-94a7-4759f8304643",
              "title": "#mint+burn",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
              "file": "/src/test/minter/04-mint-repay.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                  "title": "#mint",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow users to mint whitelisted Kresko assets backed by collateral",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint whitelisted Kresko assets backed by collateral",
                      "timedOut": false,
                      "duration": 76,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially the Kresko asset's total supply should be 0\nconst kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyBefore).to.equal(0);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// Mint Kresko asset\nconst mintAmount = (0, lib_1.toBig)(1);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the amount minted is recorded for the user.\nconst amountMinted = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(amountMinted).to.equal(mintAmount);\n// Confirm the user's Kresko asset balance has increased\nconst userBalance = await this.krAsset.mocks.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalance).to.equal(mintAmount);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter.eq(kreskoAssetTotalSupplyBefore.add(mintAmount)));",
                      "err": {},
                      "uuid": "d461b748-f406-4ad5-8dc3-165e099f34d3",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow successive, valid mints of the same Kresko asset",
                      "fullTitle": "Minter #mint+burn #mint should allow successive, valid mints of the same Kresko asset",
                      "timedOut": false,
                      "duration": 164,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially the Kresko asset's total supply should be 0\nconst kreskoAssetTotalSupplyInitial = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyInitial).to.equal(0);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsInitial = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsInitial).to.deep.equal([]);\n// Mint Kresko asset\nconst firstMintAmount = (0, lib_1.toBig)(5);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, firstMintAmount);\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the amount minted is recorded for the user.\nconst amountMintedAfter = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(amountMintedAfter).to.equal(firstMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceAfter = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalanceAfter).to.equal(amountMintedAfter);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyInitial.add(firstMintAmount));\n// ------------------------ Second mint ------------------------\n// Mint Kresko asset\nconst secondMintAmount = (0, lib_1.toBig)(5);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, secondMintAmount);\n// Confirm the array of the user's minted Kresko assets is unchanged\nconst mintedKreskoAssetsFinal = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsFinal).to.deep.equal([this.krAsset.address]);\n// Confirm the second mint amount is recorded for the user\nconst amountMintedFinal = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(amountMintedFinal).to.closeTo(firstMintAmount.add(secondMintAmount), INTEREST_RATE_DELTA);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceFinal = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalanceFinal).to.closeTo(amountMintedFinal, INTEREST_RATE_DELTA);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyFinal = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyFinal).to.closeTo(kreskoAssetTotalSupplyAfter.add(secondMintAmount), INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "3df6b48f-403f-4ea0-ae7c-d2705a7b0b31",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to mint multiple different Kresko assets",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint multiple different Kresko assets",
                      "timedOut": false,
                      "duration": 2482,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially the Kresko asset's total supply should be 0\nconst kreskoAssetTotalSupplyInitial = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyInitial).to.equal(0);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsInitial = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsInitial).to.deep.equal([]);\n// Mint Kresko asset\nconst firstMintAmount = (0, lib_1.toBig)(1);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, firstMintAmount);\n// Confirm the array of the user's minted Kresko assets has been pushed to.\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the amount minted is recorded for the user.\nconst amountMintedAfter = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(amountMintedAfter).to.equal(firstMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceAfter = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalanceAfter).to.equal(amountMintedAfter);\n// Confirm that the Kresko asset's total supply increased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyInitial.add(firstMintAmount));\n// ------------------------ Second mint ------------------------\n// Add second mock krAsset to protocol\nconst secondKrAssetArgs = {\n    name: \"SecondKreskoAsset\",\n    symbol: \"SecondKreskoAsset\",\n    price: 5,\n    marketOpen: true,\n    factor: 1,\n    supplyLimit: 100000,\n    closeFee: _test_utils_1.defaultCloseFee,\n    openFee: 0,\n};\nconst { contract: secondKreskoAsset } = await (0, krassets_1.addMockKreskoAsset)(secondKrAssetArgs);\n// Mint Kresko asset\nconst secondMintAmount = (0, lib_1.toBig)(2);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, secondKreskoAsset.address, secondMintAmount);\n// Confirm that the second address has been pushed to the array of the user's minted Kresko assets\nconst mintedKreskoAssetsFinal = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsFinal).to.deep.equal([this.krAsset.address, secondKreskoAsset.address]);\n// Confirm the second mint amount is recorded for the user\nconst amountMintedAssetTwo = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, secondKreskoAsset.address);\n(0, chai_1.expect)(amountMintedAssetTwo).to.equal(secondMintAmount);\n// Confirm the Kresko Asset as been minted to the user from Kresko.sol\nconst userBalanceFinal = await secondKreskoAsset.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalanceFinal).to.equal(amountMintedAssetTwo);\n// Confirm that the Kresko asset's total supply increased as expected\nconst secondKreskoAssetTotalSupply = await secondKreskoAsset.totalSupply();\n(0, chai_1.expect)(secondKreskoAssetTotalSupply).to.equal(secondMintAmount);",
                      "err": {},
                      "uuid": "f5d8bd8f-8f37-4c1f-a6b6-c7949481f431",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to mint Kresko assets with USD value equal to the minimum debt value",
                      "fullTitle": "Minter #mint+burn #mint should allow users to mint Kresko assets with USD value equal to the minimum debt value",
                      "timedOut": false,
                      "duration": 84,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Confirm that the user does not have an existing debt position for this Kresko asset\nconst initialKreskoAssetDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(initialKreskoAssetDebt).to.equal(0);\n// Confirm that the mint amount's USD value is equal to the contract's current minimum debt value\nconst mintAmount = (0, lib_1.toBig)(1); // 1 * $10 = $10\nconst mintAmountUSDValue = await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, mintAmount, false);\nconst currMinimumDebtValue = await hardhat_1.default.Diamond.minimumDebtValue();\n(0, chai_1.expect)((0, lib_1.fromBig)(mintAmountUSDValue.rawValue, 8)).to.equal(Number(currMinimumDebtValue) / 10 ** 8);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Confirm that the mint was successful and user's balances have increased\nconst finalKreskoAssetDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(finalKreskoAssetDebt).to.equal(mintAmount);",
                      "err": {},
                      "uuid": "11a133a4-ae43-4a44-9e02-e383b0d2c2b9",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow a trusted address to mint Kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #mint should allow a trusted address to mint Kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 88,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Grant userThree the MANAGER role\nawait hardhat_1.default.Diamond.connect(users.deployer).grantRole(_test_utils_1.Role.MANAGER, users.userThree.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(_test_utils_1.Role.MANAGER, users.userThree.address)).to.equal(true);\n// Initially the Kresko asset's total supply should be 0\nconst kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyBefore).to.equal(0);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// userThree (trusted contract) mints Kresko asset for userOne\nconst mintAmount = (0, lib_1.toBig)(1);\nawait hardhat_1.default.Diamond.connect(users.userThree).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Check that debt exists now for userOne\nconst userOneDebtFromUserThreeMint = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(userOneDebtFromUserThreeMint).to.equal(mintAmount);",
                      "err": {},
                      "uuid": "ec6425a7-b639-4cf7-a0b1-490e51409943",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit KreskoAssetMinted event",
                      "fullTitle": "Minter #mint+burn #mint should emit KreskoAssetMinted event",
                      "timedOut": false,
                      "duration": 52,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const mintAmount = (0, lib_1.toBig)(500);\nconst tx = await hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"KreskoAssetMinted\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.kreskoAsset).to.equal(this.krAsset.address);\n(0, chai_1.expect)(event.amount).to.equal(mintAmount);",
                      "err": {},
                      "uuid": "b3299109-c9e1-4f87-8cf0-f2c654891835",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow untrusted account to mint Kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #mint should not allow untrusted account to mint Kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 52,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Initially the Kresko asset's total supply should be 0\nconst kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyBefore).to.equal(0);\n// Initially, the array of the user's minted kresko assets should be empty.\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// Mint Kresko asset\nconst mintAmount = (0, lib_1.toBig)(1);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userTwo.address, this.krAsset.address, mintAmount)).to.be.revertedWith(`AccessControl: account ${users.userOne.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                      "err": {},
                      "uuid": "7bd2710e-b2c0-4c11-aa40-1926b6d98ba2",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint Kresko assets if the resulting position's USD value is less than the minimum debt value",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint Kresko assets if the resulting position's USD value is less than the minimum debt value",
                      "timedOut": false,
                      "duration": 61,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Confirm that the user does not have an existing debt position for this Kresko asset\nconst initialKreskoAssetDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(initialKreskoAssetDebt).to.equal(0);\n// Confirm that the mint amount's USD value is below the contract's current minimum debt value\nconst minAmount = 100000000; // 8 decimals\nconst mintAmount = minAmount - 1;\nconst mintAmountUSDValue = await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, mintAmount, false);\nconst currMinimumDebtValue = await hardhat_1.default.Diamond.minimumDebtValue();\n(0, chai_1.expect)(Number(mintAmountUSDValue)).to.be.lessThan(Number(currMinimumDebtValue));\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount)).to.be.revertedWith(errors_1.Error.KRASSET_MINT_AMOUNT_LOW);",
                      "err": {},
                      "uuid": "279e099d-0925-46b8-be57-7e74ff34a5f8",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint non-whitelisted Kresko assets",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint non-whitelisted Kresko assets",
                      "timedOut": false,
                      "duration": 8,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Attempt to mint a non-deployed, non-whitelisted Kresko asset\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, \"0x0000000000000000000000000000000000000002\", (0, lib_1.toBig)(1))).to.be.revertedWith(errors_1.Error.KRASSET_DOESNT_EXIST);",
                      "err": {},
                      "uuid": "01e92dae-30d1-486c-9af1-0da99ec23d84",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to mint Kresko assets over their collateralization ratio limit",
                      "fullTitle": "Minter #mint+burn #mint should not allow users to mint Kresko assets over their collateralization ratio limit",
                      "timedOut": false,
                      "duration": 32,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// We can ignore price and collateral factor as both this.collateral and this.krAsset both\n// have the same price ($10) and same collateral factor (1)\nconst collateralAmountDeposited = await hardhat_1.default.Diamond.collateralDeposits(users.userOne.address, this.collateral.address);\n// Apply 150% MCR and increase deposit amount to be above the maximum allowed by MCR\nconst mcrAmount = (0, lib_1.fromBig)(collateralAmountDeposited) / 1.5;\nconst mintAmount = (0, lib_1.toBig)(mcrAmount + 1);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount)).to.be.revertedWith(errors_1.Error.KRASSET_COLLATERAL_LOW);",
                      "err": {},
                      "uuid": "770bae78-a879-4044-a1a0-9fa1a24316a4",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow the minting of any Kresko asset amount over its maximum limit",
                      "fullTitle": "Minter #mint+burn #mint should not allow the minting of any Kresko asset amount over its maximum limit",
                      "timedOut": false,
                      "duration": 34,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// User deposits another 10,000 collateral tokens, enabling mints of up to 20,000/1.5 = ~13,333 kresko asset tokens\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).depositCollateral(users.userOne.address, this.collateral.address, (0, lib_1.toBig)(10000))).not.to.be.reverted;\nconst krAsset = await hardhat_1.default.Diamond.kreskoAsset(this.krAsset.address);\nconst overSupplyLimit = (0, lib_1.fromBig)(krAsset.supplyLimit) + 1;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, (0, lib_1.toBig)(overSupplyLimit))).to.be.revertedWith(errors_1.Error.KRASSET_MAX_SUPPLY_REACHED);",
                      "err": {},
                      "uuid": "e3b9fbce-73a7-46eb-8495-f35a5825041c",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow the minting of kreskoAssets if the market is closed",
                      "fullTitle": "Minter #mint+burn #mint should not allow the minting of kreskoAssets if the market is closed",
                      "timedOut": false,
                      "duration": 69,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "this.krAsset.setMarketOpen(false);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, (0, lib_1.toBig)(1))).to.be.revertedWith(errors_1.Error.KRASSET_MARKET_CLOSED);\n// Confirm that the user has no minted krAssets\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore).to.deep.equal([]);\n// Confirm that opening the market makes krAsset mintable again\nthis.krAsset.setMarketOpen(true);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, (0, lib_1.toBig)(1));\n// Confirm the array of the user's minted Kresko assets has been pushed to\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);",
                      "err": {},
                      "uuid": "0809288f-3848-4b4d-a06e-35015fbb2fa9",
                      "parentUUID": "e1a74515-8f23-468f-82bf-06b04e9747f9",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "d461b748-f406-4ad5-8dc3-165e099f34d3",
                    "3df6b48f-403f-4ea0-ae7c-d2705a7b0b31",
                    "f5d8bd8f-8f37-4c1f-a6b6-c7949481f431",
                    "11a133a4-ae43-4a44-9e02-e383b0d2c2b9",
                    "ec6425a7-b639-4cf7-a0b1-490e51409943",
                    "b3299109-c9e1-4f87-8cf0-f2c654891835",
                    "7bd2710e-b2c0-4c11-aa40-1926b6d98ba2",
                    "279e099d-0925-46b8-be57-7e74ff34a5f8",
                    "01e92dae-30d1-486c-9af1-0da99ec23d84",
                    "770bae78-a879-4044-a1a0-9fa1a24316a4",
                    "e3b9fbce-73a7-46eb-8495-f35a5825041c",
                    "0809288f-3848-4b4d-a06e-35015fbb2fa9"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 3202,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "4541b178-dd75-47e9-aa92-0c1f9da6fca6",
                  "title": "#mint - rebase events",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "fb3626a3-f9fa-481f-b9f8-e5443e2d6bbb",
                      "title": "debt amounts are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when minted before positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt amounts are calculated correctly when minted before positive rebase",
                          "timedOut": false,
                          "duration": 89,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst balanceBefore = await this.krAsset.contract.balanceOf(users.userOne.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\n(0, chai_1.expect)(balanceAfter).to.bignumber.equal(mintAmount.mul(denominator));\n(0, chai_1.expect)(balanceBefore).to.not.bignumber.equal(balanceAfter);\n// Ensure that debt amount is also adjsuted by the rebase\nconst debtAmount = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterAdjusted).to.bignumber.equal(debtAmount);",
                          "err": {},
                          "uuid": "d593ae55-f38b-49c5-88f4-14effb2ee01e",
                          "parentUUID": "fb3626a3-f9fa-481f-b9f8-e5443e2d6bbb",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted before negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt amounts are calculated correctly when minted before negative rebase",
                          "timedOut": false,
                          "duration": 86,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst balanceBefore = await this.krAsset.contract.balanceOf(users.userOne.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\n(0, chai_1.expect)(balanceAfter).to.bignumber.equal(mintAmount.div(denominator));\n(0, chai_1.expect)(balanceBefore).to.not.bignumber.equal(balanceAfter);\n// Ensure that debt amount is also adjsuted by the rebase\nconst debtAmount = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterAdjusted).to.bignumber.equal(debtAmount);",
                          "err": {},
                          "uuid": "863b8efe-0024-44fd-84ee-2e7a207a6bd4",
                          "parentUUID": "fb3626a3-f9fa-481f-b9f8-e5443e2d6bbb",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt amounts are calculated correctly when minted after positive rebase",
                          "timedOut": false,
                          "duration": 89,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst balanceBefore = await this.krAsset.contract.balanceOf(users.userOne.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\n(0, chai_1.expect)(balanceAfter).to.bignumber.equal(mintAmount.mul(denominator));\n(0, chai_1.expect)(balanceBefore).to.not.bignumber.equal(balanceAfter);\n// Ensure that debt amount is also adjusted by the rebase\nconst debtAmount = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterAdjusted).to.bignumber.equal(debtAmount);",
                          "err": {},
                          "uuid": "8b48332b-245a-43b0-968c-98e813e6864e",
                          "parentUUID": "fb3626a3-f9fa-481f-b9f8-e5443e2d6bbb",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt amounts are calculated correctly when minted after negative rebase",
                          "timedOut": false,
                          "duration": 91,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst balanceBefore = await this.krAsset.contract.balanceOf(users.userOne.address);\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the minted balance is adjusted by the rebase\nconst [balanceAfter, balanceAfterAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\n(0, chai_1.expect)(balanceAfter).to.bignumber.equal(mintAmount.div(denominator));\n(0, chai_1.expect)(balanceBefore).to.not.bignumber.equal(balanceAfter);\n// Ensure that debt amount is also adjusted by the rebase\nconst debtAmount = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterAdjusted).to.bignumber.equal(debtAmount);",
                          "err": {},
                          "uuid": "38d00b4b-630d-4249-926d-396c0f346dae",
                          "parentUUID": "fb3626a3-f9fa-481f-b9f8-e5443e2d6bbb",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "d593ae55-f38b-49c5-88f4-14effb2ee01e",
                        "863b8efe-0024-44fd-84ee-2e7a207a6bd4",
                        "8b48332b-245a-43b0-968c-98e813e6864e",
                        "38d00b4b-630d-4249-926d-396c0f346dae"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 355,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "69fb581a-e801-41c3-9ad1-95cd86a7a15c",
                      "title": "debt values are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when mint is made before positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values are calculated correctly when mint is made before positive rebase",
                          "timedOut": false,
                          "duration": 107,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst valueBeforeRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n// Adjust price accordingly\nconst assetPrice = await this.krAsset.getPrice();\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPrice.div(denominator), 8));\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the value inside protocol matches the value before rebase\nconst valueAfterRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(valueAfterRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue, this.krAsset));",
                          "err": {},
                          "uuid": "5be8e4d5-2bf6-4993-bddf-cd4ac0729522",
                          "parentUUID": "69fb581a-e801-41c3-9ad1-95cd86a7a15c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when mint is made before negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values are calculated correctly when mint is made before negative rebase",
                          "timedOut": false,
                          "duration": 105,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\nconst valueBeforeRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n// Adjust price accordingly\nconst assetPrice = await this.krAsset.getPrice();\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPrice.mul(denominator), 8));\n// Rebase the asset according to params\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure that the value inside protocol matches the value before rebase\nconst valueAfterRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(valueAfterRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue, this.krAsset));",
                          "err": {},
                          "uuid": "66c098f9-5216-46fd-b2e4-c1d65a8fa654",
                          "parentUUID": "69fb581a-e801-41c3-9ad1-95cd86a7a15c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values are calculated correctly when minted after positive rebase",
                          "timedOut": false,
                          "duration": 99,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Equal value after rebase\nconst equalMintAmount = mintAmount.mul(denominator);\nconst assetPrice = await this.krAsset.getPrice();\n// Get value of the future mint before rebase\nconst valueBeforeRebase = await userOne.getKrAssetValue(this.krAsset.address, mintAmount, false);\n// Adjust price accordingly\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPrice, 8) / denominator);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, equalMintAmount);\n// Ensure that value after mint matches what is expected\nconst valueAfterRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(valueAfterRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue, this.krAsset));",
                          "err": {},
                          "uuid": "3a867485-dba0-4976-a863-a6dbe6eb7119",
                          "parentUUID": "69fb581a-e801-41c3-9ad1-95cd86a7a15c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted after negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values are calculated correctly when minted after negative rebase",
                          "timedOut": false,
                          "duration": 113,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Equal value after rebase\nconst equalMintAmount = mintAmount.div(denominator);\nconst assetPrice = await this.krAsset.getPrice();\n// Get value of the future mint before rebase\nconst valueBeforeRebase = await userOne.getKrAssetValue(this.krAsset.address, mintAmount, false);\n// Adjust price accordingly\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPrice.mul(denominator), 8));\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, equalMintAmount);\n// Ensure that value after mint matches what is expected\nconst valueAfterRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(valueAfterRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue, this.krAsset));",
                          "err": {},
                          "uuid": "8c7d4ab2-f463-4efa-86af-4e945524bfdb",
                          "parentUUID": "69fb581a-e801-41c3-9ad1-95cd86a7a15c",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "5be8e4d5-2bf6-4993-bddf-cd4ac0729522",
                        "66c098f9-5216-46fd-b2e4-c1d65a8fa654",
                        "3a867485-dba0-4976-a863-a6dbe6eb7119",
                        "8c7d4ab2-f463-4efa-86af-4e945524bfdb"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 424,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "94000c03-d380-4316-8c70-d23e9003526e",
                      "title": "debt values and amounts are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when minted before and after a positive rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values and amounts are calculated correctly when minted before and after a positive rebase",
                          "timedOut": false,
                          "duration": 272,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\nconst assetPrice = await this.krAsset.getPrice();\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst mintAmountAfterRebase = mintAmount.mul(denominator);\nconst assetPriceRebase = assetPrice.div(denominator);\n// Get value of the future mint\nconst valueBeforeRebase = await userOne.getKrAssetValue(this.krAsset.address, mintAmount, false);\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Get results\nconst balanceAfterFirstMint = await this.krAsset.contract.balanceOf(users.userOne.address);\nconst debtAmountAfterFirstMint = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\nconst debtValueAfterFirstMint = await userOne.getAccountKrAssetValue(users.userOne.address);\n// Assert\n(0, chai_1.expect)(balanceAfterFirstMint).to.bignumber.equal(debtAmountAfterFirstMint);\n(0, chai_1.expect)(valueBeforeRebase.rawValue).to.bignumber.equal(debtValueAfterFirstMint.rawValue);\n// Adjust price and rebase\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPriceRebase, 8));\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure debt amounts and balances match\nconst [balanceAfterFirstRebase, balanceAfterFirstRebaseAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\nconst debtAmountAfterFirstRebase = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterFirstRebase).to.bignumber.equal(mintAmountAfterRebase);\n(0, chai_1.expect)(balanceAfterFirstRebaseAdjusted).to.bignumber.equal(debtAmountAfterFirstRebase);\n// Ensure debt usd values match\nconst debtValueAfterFirstRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(await (0, calculations_1.fromScaledAmount)(debtValueAfterFirstRebase.rawValue, this.krAsset)).to.bignumber.equal(debtValueAfterFirstMint.rawValue);\n(0, chai_1.expect)(await (0, calculations_1.fromScaledAmount)(debtValueAfterFirstRebase.rawValue, this.krAsset)).to.bignumber.equal(valueBeforeRebase.rawValue);\n// Mint after rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmountAfterRebase);\n// Ensure debt amounts and balances match\nconst balanceAfterSecondMint = await this.krAsset.contract.balanceOf(users.userOne.address);\n// Ensure balance matches\nconst expectedBalanceAfterSecondMint = balanceAfterFirstRebase.add(mintAmountAfterRebase);\n(0, chai_1.expect)(balanceAfterSecondMint).to.bignumber.equal(expectedBalanceAfterSecondMint);\n// Ensure debt usd values match\nconst debtValueAfterSecondMint = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(await (0, calculations_1.fromScaledAmount)(debtValueAfterSecondMint.rawValue, this.krAsset)).to.bignumber.closeTo(debtValueAfterFirstMint.rawValue.mul(2), INTEREST_RATE_PRICE_DELTA);\n(0, chai_1.expect)(debtValueAfterSecondMint.rawValue).to.bignumber.closeTo(valueBeforeRebase.rawValue.mul(2), INTEREST_RATE_PRICE_DELTA);",
                          "err": {},
                          "uuid": "94a543e0-2bad-4b50-8359-097956cf2e1a",
                          "parentUUID": "94000c03-d380-4316-8c70-d23e9003526e",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when minted before and after a negative rebase",
                          "fullTitle": "Minter #mint+burn #mint - rebase events debt values and amounts are calculated correctly when minted before and after a negative rebase",
                          "timedOut": false,
                          "duration": 254,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\nconst assetPrice = await this.krAsset.getPrice();\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst mintAmountAfterRebase = mintAmount.div(denominator);\nconst assetPriceRebase = assetPrice.mul(denominator);\n// Get value of the future mint\nconst valueBeforeRebase = await userOne.getKrAssetValue(this.krAsset.address, mintAmount, false);\n// Mint before rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Get results\nconst balanceAfterFirstMint = await this.krAsset.contract.balanceOf(users.userOne.address);\nconst debtAmountAfterFirstMint = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\nconst debtValueAfterFirstMint = await userOne.getAccountKrAssetValue(users.userOne.address);\n// Assert\n(0, chai_1.expect)(balanceAfterFirstMint).to.bignumber.equal(debtAmountAfterFirstMint);\n(0, chai_1.expect)(valueBeforeRebase.rawValue).to.bignumber.equal(debtValueAfterFirstMint.rawValue);\n// Adjust price and rebase\nthis.krAsset.setPrice(hardhat_1.default.fromBig(assetPriceRebase, 8));\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Ensure debt amounts and balances match\nconst [balanceAfterFirstRebase, balanceAfterFirstRebaseAdjusted] = await (0, krassets_1.getDebtIndexAdjustedBalance)(users.userOne, this.krAsset);\nconst debtAmountAfterFirstRebase = await userOne.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(balanceAfterFirstRebase).to.bignumber.equal(mintAmountAfterRebase);\n(0, chai_1.expect)(balanceAfterFirstRebaseAdjusted).to.bignumber.equal(debtAmountAfterFirstRebase);\n// Ensure debt usd values match\nconst debtValueAfterFirstRebase = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(debtValueAfterFirstRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(debtValueAfterFirstMint.rawValue, this.krAsset));\n(0, chai_1.expect)(debtValueAfterFirstRebase.rawValue).to.bignumber.equal(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue, this.krAsset));\n// Mint after rebase\nawait userOne.mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmountAfterRebase);\n// Ensure debt usd values match\nconst debtValueAfterSecondMint = await userOne.getAccountKrAssetValue(users.userOne.address);\n(0, chai_1.expect)(debtValueAfterSecondMint.rawValue).to.bignumber.closeTo(await (0, calculations_1.toScaledAmount)(debtValueAfterFirstMint.rawValue.mul(2), this.krAsset), INTEREST_RATE_PRICE_DELTA);\n(0, chai_1.expect)(debtValueAfterSecondMint.rawValue).to.bignumber.closeTo(await (0, calculations_1.toScaledAmount)(valueBeforeRebase.rawValue.mul(2), this.krAsset), INTEREST_RATE_PRICE_DELTA);",
                          "err": {},
                          "uuid": "c1c06b29-4c7f-423a-a9b0-5597c0e5ab74",
                          "parentUUID": "94000c03-d380-4316-8c70-d23e9003526e",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "94a543e0-2bad-4b50-8359-097956cf2e1a",
                        "c1c06b29-4c7f-423a-a9b0-5597c0e5ab74"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 526,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                  "title": "#burn",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#burn\"",
                      "fullTitle": "Minter #mint+burn #burn \"before each\" hook in \"#burn\"",
                      "timedOut": false,
                      "duration": 124,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Create userOne debt position\nthis.mintAmount = (0, lib_1.toBig)(2);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, this.mintAmount);\n// Load userThree with Kresko Assets\nawait this.collateral.mocks.contract.setVariable(\"_balances\", {\n    [users.userThree.address]: this.initialBalance,\n});\nawait this.collateral.mocks.contract.setVariable(\"_allowances\", {\n    [users.userThree.address]: {\n        [hardhat_1.default.Diamond.address]: this.initialBalance,\n    },\n});\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(users.userThree.address)).to.equal(this.initialBalance);\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).depositCollateral(users.userThree.address, this.collateral.address, (0, lib_1.toBig)(10000))).not.to.be.reverted;\nawait hardhat_1.default.Diamond.connect(users.userThree).mintKreskoAsset(users.userThree.address, this.krAsset.address, this.mintAmount);",
                      "err": {},
                      "uuid": "e635e957-7368-4beb-94e1-2f00b7089494",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should allow users to burn some of their Kresko asset balances",
                      "fullTitle": "Minter #mint+burn #burn should allow users to burn some of their Kresko asset balances",
                      "timedOut": false,
                      "duration": 78,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n// Burn Kresko asset\nconst burnAmount = (0, lib_1.toBig)(1);\nconst kreskoAssetIndex = 0;\nawait hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex);\n// Confirm the user no long holds the burned Kresko asset amount\nconst userBalance = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userBalance).to.equal(this.mintAmount.sub(burnAmount));\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyBefore.sub(burnAmount));\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the user's minted kresko asset amount has been updated\nconst userDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(userDebt).to.closeTo(this.mintAmount.sub(burnAmount), INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "8d055351-bc1d-46ee-b27e-0e2ef769b750",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to burn their full balance of a Kresko asset",
                      "fullTitle": "Minter #mint+burn #burn should allow users to burn their full balance of a Kresko asset",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "835a5a55-3c46-4077-9d9b-c122bd456a9e",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow trusted address to burn its own Kresko asset balances on behalf of another user",
                      "fullTitle": "Minter #mint+burn #burn should allow trusted address to burn its own Kresko asset balances on behalf of another user",
                      "timedOut": false,
                      "duration": 97,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "// Grant userThree the MANAGER role\nawait hardhat_1.default.Diamond.connect(users.deployer).grantRole(_test_utils_1.Role.MANAGER, users.userThree.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.hasRole(_test_utils_1.Role.MANAGER, users.userThree.address)).to.equal(true);\nconst kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n// Burn Kresko asset\nconst burnAmount = (0, lib_1.toBig)(1);\nconst kreskoAssetIndex = 0;\n// User three burns it's KreskoAsset to reduce userOnes debt\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex)).to.not.be.reverted;\n// Confirm the userOne had no effect on it's kreskoAsset balance\nconst userOneBalance = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(userOneBalance).to.equal(this.mintAmount);\n// Confirm the userThree no long holds the burned Kresko asset amount\nconst userThreeBalance = await this.krAsset.contract.balanceOf(users.userThree.address);\n(0, chai_1.expect)(userThreeBalance).to.equal(this.mintAmount.sub(burnAmount));\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter).to.equal(kreskoAssetTotalSupplyBefore.sub(burnAmount));\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the user's minted kresko asset amount has been updated\nconst userOneDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(userOneDebt).to.closeTo(this.mintAmount.sub(burnAmount), INTEREST_RATE_DELTA);",
                      "err": {},
                      "uuid": "22fbfa24-0a2b-49af-9c43-e6f06efebdf6",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow trusted address to burn the full balance of its Kresko asset on behalf another user",
                      "fullTitle": "Minter #mint+burn #burn should allow trusted address to burn the full balance of its Kresko asset on behalf another user",
                      "timedOut": false,
                      "duration": 0,
                      "state": "pending",
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": true,
                      "context": null,
                      "code": "",
                      "err": {},
                      "uuid": "ecf17c70-3c78-4c40-9162-779361f6a855",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should burn up to the minimum debt position amount if the requested burn would result in a position under the minimum debt value",
                      "fullTitle": "Minter #mint+burn #burn should burn up to the minimum debt position amount if the requested burn would result in a position under the minimum debt value",
                      "timedOut": false,
                      "duration": 100,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const userBalanceBefore = await this.krAsset.contract.balanceOf(users.userOne.address);\nconst kreskoAssetTotalSupplyBefore = await this.krAsset.contract.totalSupply();\n// Calculate actual burn amount\nconst userOneDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst minDebtValue = (0, lib_1.fromBig)((await hardhat_1.default.Diamond.minimumDebtValue()).rawValue, 8);\nconst oraclePrice = this.krAsset.deployArgs.price;\nconst burnAmount = hardhat_1.default.toBig((0, lib_1.fromBig)(userOneDebt) - minDebtValue / oraclePrice);\n// Burn Kresko asset\nconst kreskoAssetIndex = 0;\nawait hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex);\n// Confirm the user holds the expected Kresko asset amount\nconst userBalance = await this.krAsset.contract.balanceOf(users.userOne.address);\n// expect(fromBig(userBalance)).to.equal(fromBig(userBalanceBefore.sub(burnAmount)));\n(0, chai_1.expect)(userBalance).eq(userBalanceBefore.sub(burnAmount));\n// Confirm that the Kresko asset's total supply decreased as expected\nconst kreskoAssetTotalSupplyAfter = await this.krAsset.contract.totalSupply();\n(0, chai_1.expect)(kreskoAssetTotalSupplyAfter).eq(kreskoAssetTotalSupplyBefore.sub(burnAmount));\n// Confirm the array of the user's minted Kresko assets still contains the asset's address\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter).to.deep.equal([this.krAsset.address]);\n// Confirm the user's minted kresko asset amount has been updated\nconst newUserDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(newUserDebt).to.be.equal(userOneDebt.sub(burnAmount));",
                      "err": {},
                      "uuid": "95e428e8-dfa6-43c7-a12a-edd35358777a",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should emit KreskoAssetBurned event",
                      "fullTitle": "Minter #mint+burn #burn should emit KreskoAssetBurned event",
                      "timedOut": false,
                      "duration": 63,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nconst tx = await hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, this.mintAmount.div(5), kreskoAssetIndex);\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"KreskoAssetBurned\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.kreskoAsset).to.equal(this.krAsset.address);\n(0, chai_1.expect)(event.amount).to.equal(this.mintAmount.div(5));",
                      "err": {},
                      "uuid": "e9ddff3a-c02c-42bd-8de2-5afe0281fdf8",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow users to burn Kresko assets without giving token approval to Kresko.sol contract",
                      "fullTitle": "Minter #mint+burn #burn should allow users to burn Kresko assets without giving token approval to Kresko.sol contract",
                      "timedOut": false,
                      "duration": 120,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const secondMintAmount = 1;\nconst burnAmount = this.mintAmount.add(secondMintAmount);\nawait hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, secondMintAmount);\nconst kreskoAssetIndex = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex)).to.be.not.reverted;",
                      "err": {},
                      "uuid": "4471904f-9bf9-409f-8b13-026c498c5176",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to burn an amount of 0",
                      "fullTitle": "Minter #mint+burn #burn should not allow users to burn an amount of 0",
                      "timedOut": false,
                      "duration": 9,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, 0, kreskoAssetIndex)).to.be.revertedWith(errors_1.Error.ZERO_BURN);",
                      "err": {},
                      "uuid": "e36073b6-b53c-499d-a3af-5dd06c23e26b",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow untrusted address to burn any kresko assets on behalf of another user",
                      "fullTitle": "Minter #mint+burn #burn should not allow untrusted address to burn any kresko assets on behalf of another user",
                      "timedOut": false,
                      "duration": 30,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userThree).burnKreskoAsset(users.userOne.address, this.krAsset.address, 100, kreskoAssetIndex)).to.be.revertedWith(`AccessControl: account ${users.userThree.address.toLowerCase()} is missing role 0x46925e0f0cc76e485772167edccb8dc449d43b23b55fc4e756b063f49099e6a0`);",
                      "err": {},
                      "uuid": "fd133e5d-737a-4fd5-92c0-1a351c1ea3f1",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow users to burn more kresko assets than they hold as debt",
                      "fullTitle": "Minter #mint+burn #burn should not allow users to burn more kresko assets than they hold as debt",
                      "timedOut": false,
                      "duration": 22,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const kreskoAssetIndex = 0;\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(users.userOne.address, this.krAsset.address);\nconst burnAmount = debt.add(hardhat_1.default.toBig(1));\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex)).to.be.reverted;",
                      "err": {},
                      "uuid": "e2229862-9d11-4f01-95c7-0410736f81ec",
                      "parentUUID": "4d6140ae-c325-4beb-b9b1-7737b47c40f0",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [
                    {
                      "uuid": "e6e4b130-d65a-4a63-9503-e9f52d7deb59",
                      "title": "Protocol open fee",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should charge the protocol open fee with a single collateral asset if the deposit amount is sufficient and emit CloseFeePaid event",
                          "fullTitle": "Minter #mint+burn #burn Protocol open fee should charge the protocol open fee with a single collateral asset if the deposit amount is sufficient and emit CloseFeePaid event",
                          "timedOut": false,
                          "duration": 148,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const openFee = 0.01;\nconst openFeeBig = (0, lib_1.toBig)(openFee); // use toBig() to emulate closeFee's 18 decimals on contract\nthis.krAsset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === _test_utils_1.defaultKrAssetArgs.symbol);\nawait this.krAsset.update({\n    ..._test_utils_1.defaultKrAssetArgs,\n    openFee,\n});\nconst mintAmount = (0, lib_1.toBig)(1);\nconst mintValue = mintAmount.mul(this.krAsset.deployArgs.price);\nconst expectedFeeValue = mintValue.mul(openFeeBig);\nconst expectedCollateralFeeAmount = expectedFeeValue.div(this.collateral.deployArgs.price);\n// Get the balances prior to the fee being charged.\nconst kreskoCollateralAssetBalanceBefore = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\nconst feeRecipientCollateralBalanceBefore = await this.collateral.contract.balanceOf(await hardhat_1.default.Diamond.feeRecipient());\n// Mint Kresko asset\nconst tx = await hardhat_1.default.Diamond.connect(users.userOne).mintKreskoAsset(users.userOne.address, this.krAsset.address, mintAmount);\n// Get the balances after the fees have been charged.\nconst kreskoCollateralAssetBalanceAfter = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\nconst feeRecipientCollateralBalanceAfter = await this.collateral.contract.balanceOf(await hardhat_1.default.Diamond.feeRecipient());\n// Ensure the amount gained / lost by the kresko contract and the fee recipient are as expected\nconst feeRecipientBalanceIncrease = feeRecipientCollateralBalanceAfter.sub(feeRecipientCollateralBalanceBefore);\n(0, chai_1.expect)(kreskoCollateralAssetBalanceBefore.sub(kreskoCollateralAssetBalanceAfter)).to.equal(feeRecipientBalanceIncrease);\n// Normalize expected amount because protocol closeFee has 10**18 decimals\nconst normalizedExpectedCollateralFeeAmount = (0, lib_1.fromBig)(expectedCollateralFeeAmount) / 10 ** 18;\n(0, chai_1.expect)(feeRecipientBalanceIncrease).to.equal((0, lib_1.toBig)(normalizedExpectedCollateralFeeAmount));\n// Ensure the emitted event is as expected.\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"OpenFeePaid\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.paymentCollateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)(event.paymentAmount).to.equal((0, lib_1.toBig)(normalizedExpectedCollateralFeeAmount));\nconst expectedFeeValueNormalizedA = expectedFeeValue.div(10 ** 10); // Normalize krAsset price's 10**10 decimals on contract\nconst expectedFeeValueNormalizedB = (0, lib_1.fromBig)(expectedFeeValueNormalizedA); // Normalize closeFee's 10**18 decimals on contract\n(0, chai_1.expect)(event.paymentValue).to.equal(expectedFeeValueNormalizedB);\n// Now verify that calcExpectedFee function returns accurate fee amount\nconst feeRes = await hardhat_1.default.Diamond.calcExpectedFee(users.userOne.address, this.krAsset.address, mintAmount, _test_utils_1.Fee.OPEN);\nconst output = feeRes.toString().split(\",\");\nconst openFeeAmount = Number(output[1]) / 10 ** 18;\n(0, chai_1.expect)(openFeeAmount).eq(normalizedExpectedCollateralFeeAmount);",
                          "err": {},
                          "uuid": "e91e82e2-c2b4-4d0a-bc15-f39e5799af42",
                          "parentUUID": "e6e4b130-d65a-4a63-9503-e9f52d7deb59",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "e91e82e2-c2b4-4d0a-bc15-f39e5799af42"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 148,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "6def4001-0112-4ca7-8e7c-d751c9ccbfe7",
                      "title": "Protocol close fee",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "should charge the protocol close fee with a single collateral asset if the deposit amount is sufficient and emit CloseFeePaid event",
                          "fullTitle": "Minter #mint+burn #burn Protocol close fee should charge the protocol close fee with a single collateral asset if the deposit amount is sufficient and emit CloseFeePaid event",
                          "timedOut": false,
                          "duration": 83,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const burnAmount = (0, lib_1.toBig)(1);\nconst burnValue = burnAmount.mul(this.krAsset.deployArgs.price);\nconst closeFee = (0, lib_1.toBig)(this.krAsset.deployArgs.closeFee); // use toBig() to emulate closeFee's 18 decimals on contract\nconst expectedFeeValue = burnValue.mul(closeFee);\nconst expectedCollateralFeeAmount = expectedFeeValue.div(this.collateral.deployArgs.price);\n// Get the balances prior to the fee being charged.\nconst kreskoCollateralAssetBalanceBefore = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\nconst feeRecipientCollateralBalanceBefore = await this.collateral.contract.balanceOf(await hardhat_1.default.Diamond.feeRecipient());\n// Burn Kresko asset\nconst kreskoAssetIndex = 0;\nconst tx = await hardhat_1.default.Diamond.connect(users.userOne).burnKreskoAsset(users.userOne.address, this.krAsset.address, burnAmount, kreskoAssetIndex);\n// Get the balances after the fees have been charged.\nconst kreskoCollateralAssetBalanceAfter = await this.collateral.contract.balanceOf(hardhat_1.default.Diamond.address);\nconst feeRecipientCollateralBalanceAfter = await this.collateral.contract.balanceOf(await hardhat_1.default.Diamond.feeRecipient());\n// Ensure the amount gained / lost by the kresko contract and the fee recipient are as expected\nconst feeRecipientBalanceIncrease = feeRecipientCollateralBalanceAfter.sub(feeRecipientCollateralBalanceBefore);\n(0, chai_1.expect)(kreskoCollateralAssetBalanceBefore.sub(kreskoCollateralAssetBalanceAfter)).to.equal(feeRecipientBalanceIncrease);\n// Normalize expected amount because protocol closeFee has 10**18 decimals\nconst normalizedExpectedCollateralFeeAmount = (0, lib_1.fromBig)(expectedCollateralFeeAmount) / 10 ** 18;\n(0, chai_1.expect)(feeRecipientBalanceIncrease).to.equal((0, lib_1.toBig)(normalizedExpectedCollateralFeeAmount));\n// Ensure the emitted event is as expected.\nconst event = await (0, lib_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"CloseFeePaid\");\n(0, chai_1.expect)(event.account).to.equal(users.userOne.address);\n(0, chai_1.expect)(event.paymentCollateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)(event.paymentAmount).to.equal((0, lib_1.toBig)(normalizedExpectedCollateralFeeAmount));\nconst expectedFeeValueNormalizedA = expectedFeeValue.div(10 ** 10); // Normalize krAsset price's 10**10 decimals on contract\nconst expectedFeeValueNormalizedB = (0, lib_1.fromBig)(expectedFeeValueNormalizedA); // Normalize closeFee's 10**18 decimals on contract\n(0, chai_1.expect)(event.paymentValue).to.equal(expectedFeeValueNormalizedB);",
                          "err": {},
                          "uuid": "fcf6a4bd-b245-41f0-9ebc-0afd7fab5e00",
                          "parentUUID": "6def4001-0112-4ca7-8e7c-d751c9ccbfe7",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should charge correct protocol close fee after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn Protocol close fee should charge correct protocol close fee after a positive rebase",
                          "timedOut": false,
                          "duration": 348,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const mintAmount = 10;\nconst wAmount = 1;\nconst burnAmount = 1;\nconst expectedFeeAmount = hardhat_1.default.toBig(burnAmount * this.krAsset.deployArgs.closeFee);\nconst expectedFeeValue = hardhat_1.default.toBig(burnAmount * this.krAsset.deployArgs.price * this.krAsset.deployArgs.closeFee, 8);\nawait (0, krassets_1.mintKrAsset)({ user: users.userThree, asset: this.krAsset, amount: hardhat_1.default.toBig(mintAmount) });\nawait (0, collaterals_1.withdrawCollateral)({ user: users.userThree, asset: this.collateral, amount: wAmount });\nconst event = await (0, lib_1.getInternalEvent)(await (0, krassets_1.burnKrAsset)({ user: users.userThree, asset: this.krAsset, amount: burnAmount }), types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userThree), \"CloseFeePaid\");\n(0, chai_1.expect)(event.paymentAmount).to.equal(expectedFeeAmount);\n(0, chai_1.expect)(event.paymentValue).to.equal(expectedFeeValue);\n// rebase params\nconst denominator = 4;\nconst positive = true;\nconst priceAfter = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) / denominator;\nthis.krAsset.setPrice(priceAfter);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst burnAmountRebase = burnAmount * denominator;\nawait (0, collaterals_1.withdrawCollateral)({ user: users.userThree, asset: this.collateral, amount: wAmount });\nconst eventAfterRebase = await (0, lib_1.getInternalEvent)(await (0, krassets_1.burnKrAsset)({ user: users.userThree, asset: this.krAsset, amount: burnAmountRebase }), types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"CloseFeePaid\");\n(0, chai_1.expect)(eventAfterRebase.paymentCollateralAsset).to.equal(event.paymentCollateralAsset);\n(0, chai_1.expect)(eventAfterRebase.paymentAmount).to.equal(expectedFeeAmount);\n(0, chai_1.expect)(eventAfterRebase.paymentValue).to.equal(expectedFeeValue);",
                          "err": {},
                          "uuid": "7f81adea-105c-4dfb-95dd-25324d16573b",
                          "parentUUID": "6def4001-0112-4ca7-8e7c-d751c9ccbfe7",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "should charge correct protocol close fee after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn Protocol close fee should charge correct protocol close fee after a negative rebase",
                          "timedOut": false,
                          "duration": 346,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const mintAmount = 10;\nconst wAmount = 1;\nconst burnAmount = 1;\nconst expectedFeeAmount = hardhat_1.default.toBig(burnAmount * this.krAsset.deployArgs.closeFee);\nconst expectedFeeValue = hardhat_1.default.toBig(burnAmount * this.krAsset.deployArgs.price * this.krAsset.deployArgs.closeFee, 8);\nawait (0, krassets_1.mintKrAsset)({ user: users.userThree, asset: this.krAsset, amount: hardhat_1.default.toBig(mintAmount) });\nawait (0, collaterals_1.withdrawCollateral)({ user: users.userThree, asset: this.collateral, amount: wAmount });\nconst event = await (0, lib_1.getInternalEvent)(await (0, krassets_1.burnKrAsset)({ user: users.userThree, asset: this.krAsset, amount: burnAmount }), types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userThree), \"CloseFeePaid\");\n(0, chai_1.expect)(event.paymentAmount).to.equal(expectedFeeAmount);\n(0, chai_1.expect)(event.paymentValue).to.equal(expectedFeeValue);\n// rebase params\nconst denominator = 4;\nconst positive = false;\nconst priceAfter = hardhat_1.default.fromBig(await this.krAsset.getPrice(), 8) * denominator;\nthis.krAsset.setPrice(priceAfter);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nconst burnAmountRebase = burnAmount / denominator;\nawait (0, collaterals_1.withdrawCollateral)({ user: users.userThree, asset: this.collateral, amount: wAmount });\nconst eventAfterRebase = await (0, lib_1.getInternalEvent)(await (0, krassets_1.burnKrAsset)({ user: users.userThree, asset: this.krAsset, amount: burnAmountRebase }), types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"CloseFeePaid\");\n(0, chai_1.expect)(eventAfterRebase.paymentCollateralAsset).to.equal(event.paymentCollateralAsset);\n(0, chai_1.expect)(eventAfterRebase.paymentAmount).to.equal(expectedFeeAmount);\n(0, chai_1.expect)(eventAfterRebase.paymentValue).to.equal(expectedFeeValue);",
                          "err": {},
                          "uuid": "f2ed0c4c-fecb-444d-86c1-9c665cd6b25f",
                          "parentUUID": "6def4001-0112-4ca7-8e7c-d751c9ccbfe7",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "fcf6a4bd-b245-41f0-9ebc-0afd7fab5e00",
                        "7f81adea-105c-4dfb-95dd-25324d16573b",
                        "f2ed0c4c-fecb-444d-86c1-9c665cd6b25f"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 777,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [
                    "8d055351-bc1d-46ee-b27e-0e2ef769b750",
                    "22fbfa24-0a2b-49af-9c43-e6f06efebdf6",
                    "95e428e8-dfa6-43c7-a12a-edd35358777a",
                    "e9ddff3a-c02c-42bd-8de2-5afe0281fdf8",
                    "4471904f-9bf9-409f-8b13-026c498c5176",
                    "e36073b6-b53c-499d-a3af-5dd06c23e26b",
                    "fd133e5d-737a-4fd5-92c0-1a351c1ea3f1",
                    "e2229862-9d11-4f01-95c7-0410736f81ec"
                  ],
                  "failures": [],
                  "pending": [
                    "835a5a55-3c46-4077-9d9b-c122bd456a9e",
                    "ecf17c70-3c78-4c40-9162-779361f6a855"
                  ],
                  "skipped": [],
                  "duration": 519,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "a0f4cab7-c418-4745-b4a3-f7431354018f",
                  "title": "#burn - rebase events",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                  "file": "/src/test/minter/04-mint-repay.ts",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"#burn - rebase events\"",
                      "fullTitle": "Minter #mint+burn #burn - rebase events \"before each\" hook in \"#burn - rebase events\"",
                      "timedOut": false,
                      "duration": 59,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, krassets_1.mintKrAsset)({ asset: this.krAsset, amount: mintAmountInt, user: users.userOne });",
                      "err": {},
                      "uuid": "b7e5e56b-f820-4a46-9873-9792c1d09308",
                      "parentUUID": "a0f4cab7-c418-4745-b4a3-f7431354018f",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [],
                  "suites": [
                    {
                      "uuid": "927569ba-5706-4878-a3a7-770a2938b25c",
                      "title": "debt amounts are calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when repaying all debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt amounts are calculated correctly when repaying all debt after a positive rebase",
                          "timedOut": false,
                          "duration": 548,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.div(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst repayAmount = debt;\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, repayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfter).to.bignumber.equal(0);\nconst expectedBalanceAfterBurn = 0;\nconst balanceAfterBurn = hardhat_1.default.fromBig(await this.krAsset.contract.balanceOf(users.userOne.address));\n(0, chai_1.expect)(balanceAfterBurn).to.equal(expectedBalanceAfterBurn);\n// Anchor krAssets should equal balance * denominator\nconst wkrAssetBalanceKresko = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(wkrAssetBalanceKresko).to.closeTo(hardhat_1.default.toBig(expectedBalanceAfterBurn / denominator), 100000); // WEI",
                          "err": {},
                          "uuid": "1ad5f81e-7e11-42f9-b776-f6c05f1e9990",
                          "parentUUID": "927569ba-5706-4878-a3a7-770a2938b25c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt amounts are calculated correctly when repaying partial debt after a positive rebase",
                          "timedOut": false,
                          "duration": 100,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.div(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst repayAmount = debt.div(2);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, repayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\n// Calc expected value with last update\nconst expectedDebt = mintAmount.div(2).mul(denominator);\n(0, chai_1.expect)(debtAfter).to.bignumber.equal(expectedDebt);\n// Should be all burned\nconst expectedBalanceAfter = mintAmount.mul(denominator).sub(repayAmount);\nconst balanceAfterBurn = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(balanceAfterBurn).to.bignumber.equal(expectedBalanceAfter);\n// All wkrAssets should be burned\nconst expectedwkrBalance = mintAmount.sub(repayAmount.div(denominator));\nconst wkrAssetBalanceKresko = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(wkrAssetBalanceKresko).to.equal(expectedwkrBalance);",
                          "err": {},
                          "uuid": "36ef7c94-0bf3-4536-9d30-44fa75318f60",
                          "parentUUID": "927569ba-5706-4878-a3a7-770a2938b25c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying all debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt amounts are calculated correctly when repaying all debt after a negative rebase",
                          "timedOut": false,
                          "duration": 104,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.mul(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst repayAmount = debt;\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, repayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\n// Calc expected value with last update\nconst expectedDebt = 0;\n(0, chai_1.expect)(debtAfter).to.bignumber.equal(expectedDebt);\nconst expectedBalanceAfterBurn = 0;\nconst balanceAfterBurn = hardhat_1.default.fromBig(await this.krAsset.contract.balanceOf(users.userOne.address));\n(0, chai_1.expect)(balanceAfterBurn).to.equal(expectedBalanceAfterBurn);\n// Anchor krAssets should equal balance * denominator\nconst wkrAssetBalanceKresko = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(wkrAssetBalanceKresko).to.equal(hardhat_1.default.toBig(expectedBalanceAfterBurn * denominator)); // WEI",
                          "err": {},
                          "uuid": "45e51fc9-0ba5-465b-8651-87581bb275d2",
                          "parentUUID": "927569ba-5706-4878-a3a7-770a2938b25c",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt amounts are calculated correctly when repaying partial debt after a negative rebase",
                          "timedOut": false,
                          "duration": 101,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.mul(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst repayAmount = debt.div(2);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, repayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\n// Calc expected value with last update\nconst expectedDebt = mintAmount.div(2).div(denominator);\n(0, chai_1.expect)(debtAfter).to.bignumber.equal(expectedDebt);\n// Should be all burned\nconst expectedBalanceAfter = mintAmount.div(denominator).sub(repayAmount);\nconst balanceAfterBurn = await this.krAsset.contract.balanceOf(users.userOne.address);\n(0, chai_1.expect)(balanceAfterBurn).to.bignumber.equal(expectedBalanceAfter);\n// All wkrAssets should be burned\nconst expectedwkrBalance = mintAmount.sub(repayAmount.mul(denominator));\nconst wkrAssetBalanceKresko = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(wkrAssetBalanceKresko).to.equal(expectedwkrBalance);",
                          "err": {},
                          "uuid": "cd51c159-07a2-4cfc-9b00-f7803d253d75",
                          "parentUUID": "927569ba-5706-4878-a3a7-770a2938b25c",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "1ad5f81e-7e11-42f9-b776-f6c05f1e9990",
                        "36ef7c94-0bf3-4536-9d30-44fa75318f60",
                        "45e51fc9-0ba5-465b-8651-87581bb275d2",
                        "cd51c159-07a2-4cfc-9b00-f7803d253d75"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 853,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    },
                    {
                      "uuid": "a5cbe317-fee9-45af-a3d0-673aef6d2252",
                      "title": "debt value and mintedKreskoAssets book-keeping is calculated correctly",
                      "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/minter/04-mint-repay.ts",
                      "file": "/src/test/minter/04-mint-repay.ts",
                      "beforeHooks": [],
                      "afterHooks": [],
                      "tests": [
                        {
                          "title": "when repaying all debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying all debt after a positive rebase",
                          "timedOut": false,
                          "duration": 92,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst fullRepayAmount = mintAmount.mul(denominator);\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.div(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, fullRepayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst debtValueAfter = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, debtAfter, false))\n    .rawValue;\n(0, chai_1.expect)(debtValueAfter).to.equal(0);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfterBurn).to.contain(this.krAsset.address);",
                          "err": {},
                          "uuid": "0c175bff-4031-4322-b29a-2bb5495a4d72",
                          "parentUUID": "a5cbe317-fee9-45af-a3d0-673aef6d2252",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a positive rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying partial debt after a positive rebase",
                          "timedOut": false,
                          "duration": 120,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = true;\nconst mintValue = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, mintAmount, false))\n    .rawValue;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.div(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Should contain minted krAsset\nconst mintedKreskoAssetsBeforeBurn = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsBeforeBurn).to.contain(this.krAsset.address);\n// Burn assets\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, debt.div(2), 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst debtValueAfter = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, debtAfter, false))\n    .rawValue;\n// Calc expected value with last update\nconst expectedValue = mintValue.div(2);\n(0, chai_1.expect)(debtValueAfter).to.equal(expectedValue);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfterBurn).to.contain(this.krAsset.address);",
                          "err": {},
                          "uuid": "6023c17a-eae1-4e04-8a1c-35e3a2fe544e",
                          "parentUUID": "a5cbe317-fee9-45af-a3d0-673aef6d2252",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying all debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying all debt after a negative rebase",
                          "timedOut": false,
                          "duration": 90,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst fullRepayAmount = mintAmount.div(denominator);\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.mul(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, fullRepayAmount, 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst debtValueAfter = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, debtAfter, false))\n    .rawValue;\n(0, chai_1.expect)(debtValueAfter).to.equal(0);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfterBurn).to.contain(this.krAsset.address);",
                          "err": {},
                          "uuid": "40a74f45-49e2-46df-8888-cd6777f25f9c",
                          "parentUUID": "a5cbe317-fee9-45af-a3d0-673aef6d2252",
                          "isHook": false,
                          "skipped": false
                        },
                        {
                          "title": "when repaying partial debt after a negative rebase",
                          "fullTitle": "Minter #mint+burn #burn - rebase events debt value and mintedKreskoAssets book-keeping is calculated correctly when repaying partial debt after a negative rebase",
                          "timedOut": false,
                          "duration": 118,
                          "state": "passed",
                          "speed": "slow",
                          "pass": true,
                          "fail": false,
                          "pending": false,
                          "context": null,
                          "code": "const userOne = hardhat_1.default.Diamond.connect(users.userOne);\n// Rebase params\nconst denominator = 4;\nconst positive = false;\nconst mintValue = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, mintAmount, false))\n    .rawValue;\n// Adjust price according to rebase params\nconst assetPrice = await this.krAsset.getPrice();\nconst newPrice = hardhat_1.default.fromBig(assetPrice.mul(denominator), 8);\nthis.krAsset.setPrice(newPrice);\nawait this.krAsset.contract.rebase(hardhat_1.default.toBig(denominator), positive);\n// Pay half of debt\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nawait userOne.burnKreskoAsset(users.userOne.address, this.krAsset.address, debt.div(2), 0);\n// Debt value after half repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(users.userOne.address, this.krAsset.address);\nconst debtValueAfter = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, debtAfter, false))\n    .rawValue;\n// Calc expected value with last update\nconst expectedValue = mintValue.div(2);\n(0, chai_1.expect)(debtValueAfter).to.equal(expectedValue);\n// Should still contain minted krAsset\nconst mintedKreskoAssetsAfterBurn = await hardhat_1.default.Diamond.getMintedKreskoAssets(users.userOne.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfterBurn).to.contain(this.krAsset.address);",
                          "err": {},
                          "uuid": "7b7ec75c-ea82-4bdb-a5dc-de0c8431bed3",
                          "parentUUID": "a5cbe317-fee9-45af-a3d0-673aef6d2252",
                          "isHook": false,
                          "skipped": false
                        }
                      ],
                      "suites": [],
                      "passes": [
                        "0c175bff-4031-4322-b29a-2bb5495a4d72",
                        "6023c17a-eae1-4e04-8a1c-35e3a2fe544e",
                        "40a74f45-49e2-46df-8888-cd6777f25f9c",
                        "7b7ec75c-ea82-4bdb-a5dc-de0c8431bed3"
                      ],
                      "failures": [],
                      "pending": [],
                      "skipped": [],
                      "duration": 420,
                      "root": false,
                      "rootEmpty": false,
                      "_timeout": 15000
                    }
                  ],
                  "passes": [],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 0,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "f7b1689b-6bf6-4c84-a044-5cb6535ea0bf",
          "title": "Flux Pricefeed",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/00-pricefeed.ts",
          "file": "/src/test/oracle/00-pricefeed.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Flux Pricefeed\"",
              "fullTitle": "Flux Pricefeed \"before all\" hook in \"Flux Pricefeed\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nthis.pricefeed;",
              "err": {},
              "uuid": "4d28bafe-f2aa-4e9f-82ef-8f1db0e868ad",
              "parentUUID": "f7b1689b-6bf6-4c84-a044-5cb6535ea0bf",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Flux Pricefeed\"",
              "fullTitle": "Flux Pricefeed \"before all\" hook in \"Flux Pricefeed\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "6b9f3764-7fc9-4e87-8ee3-ac6ce7b70948",
              "parentUUID": "f7b1689b-6bf6-4c84-a044-5cb6535ea0bf",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Flux Pricefeed\"",
              "fullTitle": "Flux Pricefeed \"before each\" hook in \"Flux Pricefeed\"",
              "timedOut": false,
              "duration": 22,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "c4449caa-9aac-4c4e-bc9e-f385ab06be91",
              "parentUUID": "f7b1689b-6bf6-4c84-a044-5cb6535ea0bf",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Flux Pricefeed\"",
              "fullTitle": "Flux Pricefeed \"before each\" hook in \"Flux Pricefeed\"",
              "timedOut": false,
              "duration": 61,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "// Deploy one price feed\nconst name = \"TEST\";\nconst decimals = 8;\nconst descriptionFeed = \"Test description\";\nconst feed = await hardhat_1.default.run(\"deployone:fluxpricefeed\", {\n    name,\n    decimals,\n    description: descriptionFeed,\n    log: false,\n});\nthis.pricefeed = feed;",
              "err": {},
              "uuid": "04eaf907-5bfd-4d56-b1a7-639e8b0a266c",
              "parentUUID": "f7b1689b-6bf6-4c84-a044-5cb6535ea0bf",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "228f7911-25dd-4de6-85de-a5fb5c129d52",
              "title": "functionality",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/00-pricefeed.ts",
              "file": "/src/test/oracle/00-pricefeed.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should initialize timestamp value once the initial answer is submitted",
                  "fullTitle": "Flux Pricefeed functionality should initialize timestamp value once the initial answer is submitted",
                  "timedOut": false,
                  "duration": 13,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.latestTimestamp()).to.equal(0);\nawait this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\n(0, chai_1.expect)(Number(await this.pricefeed.latestTimestamp())).to.be.greaterThan(0);",
                  "err": {},
                  "uuid": "590be036-e908-442b-9ea1-06a60f1e58d3",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return latestAnswer once it's changed",
                  "fullTitle": "Flux Pricefeed functionality should return latestAnswer once it's changed",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.latestAnswer()).to.equal(0);\nawait this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\n(0, chai_1.expect)(await this.pricefeed.latestAnswer()).to.equal(TEST_VALUE);",
                  "err": {},
                  "uuid": "68fddbaa-cee3-431f-8c90-7e8001048e6d",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return marketOpen once it's changed",
                  "fullTitle": "Flux Pricefeed functionality should return marketOpen once it's changed",
                  "timedOut": false,
                  "duration": 10,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.latestMarketOpen()).to.equal(false);\nawait this.pricefeed.transmit(0, true, { from: addr.deployer });\n(0, chai_1.expect)(await this.pricefeed.latestMarketOpen()).to.equal(true);",
                  "err": {},
                  "uuid": "dfb020e2-e587-4323-9d4c-c484e330ead1",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow non-validator to change values",
                  "fullTitle": "Flux Pricefeed functionality should not allow non-validator to change values",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.latestAnswer()).to.equal(0);\ntry {\n    await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.userOne });\n}\ncatch (e) {\n    if (!(e instanceof Error))\n        return;\n    (0, chai_1.expect)(e.message).to.equal('Contract with a Signer cannot override from (operation=\"overrides.from\", code=UNSUPPORTED_OPERATION, version=contracts/5.7.0)');\n    (0, chai_1.expect)(await this.pricefeed.latestAnswer()).to.equal(0);\n    (0, chai_1.expect)(await this.pricefeed.latestMarketOpen()).to.equal(false);\n}",
                  "err": {},
                  "uuid": "2d8efc8e-2351-41f7-b273-50fa2c01d9f6",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return description",
                  "fullTitle": "Flux Pricefeed functionality should return description",
                  "timedOut": false,
                  "duration": 5,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.description()).to.equal(\"Test description\");",
                  "err": {},
                  "uuid": "fa0e6ac2-65e2-4aae-bd44-cac27d349e2f",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return decimals",
                  "fullTitle": "Flux Pricefeed functionality should return decimals",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "(0, chai_1.expect)(await this.pricefeed.decimals()).to.equal(8);",
                  "err": {},
                  "uuid": "b60b4fca-6895-48a9-9be0-531bae7b7783",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return latestRoundData correctly",
                  "fullTitle": "Flux Pricefeed functionality should return latestRoundData correctly",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\nconst roundDataCall = await this.pricefeed.latestRoundData();\nconst roundData = {\n    roundId: roundDataCall[0].toNumber(),\n    answer: roundDataCall[1].toNumber(),\n    marketOpen: roundDataCall[2].valueOf(),\n    startedAt: roundDataCall[3].toNumber(),\n    updatedAt: roundDataCall[4].toNumber(),\n    answeredInRound: roundDataCall[5].toNumber(),\n};\n(0, chai_1.expect)(roundData.roundId).to.gt(0);\n(0, chai_1.expect)(roundData.startedAt).to.gt(0);\n(0, chai_1.expect)(roundData.startedAt).to.equal(roundData.updatedAt);\n(0, chai_1.expect)(roundData.answeredInRound).to.equal(roundData.roundId);\n(0, chai_1.expect)(roundData.answer).to.equal(TEST_VALUE);\n(0, chai_1.expect)(roundData.marketOpen).to.equal(true);",
                  "err": {},
                  "uuid": "d4fcbc72-41fe-465d-b57e-2b28d2653ac8",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return getRoundData correctly",
                  "fullTitle": "Flux Pricefeed functionality should return getRoundData correctly",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\nconst roundDataCall = await this.pricefeed.getRoundData(1);\nconst roundData = {\n    roundId: roundDataCall[0].toNumber(),\n    answer: roundDataCall[1].toNumber(),\n    marketOpen: roundDataCall[2].valueOf(),\n    startedAt: roundDataCall[3].toNumber(),\n    updatedAt: roundDataCall[4].toNumber(),\n    answeredInRound: roundDataCall[5].toNumber(),\n};\n(0, chai_1.expect)(roundData.roundId).to.gt(0);\n(0, chai_1.expect)(roundData.startedAt).to.gt(0);\n(0, chai_1.expect)(roundData.startedAt).to.equal(roundData.updatedAt);\n(0, chai_1.expect)(roundData.answeredInRound).to.equal(roundData.roundId);\n(0, chai_1.expect)(roundData.answer).to.equal(TEST_VALUE);\n(0, chai_1.expect)(roundData.marketOpen).to.equal(true);",
                  "err": {},
                  "uuid": "fb1d555d-06d7-4081-9517-4bb6e4cb75c5",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return getAnswer correctly",
                  "fullTitle": "Flux Pricefeed functionality should return getAnswer correctly",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\n(0, chai_1.expect)(await this.pricefeed.getAnswer(1)).to.equal(TEST_VALUE);",
                  "err": {},
                  "uuid": "f16ef1bc-3710-4ef2-b4cb-829a0cf5f3ab",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return marketOpen correctly",
                  "fullTitle": "Flux Pricefeed functionality should return marketOpen correctly",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\n(0, chai_1.expect)(await this.pricefeed.getMarketOpen(1)).to.equal(true);",
                  "err": {},
                  "uuid": "234cdda4-f0c1-4db6-9fb9-7952bacd0365",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return latestRound correctly",
                  "fullTitle": "Flux Pricefeed functionality should return latestRound correctly",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.pricefeed.transmit(TEST_VALUE, true, { from: addr.deployer });\n(0, chai_1.expect)(await this.pricefeed.latestRound()).to.equal(1);",
                  "err": {},
                  "uuid": "6c2b27f2-51b0-457e-ad38-b52c702d6ea8",
                  "parentUUID": "228f7911-25dd-4de6-85de-a5fb5c129d52",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "590be036-e908-442b-9ea1-06a60f1e58d3",
                "68fddbaa-cee3-431f-8c90-7e8001048e6d",
                "dfb020e2-e587-4323-9d4c-c484e330ead1",
                "2d8efc8e-2351-41f7-b273-50fa2c01d9f6",
                "fa0e6ac2-65e2-4aae-bd44-cac27d349e2f",
                "b60b4fca-6895-48a9-9be0-531bae7b7783",
                "d4fcbc72-41fe-465d-b57e-2b28d2653ac8",
                "fb1d555d-06d7-4081-9517-4bb6e4cb75c5",
                "f16ef1bc-3710-4ef2-b4cb-829a0cf5f3ab",
                "234cdda4-f0c1-4db6-9fb9-7952bacd0365",
                "6c2b27f2-51b0-457e-ad38-b52c702d6ea8"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 97,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "9bedb423-42ad-4484-bbe2-cab6ef235904",
          "title": "Flux price aggregator",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/01-priceaggregator.ts",
          "file": "/src/test/oracle/01-priceaggregator.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Flux price aggregator\"",
              "fullTitle": "Flux price aggregator \"before all\" hook in \"Flux price aggregator\"",
              "timedOut": false,
              "duration": 2,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "addr = await hardhat_1.default.getAddresses();\nthis.aggregator;",
              "err": {},
              "uuid": "60384f88-515a-4c6f-b098-5952ae588c46",
              "parentUUID": "9bedb423-42ad-4484-bbe2-cab6ef235904",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before all\" hook in \"Flux price aggregator\"",
              "fullTitle": "Flux price aggregator \"before all\" hook in \"Flux price aggregator\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "c80eaf8a-1f92-4395-8d60-8103a335ec7f",
              "parentUUID": "9bedb423-42ad-4484-bbe2-cab6ef235904",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Flux price aggregator\"",
              "fullTitle": "Flux price aggregator \"before each\" hook in \"Flux price aggregator\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "cdce84c8-c81e-4b34-8391-d5146ea426b3",
              "parentUUID": "9bedb423-42ad-4484-bbe2-cab6ef235904",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Flux price aggregator\"",
              "fullTitle": "Flux price aggregator \"before each\" hook in \"Flux price aggregator\"",
              "timedOut": false,
              "duration": 269,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "// Deploy three price feeds\nfor (let i = 0; i < 3; i++) {\n    const name = \"TEST\" + i;\n    const decimals = 8;\n    const descriptionFeed = \"Test description\";\n    const feed = await hardhat_1.default.run(\"deployone:fluxpricefeed\", {\n        name,\n        decimals,\n        description: descriptionFeed,\n        log: false,\n    });\n    oracles.push(feed);\n}\n// Deploy aggregator from the 3 price feeds\nconst decimalsAggregator = 8;\nconst description = \"TEST\";\nconst pricefeeds = oracles.map(oracle => oracle.address);\nconst deployedAggregator = await hardhat_1.default.run(\"test:deployone:fluxpriceaggregator\", {\n    oracles: pricefeeds.toString(),\n    decimals: decimalsAggregator.toString(),\n    description,\n    log: false,\n});\nthis.aggregator = deployedAggregator;\nthis.oracles = oracles;",
              "err": {},
              "uuid": "e30fd5d8-2409-4308-9b05-36420653fd58",
              "parentUUID": "9bedb423-42ad-4484-bbe2-cab6ef235904",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "83e66074-0a56-41e2-9aba-55b043a58666",
              "title": "Basic functionality",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/01-priceaggregator.ts",
              "file": "/src/test/oracle/01-priceaggregator.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should update latest timestamp when the updatePrices() method is called",
                  "fullTitle": "Flux price aggregator Basic functionality should update latest timestamp when the updatePrices() method is called",
                  "timedOut": false,
                  "duration": 44,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await initializeAllPricefeeds();\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);",
                  "err": {},
                  "uuid": "d9a72724-77cd-4e1d-8c73-f2c76e933696",
                  "parentUUID": "83e66074-0a56-41e2-9aba-55b043a58666",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should increment latestRound number when the updatePrices() method is called",
                  "fullTitle": "Flux price aggregator Basic functionality should increment latestRound number when the updatePrices() method is called",
                  "timedOut": false,
                  "duration": 61,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await initializeAllPricefeeds();\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(1);",
                  "err": {},
                  "uuid": "4124ce3b-be2c-4573-8a9e-a9633e894258",
                  "parentUUID": "83e66074-0a56-41e2-9aba-55b043a58666",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow deployer to change delay",
                  "fullTitle": "Flux price aggregator Basic functionality should allow deployer to change delay",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.aggregator.setDelay(12345, { from: addr.deployer });\n(0, chai_1.expect)(await this.aggregator.minDelay()).to.equal(12345);",
                  "err": {},
                  "uuid": "bf420d59-bb07-4445-a0d9-280ca22d5964",
                  "parentUUID": "83e66074-0a56-41e2-9aba-55b043a58666",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow deployer to change oracles",
                  "fullTitle": "Flux price aggregator Basic functionality should allow deployer to change oracles",
                  "timedOut": false,
                  "duration": 25,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Check oracle addresses\n(0, chai_1.expect)(await this.aggregator.oracles(0)).to.equal(this.oracles[0].address);\n(0, chai_1.expect)(await this.aggregator.oracles(1)).to.equal(this.oracles[1].address);\n(0, chai_1.expect)(await this.aggregator.oracles(2)).to.equal(this.oracles[2].address);\n// Remove 3rd oracle\nconst newOracles = [this.oracles[0].address, this.oracles[1].address];\nawait this.aggregator.setOracles(newOracles, { from: addr.deployer });\n// Check oracle addresses again\n(0, chai_1.expect)(await this.aggregator.oracles(0)).to.equal(this.oracles[0].address);\n(0, chai_1.expect)(await this.aggregator.oracles(1)).to.equal(this.oracles[1].address);\ntry {\n    // Third oracle should not exist anymore\n    (0, chai_1.expect)(await this.aggregator.oracles(2)).to.equal(this.oracles[2].address);\n}\ncatch (e) {\n    if (e instanceof Error) {\n        (0, chai_1.expect)(e.message).to.contain(`code=CALL_EXCEPTION`);\n    }\n}",
                  "err": {},
                  "uuid": "3b9e9582-f6a2-4f68-961b-083da47ac094",
                  "parentUUID": "83e66074-0a56-41e2-9aba-55b043a58666",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow updatePrices() to be called unless all oracles are initialized",
                  "fullTitle": "Flux price aggregator Basic functionality should not allow updatePrices() to be called unless all oracles are initialized",
                  "timedOut": false,
                  "duration": 149,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Rejected when there are 0 oracles initialized\nawait (0, chai_1.expect)(this.aggregator.updatePrices({ from: addr.deployer })).to.be.revertedWith(\"Error: uninitialized oracle\");\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(0);\n// Rejected when there is 1 oracle initialized\nawait oracles[0].transmit(0, false, {\n    from: addr.deployer,\n});\nawait (0, chai_1.expect)(this.aggregator.updatePrices({ from: addr.deployer })).to.be.revertedWith(\"Error: uninitialized oracle\");\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(0);\n// Rejected when there are 2 oracles initialized\nawait oracles[1].transmit(0, false, {\n    from: addr.deployer,\n});\nawait (0, chai_1.expect)(this.aggregator.updatePrices({ from: addr.deployer })).to.be.revertedWith(\"Error: uninitialized oracle\");\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(0);\n// Accepted when all 3 oracles are initialized\nawait oracles[2].transmit(0, false, {\n    from: addr.deployer,\n});\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestRound())).to.be.equal(1);",
                  "err": {},
                  "uuid": "e05b88c7-dc8c-4814-9f17-0fb721e6dc54",
                  "parentUUID": "83e66074-0a56-41e2-9aba-55b043a58666",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d9a72724-77cd-4e1d-8c73-f2c76e933696",
                "4124ce3b-be2c-4573-8a9e-a9633e894258",
                "bf420d59-bb07-4445-a0d9-280ca22d5964",
                "3b9e9582-f6a2-4f68-961b-083da47ac094",
                "e05b88c7-dc8c-4814-9f17-0fb721e6dc54"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 287,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "7c397f99-22aa-44e5-b289-bb6aa76a234f",
              "title": "Market open/close determination",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/01-priceaggregator.ts",
              "file": "/src/test/oracle/01-priceaggregator.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should determine market open/closed via majority vote",
                  "fullTitle": "Flux price aggregator Market open/close determination should determine market open/closed via majority vote",
                  "timedOut": false,
                  "duration": 128,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.oracles[0].transmit(100, true, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(150, false, {\n    from: addr.deployer,\n});\nawait this.oracles[2].transmit(160, true, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(false);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(true);",
                  "err": {},
                  "uuid": "032d99d4-71d1-442f-9886-78d21b6d53eb",
                  "parentUUID": "7c397f99-22aa-44e5-b289-bb6aa76a234f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should evaluate split 50-50 decision on market as market closed",
                  "fullTitle": "Flux price aggregator Market open/close determination should evaluate split 50-50 decision on market as market closed",
                  "timedOut": false,
                  "duration": 49,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Remove 3rd oracle so there are an even number of pricefeeds\nconst newOracles = [this.oracles[0].address, this.oracles[1].address];\nawait this.aggregator.setOracles(newOracles, { from: addr.deployer });\nawait this.oracles[0].transmit(100, true, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(150, false, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(false);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n// Timestamp updated but market open evaluates to false\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(false);",
                  "err": {},
                  "uuid": "6a595e0d-9c3e-4ac3-92c8-b1c4d1195b0e",
                  "parentUUID": "7c397f99-22aa-44e5-b289-bb6aa76a234f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should ignore negative prices + not include their market open boolean in market open/closed determination",
                  "fullTitle": "Flux price aggregator Market open/close determination should ignore negative prices + not include their market open boolean in market open/closed determination",
                  "timedOut": false,
                  "duration": 152,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await initializeAllPricefeeds();\nawait this.oracles[0].transmit(100, true, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(-20, false, {\n    from: addr.deployer,\n});\nawait this.oracles[2].transmit(-10, false, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(true);",
                  "err": {},
                  "uuid": "1d91f9a1-6cdc-40c9-94a6-51dae8ab9615",
                  "parentUUID": "7c397f99-22aa-44e5-b289-bb6aa76a234f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "032d99d4-71d1-442f-9886-78d21b6d53eb",
                "6a595e0d-9c3e-4ac3-92c8-b1c4d1195b0e",
                "1d91f9a1-6cdc-40c9-94a6-51dae8ab9615"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 329,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "f58e07b6-8500-4d23-a183-08c99f09d746",
              "title": "Median calculations",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/oracle/01-priceaggregator.ts",
              "file": "/src/test/oracle/01-priceaggregator.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should ignore prices of oracles who report that the market is closed",
                  "fullTitle": "Flux price aggregator Median calculations should ignore prices of oracles who report that the market is closed",
                  "timedOut": false,
                  "duration": 183,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Median of (10, 500, 600) = 500\n// Median of (500, 600) = 550\nawait this.oracles[0].transmit(10, false, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(500, true, {\n    from: addr.deployer,\n});\nawait this.oracles[2].transmit(600, true, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(false);\n(0, chai_1.expect)(Number(await this.aggregator.latestAnswer())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n// Market is open and price should be 550\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestMarketOpen()).to.equal(true);\n(0, chai_1.expect)(Number(await this.aggregator.latestAnswer())).to.be.equal(550);",
                  "err": {},
                  "uuid": "59cdb09f-57b2-4249-b321-d9071da599bf",
                  "parentUUID": "f58e07b6-8500-4d23-a183-08c99f09d746",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should aggregate latest prices from 3+ oracles, correctly selecting the median price",
                  "fullTitle": "Flux price aggregator Median calculations should aggregate latest prices from 3+ oracles, correctly selecting the median price",
                  "timedOut": false,
                  "duration": 201,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.oracles[0].transmit(100, true, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(125, true, {\n    from: addr.deployer,\n});\nawait this.oracles[2].transmit(300, true, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestAnswer()).to.equal(125);",
                  "err": {},
                  "uuid": "e20517ad-975e-4a57-bc2c-952ce208152d",
                  "parentUUID": "f58e07b6-8500-4d23-a183-08c99f09d746",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should ignore negative prices, not including them in price aggregation",
                  "fullTitle": "Flux price aggregator Median calculations should ignore negative prices, not including them in price aggregation",
                  "timedOut": false,
                  "duration": 165,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.oracles[0].transmit(100, true, {\n    from: addr.deployer,\n});\nawait this.oracles[1].transmit(-20, true, {\n    from: addr.deployer,\n});\nawait this.oracles[2].transmit(-10, true, {\n    from: addr.deployer,\n});\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.equal(0);\nawait this.aggregator.updatePrices({ from: addr.deployer });\n(0, chai_1.expect)(Number(await this.aggregator.latestTimestamp())).to.be.greaterThan(0);\n(0, chai_1.expect)(await this.aggregator.latestAnswer()).to.equal(100);",
                  "err": {},
                  "uuid": "14bbfa49-99a1-4841-bb77-a604d1f77600",
                  "parentUUID": "f58e07b6-8500-4d23-a183-08c99f09d746",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "59cdb09f-57b2-4249-b321-d9071da599bf",
                "e20517ad-975e-4a57-bc2c-952ce208152d",
                "14bbfa49-99a1-4841-bb77-a604d1f77600"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 549,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "38a92197-0bbe-4119-833a-0716c049bdde",
          "title": "Safety Council",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
          "file": "/src/test/safety/00-council.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Safety Council\"",
              "fullTitle": "Safety Council \"before all\" hook in \"Safety Council\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "606fa670-c831-4037-b5be-06faec445d86",
              "parentUUID": "38a92197-0bbe-4119-833a-0716c049bdde",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Safety Council\"",
              "fullTitle": "Safety Council \"before each\" hook in \"Safety Council\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "d75f5757-67f2-4def-a2b9-a9e40c2930e1",
              "parentUUID": "38a92197-0bbe-4119-833a-0716c049bdde",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Safety Council\"",
              "fullTitle": "Safety Council \"before each\" hook in \"Safety Council\"",
              "timedOut": false,
              "duration": 3,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "this.collateral = hardhat_1.default.collaterals.find(asset => asset.deployArgs.name === _test_utils_1.defaultCollateralArgs.name);\nthis.krAsset = hardhat_1.default.krAssets.find(asset => asset.deployArgs.symbol === _test_utils_1.defaultKrAssetArgs.symbol);\n// These are the 5 signers on the SafetyCouncil multisig\nconst { deployer, devTwo, extOne, extTwo, extThree } = await hardhat_1.default.ethers.getNamedSigners();\nusers = await hardhat_1.default.getUsers();\nthis.deployer = deployer;\nthis.devTwo = devTwo;\nthis.extOne = extOne;\nthis.extTwo = extTwo;\nthis.extThree = extThree;",
              "err": {},
              "uuid": "4b6daaba-9965-41eb-8b3e-01e94e960009",
              "parentUUID": "38a92197-0bbe-4119-833a-0716c049bdde",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "e5e4ec63-1e13-4ade-a0ab-910db8f2b358",
              "title": "#toggleAssetsPaused",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
              "file": "/src/test/safety/00-council.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "5745e242-3bbc-468d-bb4d-d4629b68c4c1",
                  "title": "multisig signature threshold",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "multisig transacts successfully with majority of signers (3/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with majority of signers (3/5)",
                      "timedOut": false,
                      "duration": 39,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne]);\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "2c357ede-31f1-4dba-ab15-b06d5fb26f8e",
                      "parentUUID": "5745e242-3bbc-468d-bb4d-d4629b68c4c1",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig transacts successfully with super-majority of signers (4/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with super-majority of signers (4/5)",
                      "timedOut": false,
                      "duration": 43,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne, this.extTwo]);\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "1774c370-2845-4181-ba49-38328cb12199",
                      "parentUUID": "5745e242-3bbc-468d-bb4d-d4629b68c4c1",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig transacts successfully with all signers (5/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig transacts successfully with all signers (5/5)",
                      "timedOut": false,
                      "duration": 40,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne, this.extTwo, this.extThree]);\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "9fd16a2e-71a3-4e7a-a793-69cb4844ad2f",
                      "parentUUID": "5745e242-3bbc-468d-bb4d-d4629b68c4c1",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "multisig should reject transactions signed by a minority of signers (2/5)",
                      "fullTitle": "Safety Council #toggleAssetsPaused multisig signature threshold multisig should reject transactions signed by a minority of signers (2/5)",
                      "timedOut": false,
                      "duration": 29,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, chai_1.expect)((0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo])).to.be.revertedWith(\"\");\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "91a7645a-b948-4c2a-b06b-60143d443b02",
                      "parentUUID": "5745e242-3bbc-468d-bb4d-d4629b68c4c1",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "2c357ede-31f1-4dba-ab15-b06d5fb26f8e",
                    "1774c370-2845-4181-ba49-38328cb12199",
                    "9fd16a2e-71a3-4e7a-a793-69cb4844ad2f",
                    "91a7645a-b948-4c2a-b06b-60143d443b02"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 151,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "7ec62888-9f36-4cc1-b99c-9ebdaa0fc730",
                  "title": "toggle actions only for listed assets",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can toggle actions for listed collateral assets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets can toggle actions for listed collateral assets",
                      "timedOut": false,
                      "duration": 39,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne]);\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "9dd4804b-275c-4097-a447-953244a79c0c",
                      "parentUUID": "7ec62888-9f36-4cc1-b99c-9ebdaa0fc730",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle actions for listed krAssets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets can toggle actions for listed krAssets",
                      "timedOut": false,
                      "duration": 38,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.krAsset.address], _test_utils_1.Action.REPAY, false, 0], [this.deployer, this.devTwo, this.extOne]);\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.REPAY.toString(), this.krAsset.address);\n(0, chai_1.expect)(isPaused).to.equal(true);",
                      "err": {},
                      "uuid": "a98565da-ffe0-4cf5-8fb0-52008fbe974d",
                      "parentUUID": "7ec62888-9f36-4cc1-b99c-9ebdaa0fc730",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "cannot toggle actions for addresses that are not listed collateral assets or krAssets",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle actions only for listed assets cannot toggle actions for addresses that are not listed collateral assets or krAssets",
                      "timedOut": false,
                      "duration": 44,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const randomAddr = hardhat_1.default.ethers.utils.computeAddress(\"0xb976778317b23a1285ec2d483eda6904d9319135b89f1d8eee9f6d2593e2665d\");\nawait (0, chai_1.expect)((0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[randomAddr], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne])).to.be.revertedWith(\"\");\nconst isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), randomAddr);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "81df14c9-c821-436b-a420-91ffe59e3d38",
                      "parentUUID": "7ec62888-9f36-4cc1-b99c-9ebdaa0fc730",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "9dd4804b-275c-4097-a447-953244a79c0c",
                    "a98565da-ffe0-4cf5-8fb0-52008fbe974d",
                    "81df14c9-c821-436b-a420-91ffe59e3d38"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 121,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "f611e4ce-babd-4f8c-8cbb-f0c6ec7035e7",
                  "title": "duration based pausing",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can optionally set a timeout on a given pause command",
                      "fullTitle": "Safety Council #toggleAssetsPaused duration based pausing can optionally set a timeout on a given pause command",
                      "timedOut": false,
                      "duration": 43,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const duration = 100000000;\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, true, duration], [this.deployer, this.devTwo, this.extOne]);\nconst depositSafetyState = await hardhat_1.default.Diamond.safetyStateFor(this.collateral.address, _test_utils_1.Action.DEPOSIT);\n(0, chai_1.expect)(depositSafetyState.length).to.equal(1);\n// Blocktime timestamp + duration should be equal to final timestamp\n(0, chai_1.expect)(depositSafetyState[0].timestamp0.add(duration)).eq(depositSafetyState[0].timestamp1);",
                      "err": {},
                      "uuid": "10cfd865-7012-45b9-94ad-f1a94ba96f8b",
                      "parentUUID": "f611e4ce-babd-4f8c-8cbb-f0c6ec7035e7",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "duration based pause functionality should expire after the duration has passed [PLACEHOLDER]",
                      "fullTitle": "Safety Council #toggleAssetsPaused duration based pausing duration based pause functionality should expire after the duration has passed [PLACEHOLDER]",
                      "timedOut": false,
                      "duration": 43,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const duration = 100000;\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, true, duration], [this.deployer, this.devTwo, this.extOne]);\nconst depositSafetyState = await hardhat_1.default.Diamond.safetyStateFor(this.collateral.address, _test_utils_1.Action.DEPOSIT);\n(0, chai_1.expect)(depositSafetyState.length).to.equal(1);\n// Blocktime timestamp + duration should be equal to final timestamp\n(0, chai_1.expect)(depositSafetyState[0].timestamp0.add(duration)).eq(depositSafetyState[0].timestamp1);\n// Confirm that the current blocktime is within the pause action's duration\nconst blockNumBefore = await hardhat_1.default.ethers.provider.getBlockNumber();\nconst blockBefore = await hardhat_1.default.ethers.provider.getBlock(blockNumBefore);\nconst timestampBefore = blockBefore.timestamp;\n(0, chai_1.expect)(Number(depositSafetyState[0].timestamp1)).to.be.greaterThan(timestampBefore);\n// Increase time by seven days\nconst sevenDays = 7 * 24 * 60 * 60;\nawait hardhat_1.default.ethers.provider.send(\"evm_increaseTime\", [sevenDays]);\nawait hardhat_1.default.ethers.provider.send(\"evm_mine\", []);\n// Confirm that block time has increased as expected\nconst blockNumAfter = await hardhat_1.default.ethers.provider.getBlockNumber();\nconst blockAfter = await hardhat_1.default.ethers.provider.getBlock(blockNumAfter);\nconst timestampAfter = blockAfter.timestamp;\n(0, chai_1.expect)(blockNumAfter).to.be.equal(blockNumBefore + 1);\n(0, chai_1.expect)(timestampAfter).to.be.equal(timestampBefore + sevenDays);\n// Confirm that the current blocktime is after the pause action's duration\n(0, chai_1.expect)(timestampAfter).to.be.greaterThan(Number(depositSafetyState[0].timestamp1));\n// NOTE: now we can test any functionality that should have now expired",
                      "err": {},
                      "uuid": "e93ab156-2052-4bf1-b8a9-0707fc8c76f4",
                      "parentUUID": "f611e4ce-babd-4f8c-8cbb-f0c6ec7035e7",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "10cfd865-7012-45b9-94ad-f1a94ba96f8b",
                    "e93ab156-2052-4bf1-b8a9-0707fc8c76f4"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 86,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                  "title": "toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "can toggle action DEPOSIT pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action DEPOSIT pause status on and off",
                      "timedOut": false,
                      "duration": 77,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne]);\nlet isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne]);\nisPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.DEPOSIT.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "3e0a0eb9-fe96-4ee5-8aab-2df6be6f71e2",
                      "parentUUID": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action WITHDRAW pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action WITHDRAW pause status on and off",
                      "timedOut": false,
                      "duration": 74,
                      "state": "passed",
                      "speed": "medium",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.WITHDRAW, false, 0], [this.deployer, this.devTwo, this.extOne]);\nlet isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.WITHDRAW.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.WITHDRAW, false, 0], [this.deployer, this.devTwo, this.extOne]);\nisPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.WITHDRAW.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "a380aac5-4270-4eff-a61d-f1f88dbb4c3a",
                      "parentUUID": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action REPAY pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action REPAY pause status on and off",
                      "timedOut": false,
                      "duration": 77,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.REPAY, false, 0], [this.deployer, this.devTwo, this.extOne]);\nlet isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.REPAY.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.REPAY, false, 0], [this.deployer, this.devTwo, this.extOne]);\nisPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.REPAY.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "7fad3460-416b-4b5f-9c90-25d2491f5a25",
                      "parentUUID": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action BORROW pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action BORROW pause status on and off",
                      "timedOut": false,
                      "duration": 76,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.BORROW, false, 0], [this.deployer, this.devTwo, this.extOne]);\nlet isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.BORROW.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.BORROW, false, 0], [this.deployer, this.devTwo, this.extOne]);\nisPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.BORROW.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "308d9fe4-af51-42e7-9f89-ec846df78c53",
                      "parentUUID": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "can toggle action LIQUIDATION pause status on and off",
                      "fullTitle": "Safety Council #toggleAssetsPaused toggle all possible actions: DEPOSIT, WITHDRAW, REPAY, BORROW, LIQUIDATION can toggle action LIQUIDATION pause status on and off",
                      "timedOut": false,
                      "duration": 84,
                      "state": "passed",
                      "speed": "slow",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.LIQUIDATION, false, 0], [this.deployer, this.devTwo, this.extOne]);\nlet isPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.LIQUIDATION.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(true);\nawait (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.LIQUIDATION, false, 0], [this.deployer, this.devTwo, this.extOne]);\nisPaused = await hardhat_1.default.Diamond.assetActionPaused(_test_utils_1.Action.LIQUIDATION.toString(), this.collateral.address);\n(0, chai_1.expect)(isPaused).to.equal(false);",
                      "err": {},
                      "uuid": "bfb3205c-3d03-4f73-abb1-17ba7134e458",
                      "parentUUID": "b5e6729f-9ac4-4ea7-92a2-06bb90db0adc",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "3e0a0eb9-fe96-4ee5-8aab-2df6be6f71e2",
                    "a380aac5-4270-4eff-a61d-f1f88dbb4c3a",
                    "7fad3460-416b-4b5f-9c90-25d2491f5a25",
                    "308d9fe4-af51-42e7-9f89-ec846df78c53",
                    "bfb3205c-3d03-4f73-abb1-17ba7134e458"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 388,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                },
                {
                  "uuid": "83934d28-1d77-4222-b85b-d693465169e9",
                  "title": "event emission",
                  "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/safety/00-council.ts",
                  "file": "/src/test/safety/00-council.ts",
                  "beforeHooks": [],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should emit event MinterEvent.SafetyStateChange on action changed containing action, asset, and description",
                      "fullTitle": "Safety Council #toggleAssetsPaused event emission should emit event MinterEvent.SafetyStateChange on action changed containing action, asset, and description",
                      "timedOut": false,
                      "duration": 35,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const tx = await (0, execution_1.executeContractCallWithSigners)(hardhat_1.default.Multisig, hardhat_1.default.Diamond, \"toggleAssetsPaused\", [[this.collateral.address], _test_utils_1.Action.DEPOSIT, false, 0], [this.deployer, this.devTwo, this.extOne]);\nconst event = await (0, events_1.getInternalEvent)(tx, types_1.MinterEvent__factory.connect(hardhat_1.default.Diamond.address, users.userOne), \"SafetyStateChange\");\n(0, chai_1.expect)(event.action).to.equal(_test_utils_1.Action.DEPOSIT);\n(0, chai_1.expect)(event.asset).to.equal(this.collateral.address);\n// @ts-ignore\n(0, chai_1.expect)(event.description.hash).to.equal(hardhat_1.default.ethers.utils.keccak256(hardhat_1.default.ethers.utils.toUtf8Bytes(\"paused\")));",
                      "err": {},
                      "uuid": "a21c95d0-d548-4678-b49b-3bf2b8dda267",
                      "parentUUID": "83934d28-1d77-4222-b85b-d693465169e9",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a21c95d0-d548-4678-b49b-3bf2b8dda267"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 35,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 15000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "7a8ac7df-25a8-4c6e-ac2c-99c71e3a3ef1",
          "title": "Interest Rates",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/00-init.ts",
          "file": "/src/test/stability-rate/00-init.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Interest Rates\"",
              "fullTitle": "Interest Rates \"before all\" hook in \"Interest Rates\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "51f9f563-95ee-4aa2-bbf5-683552cb0101",
              "parentUUID": "7a8ac7df-25a8-4c6e-ac2c-99c71e3a3ef1",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Interest Rates\"",
              "fullTitle": "Interest Rates \"before each\" hook in \"Interest Rates\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "6f3e4b93-da0c-4d1a-b035-02ba5cb198d8",
              "parentUUID": "7a8ac7df-25a8-4c6e-ac2c-99c71e3a3ef1",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Interest Rates\"",
              "fullTitle": "Interest Rates \"before each\" hook in \"Interest Rates\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "this.krAsset = this.krAssets.find(c => c.deployArgs.name === test_1.defaultKrAssetArgs.name);\nthis.collateral = this.collaterals.find(c => c.deployArgs.name === test_1.defaultCollateralArgs.name);",
              "err": {},
              "uuid": "dfd9af54-9666-46e7-99cb-e0b825b4ea22",
              "parentUUID": "7a8ac7df-25a8-4c6e-ac2c-99c71e3a3ef1",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "394e7602-9299-45fd-a096-593447a4cb77",
              "title": "#init",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/00-init.ts",
              "file": "/src/test/stability-rate/00-init.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "initializes correct stability rates",
                  "fullTitle": "Interest Rates #init initializes correct stability rates",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const config = await hardhat_1.default.Diamond.getStabilityRateConfigurationForAsset(this.krAsset.address);\n// default values\n(0, chai_1.expect)(config.debtIndex).to.bignumber.equal(wadray_1.oneRay);\n(0, chai_1.expect)(config.stabilityRate).to.bignumber.equal(wadray_1.oneRay);\n(0, chai_1.expect)(config.asset).to.equal(this.krAsset.address);\n// configured values\n(0, chai_1.expect)(config.rateSlope1).to.bignumber.equal(test_1.defaultKrAssetArgs.stabilityRates.rateSlope1);\n(0, chai_1.expect)(config.rateSlope2).to.bignumber.equal(test_1.defaultKrAssetArgs.stabilityRates.rateSlope2);\n(0, chai_1.expect)(config.stabilityRateBase).to.bignumber.equal(test_1.defaultKrAssetArgs.stabilityRates.stabilityRateBase);\n(0, chai_1.expect)(config.optimalPriceRate).to.bignumber.equal(test_1.defaultKrAssetArgs.stabilityRates.optimalPriceRate);\n(0, chai_1.expect)(config.priceRateDelta).to.bignumber.equal(test_1.defaultKrAssetArgs.stabilityRates.priceRateDelta);",
                  "err": {},
                  "uuid": "6f919e40-883b-43df-9031-b111b89a4622",
                  "parentUUID": "394e7602-9299-45fd-a096-593447a4cb77",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "configures correct stability rates",
                  "fullTitle": "Interest Rates #init configures correct stability rates",
                  "timedOut": false,
                  "duration": 18,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const configuration = {\n    stabilityRateBase: wadray_1.oneRay,\n    rateSlope1: wadray_1.oneRay.mul(10),\n    rateSlope2: wadray_1.oneRay.mul(50),\n    optimalPriceRate: wadray_1.oneRay.div(2),\n    priceRateDelta: wadray_1.oneRay.div(100).mul(10),\n};\nawait hardhat_1.default.Diamond.updateStabilityRateParams(this.krAsset.address, configuration);\nconst config = await hardhat_1.default.Diamond.getStabilityRateConfigurationForAsset(this.krAsset.address);\n// default values\n(0, chai_1.expect)(config.debtIndex).to.bignumber.equal(wadray_1.oneRay);\n(0, chai_1.expect)(config.stabilityRate).to.bignumber.equal(wadray_1.oneRay);\n(0, chai_1.expect)(config.asset).to.equal(this.krAsset.address);\n// configured values\n(0, chai_1.expect)(config.rateSlope1).to.bignumber.equal(configuration.rateSlope1);\n(0, chai_1.expect)(config.rateSlope2).to.bignumber.equal(configuration.rateSlope2);\n(0, chai_1.expect)(config.stabilityRateBase).to.bignumber.equal(configuration.stabilityRateBase);\n(0, chai_1.expect)(config.optimalPriceRate).to.bignumber.equal(configuration.optimalPriceRate);\n(0, chai_1.expect)(config.priceRateDelta).to.bignumber.equal(configuration.priceRateDelta);",
                  "err": {},
                  "uuid": "d7926907-f348-4a64-aa2e-e459ae957e7e",
                  "parentUUID": "394e7602-9299-45fd-a096-593447a4cb77",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cant set incorrect values",
                  "fullTitle": "Interest Rates #init cant set incorrect values",
                  "timedOut": false,
                  "duration": 29,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const incorrectOptimalRate = {\n    stabilityRateBase: wadray_1.oneRay,\n    rateSlope1: wadray_1.oneRay.mul(10),\n    rateSlope2: wadray_1.oneRay.mul(50),\n    optimalPriceRate: wadray_1.oneRay.add(1),\n    priceRateDelta: wadray_1.oneRay.div(100).mul(10),\n};\nconst incorrectExcessRate = {\n    stabilityRateBase: wadray_1.oneRay,\n    rateSlope1: wadray_1.oneRay.mul(10),\n    rateSlope2: wadray_1.oneRay.mul(50),\n    optimalPriceRate: wadray_1.oneRay,\n    priceRateDelta: wadray_1.oneRay.add(1),\n};\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.setupStabilityRateParams(this.krAsset.address, test_1.defaultKrAssetArgs.stabilityRates))\n    .to.be.reverted;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.updateStabilityRateParams(this.krAsset.address, incorrectOptimalRate)).to.be\n    .reverted;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.updateStabilityRateParams(this.krAsset.address, incorrectExcessRate)).to.be\n    .reverted;",
                  "err": {},
                  "uuid": "91affb2e-1e1a-46a7-ab02-3d3820b4a42b",
                  "parentUUID": "394e7602-9299-45fd-a096-593447a4cb77",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6f919e40-883b-43df-9031-b111b89a4622",
                "d7926907-f348-4a64-aa2e-e459ae957e7e",
                "91affb2e-1e1a-46a7-ab02-3d3820b4a42b"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 54,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "be1cddc5-a127-43cf-b35b-d85b74c7c0a0",
          "title": "Stability Rates",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/01-rates.ts",
          "file": "/src/test/stability-rate/01-rates.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before all\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "6f03cfd3-0569-4fd5-8658-78d4fa2b7f28",
              "parentUUID": "be1cddc5-a127-43cf-b35b-d85b74c7c0a0",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 20,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "87cd1a31-d254-4fd7-bca7-a8619eabf42c",
              "parentUUID": "be1cddc5-a127-43cf-b35b-d85b74c7c0a0",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 256,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();\nuserOne = users.deployer;\nthis.krAsset = this.krAssets.find(c => c.deployArgs.name === test_1.defaultKrAssetArgs.name);\nthis.collateral = this.collaterals.find(c => c.deployArgs.name === test_1.defaultCollateralArgs.name);\n[UniMath] = await hardhat_1.default.deploy(\"UniswapMath\", {\n    from: users.deployer.address,\n    args: [hardhat_1.default.UniV2Factory.address, hardhat_1.default.UniV2Router.address],\n});\nconst krAssetOraclePrice = 10;\nthis.krAsset.setPrice(krAssetOraclePrice);\nconst cLiq = (0, numbers_1.toBig)(1000);\nconst kLiq = (0, numbers_1.toBig)(100);\nawait this.collateral.setBalance(userOne, cLiq.mul(2));\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: cLiq,\n    user: userOne,\n});\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: kLiq });\n// 1000/100 = krAsset amm price 10\nconst pair = await (0, amm_1.addLiquidity)({\n    user: userOne,\n    router: hardhat_1.default.UniV2Router,\n    amount0: cLiq,\n    amount1: kLiq,\n    token0: this.collateral,\n    token1: this.krAsset,\n});\nupdateTWAP = (0, amm_1.getTWAPUpdaterFor)(pair.address);\nawait hardhat_1.default.UniV2Oracle.initPair(pair.address, this.krAsset.address, 60 * 60);\nawait updateTWAP();",
              "err": {},
              "uuid": "75dede2c-0f0c-477f-a50b-d3ecabb0cdcc",
              "parentUUID": "be1cddc5-a127-43cf-b35b-d85b74c7c0a0",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "5055d480-88ac-429f-b2f5-cdd91e7cfe2f",
              "title": "#no-amm-prices",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/01-rates.ts",
              "file": "/src/test/stability-rate/01-rates.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct price rates when the amm liquidity does not qualify",
                  "fullTitle": "Stability Rates #no-amm-prices calculates correct price rates when the amm liquidity does not qualify",
                  "timedOut": false,
                  "duration": 0,
                  "state": "pending",
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": true,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "3e90dbc2-0c42-4b48-8a68-369e2af661e4",
                  "parentUUID": "5055d480-88ac-429f-b2f5-cdd91e7cfe2f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct rates and debt when there is no amm price",
                  "fullTitle": "Stability Rates #no-amm-prices calculates correct rates and debt when there is no amm price",
                  "timedOut": false,
                  "duration": 4761,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const krAssetAmount = (0, numbers_1.toBig)(1);\nconst krAssetNoBaseRate = await (0, krassets_1.addMockKreskoAsset)({\n    name: \"krasset2\",\n    symbol: \"krasset2\",\n    marketOpen: true,\n    factor: 1,\n    closeFee: 0,\n    openFee: 0,\n    stabilityRateBase: ethers_1.BigNumber.from(0),\n    price: 10,\n    supplyLimit: 2000,\n});\nconst krAssetWithBaseRate = await (0, krassets_1.addMockKreskoAsset)({\n    name: \"krasset2\",\n    symbol: \"krasset2\",\n    marketOpen: true,\n    factor: 1,\n    closeFee: 0,\n    openFee: 0,\n    stabilityRateBase: test_1.BASIS_POINT.mul(20),\n    price: 10,\n    supplyLimit: 2000,\n});\n// Asset\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: krAssetNoBaseRate, amount: krAssetAmount });\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: krAssetWithBaseRate, amount: krAssetAmount });\nconst lastUpdateTimestamp = await (0, calculations_1.getBlockTimestamp)();\nconst debtIndexBefore = await hardhat_1.default.Diamond.getDebtIndexForAsset(krAssetWithBaseRate.address);\nawait hardhat_network_helpers_1.time.increase(+wadray_1.ONE_YEAR);\n// asset with no base rate and no amm price\nconst debtIndexNoBaseRate = await hardhat_1.default.Diamond.getDebtIndexForAsset(krAssetNoBaseRate.address);\nconst debtScaledNoBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebt(userOne.address, krAssetNoBaseRate.address);\nconst debtPrincipalNoBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userOne.address, krAssetNoBaseRate.address);\nconst debtInterestNoBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userOne.address, krAssetNoBaseRate.address);\n(0, chai_1.expect)(debtIndexNoBaseRate).to.equal(wadray_1.oneRay);\n(0, chai_1.expect)(debtScaledNoBaseRate).to.equal(debtPrincipalNoBaseRate);\n(0, chai_1.expect)(debtInterestNoBaseRate.kissAmount).to.equal(0);\n(0, chai_1.expect)(debtInterestNoBaseRate.assetAmount).to.equal(0);\n// asset with base rate and no amm price\nconst debtIndexWithBaseRate = await hardhat_1.default.Diamond.getDebtIndexForAsset(krAssetWithBaseRate.address);\nconst debtScaledWithBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebt(userOne.address, krAssetWithBaseRate.address);\nconst debtPrincipalWithBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userOne.address, krAssetWithBaseRate.address);\nconst debtInterestWithBaseRate = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userOne.address, krAssetWithBaseRate.address);\nconst expectedScaledDebt = await (0, calculations_1.toScaledAmount)(debtPrincipalWithBaseRate, krAssetWithBaseRate);\nconst expectedDebtIndex = await (0, calculations_1.calcDebtIndex)(krAssetWithBaseRate, debtIndexBefore, lastUpdateTimestamp);\nconst expectedAssetInterest = debtScaledWithBaseRate.sub(debtPrincipalWithBaseRate);\nconst expectedKissInterestAmount = await (0, calculations_1.oraclePriceToWad)(hardhat_1.default.Diamond.getKrAssetValue(krAssetWithBaseRate.address, expectedAssetInterest, true));\n(0, chai_1.expect)(debtIndexWithBaseRate).to.equal(expectedDebtIndex);\n(0, chai_1.expect)(debtScaledWithBaseRate).to.equal(expectedScaledDebt);\n(0, chai_1.expect)(debtInterestWithBaseRate.assetAmount).to.equal(expectedAssetInterest);\n(0, chai_1.expect)(debtInterestWithBaseRate.kissAmount).to.equal(expectedKissInterestAmount);",
                  "err": {},
                  "uuid": "fb1fb906-e930-4647-8d49-9070b2b145bb",
                  "parentUUID": "5055d480-88ac-429f-b2f5-cdd91e7cfe2f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "fb1fb906-e930-4647-8d49-9070b2b145bb"
              ],
              "failures": [],
              "pending": [
                "3e90dbc2-0c42-4b48-8a68-369e2af661e4"
              ],
              "skipped": [],
              "duration": 4761,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "ac145d72-e09d-4a31-b8ea-b82ad3d1a256",
              "title": "#price-rate",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/01-rates.ts",
              "file": "/src/test/stability-rate/01-rates.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct price rates when amm == oracle",
                  "fullTitle": "Stability Rates #price-rate calculates correct price rates when amm == oracle",
                  "timedOut": false,
                  "duration": 70,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst ammPricesOptimal = await (0, amm_1.getAMMPrices)(this.collateral, this.krAsset);\n(0, chai_1.expect)(ammPricesOptimal.price0).to.be.closeTo(10, 0.05);\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(priceRate).to.bignumber.equal(wadray_1.oneRay);",
                  "err": {},
                  "uuid": "5b6a193d-4611-4ecf-8b59-14f8aad53557",
                  "parentUUID": "ac145d72-e09d-4a31-b8ea-b82ad3d1a256",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct price rates when amm > oracle",
                  "fullTitle": "Stability Rates #price-rate calculates correct price rates when amm > oracle",
                  "timedOut": false,
                  "duration": 124,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const premiumPercentage = 105; // 105% eg. 5% premium\nconst expectedPriceRate = wadray_1.oneRay.div(100).mul(premiumPercentage);\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait this.collateral.setBalance(userOne, amountIn);\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.collateral.address, this.krAsset.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nconst ammPricesUpPremium = await (0, amm_1.getAMMPrices)(this.collateral, this.krAsset);\n(0, chai_1.expect)(ammPricesUpPremium.price0).to.be.closeTo(10.5, 0.05);\nawait updateTWAP();\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(priceRate).to.bignumber.closeTo(expectedPriceRate, wadray_1.oneRay.div(100));",
                  "err": {},
                  "uuid": "5c7390cb-269c-4301-b21c-0ffe03c4c756",
                  "parentUUID": "ac145d72-e09d-4a31-b8ea-b82ad3d1a256",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct price rates when amm < oracle ",
                  "fullTitle": "Stability Rates #price-rate calculates correct price rates when amm < oracle ",
                  "timedOut": false,
                  "duration": 195,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const premiumPercentage = 95; // 95% eg. 5% below oracle price\nconst expectedPriceRate = wadray_1.oneRay.div(100).mul(premiumPercentage);\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nconst ammRates = await (0, amm_1.getAMMPrices)(this.collateral, this.krAsset);\n(0, chai_1.expect)(ammRates.price0).to.be.closeTo(9.5, 0.05);\nawait updateTWAP();\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(priceRate).to.bignumber.closeTo(expectedPriceRate, wadray_1.oneRay.div(100));",
                  "err": {},
                  "uuid": "a0df0fd6-6ba7-4f84-b8eb-88f1332c57af",
                  "parentUUID": "ac145d72-e09d-4a31-b8ea-b82ad3d1a256",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "5b6a193d-4611-4ecf-8b59-14f8aad53557",
                "5c7390cb-269c-4301-b21c-0ffe03c4c756",
                "a0df0fd6-6ba7-4f84-b8eb-88f1332c57af"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 389,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "115756b1-5173-4590-a56a-bddfdf568c29",
              "title": "#stability-rate",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/01-rates.ts",
              "file": "/src/test/stability-rate/01-rates.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct stability rates when amm == oracle",
                  "fullTitle": "Stability Rates #stability-rate calculates correct stability rates when amm == oracle",
                  "timedOut": false,
                  "duration": 89,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst stabilityRate = await hardhat_1.default.Diamond.getStabilityRateForAsset(this.krAsset.address);\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(stabilityRate).to.bignumber.equal((0, calculations_1.calcExpectedStabilityRateNoPremium)(priceRate, test_1.defaultKrAssetArgs));",
                  "err": {},
                  "uuid": "8f33654a-d0e1-4406-a3e5-05589a07a8c0",
                  "parentUUID": "115756b1-5173-4590-a56a-bddfdf568c29",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct stability rates when amm > oracle",
                  "fullTitle": "Stability Rates #stability-rate calculates correct stability rates when amm > oracle",
                  "timedOut": false,
                  "duration": 144,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 105; // 105% eg. 5% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait this.collateral.setBalance(userOne, amountIn);\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.collateral.address, this.krAsset.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst stabilityRate = await hardhat_1.default.Diamond.getStabilityRateForAsset(this.krAsset.address);\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(stabilityRate).to.bignumber.equal((0, calculations_1.calcExpectedStabilityRateHighPremium)(priceRate, test_1.defaultKrAssetArgs));",
                  "err": {},
                  "uuid": "823d39b4-fee8-4008-bb9c-c42dff5783c3",
                  "parentUUID": "115756b1-5173-4590-a56a-bddfdf568c29",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct stability rates when amm < oracle ",
                  "fullTitle": "Stability Rates #stability-rate calculates correct stability rates when amm < oracle ",
                  "timedOut": false,
                  "duration": 238,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 95; // 95% eg. -5% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst stabilityRate = await hardhat_1.default.Diamond.getStabilityRateForAsset(this.krAsset.address);\nconst priceRate = await hardhat_1.default.Diamond.getPriceRateForAsset(this.krAsset.address);\n(0, chai_1.expect)(stabilityRate).to.bignumber.equal((0, calculations_1.calcExpectedStabilityRateLowPremium)(priceRate, test_1.defaultKrAssetArgs));",
                  "err": {},
                  "uuid": "6bc5c8b4-3a92-487a-9b7e-ece834c904c9",
                  "parentUUID": "115756b1-5173-4590-a56a-bddfdf568c29",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "8f33654a-d0e1-4406-a3e5-05589a07a8c0",
                "823d39b4-fee8-4008-bb9c-c42dff5783c3",
                "6bc5c8b4-3a92-487a-9b7e-ece834c904c9"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 471,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "16bc7b5c-6aef-4a3b-bacf-621349a8ba6d",
              "title": "#debt-index",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/01-rates.ts",
              "file": "/src/test/stability-rate/01-rates.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct debt index after a year when amm price > oracle",
                  "fullTitle": "Stability Rates #debt-index calculates correct debt index after a year when amm price > oracle",
                  "timedOut": false,
                  "duration": 230,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 105; // 105% eg. 5% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst debtIndexBefore = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\nconst lastUpdateTimestamp = await (0, calculations_1.getBlockTimestamp)();\nawait hardhat_network_helpers_1.time.increase(+wadray_1.ONE_YEAR);\nconst debtIndexAfter = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndexAfter).to.not.equal(debtIndexBefore);\n(0, chai_1.expect)(debtIndexAfter).to.be.bignumber.equal(await (0, calculations_1.calcDebtIndex)(this.krAsset, debtIndexBefore, lastUpdateTimestamp));",
                  "err": {},
                  "uuid": "bb64c155-5dc3-486b-9982-e8f42087274f",
                  "parentUUID": "16bc7b5c-6aef-4a3b-bacf-621349a8ba6d",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct debt index after year when amm price < oracle",
                  "fullTitle": "Stability Rates #debt-index calculates correct debt index after year when amm price < oracle",
                  "timedOut": false,
                  "duration": 226,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 90; // 90% eg. -10% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst debtIndexBefore = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\nconst lastUpdateTimestamp = await (0, calculations_1.getBlockTimestamp)();\nawait hardhat_network_helpers_1.time.increase(+wadray_1.ONE_YEAR);\nconst debtIndexAfter = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndexAfter).to.not.equal(debtIndexBefore);\n(0, chai_1.expect)(debtIndexAfter).to.be.bignumber.equal(await (0, calculations_1.calcDebtIndex)(this.krAsset, debtIndexBefore, lastUpdateTimestamp));",
                  "err": {},
                  "uuid": "f7a9ba86-e1df-4e4a-b778-691a6618fc25",
                  "parentUUID": "16bc7b5c-6aef-4a3b-bacf-621349a8ba6d",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct debt index after a year for amm price == oracle",
                  "fullTitle": "Stability Rates #debt-index calculates correct debt index after a year for amm price == oracle",
                  "timedOut": false,
                  "duration": 71,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst debtIndexBefore = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\nconst lastUpdateTimestamp = await (0, calculations_1.getBlockTimestamp)();\nawait hardhat_network_helpers_1.time.increase(+wadray_1.ONE_YEAR);\nconst debtIndexAfter = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndexAfter).to.not.equal(debtIndexBefore);\n(0, chai_1.expect)(debtIndexAfter).to.be.bignumber.equal(await (0, calculations_1.calcDebtIndex)(this.krAsset, debtIndexBefore, lastUpdateTimestamp));",
                  "err": {},
                  "uuid": "ace9e0e2-e9a1-4435-93fb-877131aab682",
                  "parentUUID": "16bc7b5c-6aef-4a3b-bacf-621349a8ba6d",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bb64c155-5dc3-486b-9982-e8f42087274f",
                "f7a9ba86-e1df-4e4a-b778-691a6618fc25",
                "ace9e0e2-e9a1-4435-93fb-877131aab682"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 527,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "c2ca4ccd-5837-4913-a921-8ebacffdac07",
          "title": "Stability Rates",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/02-debt.ts",
          "file": "/src/test/stability-rate/02-debt.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before all\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "6ffc0390-794e-4040-98c1-adc6ef95ece6",
              "parentUUID": "c2ca4ccd-5837-4913-a921-8ebacffdac07",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 21,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "1bd920ac-9dbb-4160-aa51-bc2ebf7874ad",
              "parentUUID": "c2ca4ccd-5837-4913-a921-8ebacffdac07",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 323,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();\nuserOne = users.deployer;\nuserTwo = users.userTwo;\nthis.krAsset = hardhat_1.default.krAssets.find(c => c.deployArgs.name === test_1.defaultKrAssetArgs.name);\nthis.collateral = hardhat_1.default.collaterals.find(c => c.deployArgs.name === test_1.defaultCollateralArgs.name);\n[UniMath] = await hardhat_1.default.deploy(\"UniswapMath\", {\n    from: users.deployer.address,\n    args: [hardhat_1.default.UniV2Factory.address, hardhat_1.default.UniV2Router.address],\n});\nconst krAssetOraclePrice = 10;\nthis.krAsset.setPrice(krAssetOraclePrice);\nconst cLiq = (0, numbers_1.toBig)(1000);\nconst kLiq = (0, numbers_1.toBig)(100);\nawait this.collateral.setBalance(userOne, cLiq.mul(2));\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: cLiq,\n    user: userOne,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: kLiq,\n    user: userOne,\n});\nconst anchorBalance = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(anchorBalance).to.equal(kLiq);\n// 1000/100 = krAsset amm price 10\nconst pair = await (0, amm_1.addLiquidity)({\n    user: userOne,\n    router: hardhat_1.default.UniV2Router,\n    amount0: cLiq,\n    amount1: kLiq,\n    token0: this.collateral,\n    token1: this.krAsset,\n});\nupdateTWAP = (0, amm_1.getTWAPUpdaterFor)(pair.address);\nawait hardhat_1.default.UniV2Oracle.initPair(pair.address, this.krAsset.address, 60 * 60);\nawait updateTWAP();",
              "err": {},
              "uuid": "16464f49-1e16-439e-a305-57d0f6e9d785",
              "parentUUID": "c2ca4ccd-5837-4913-a921-8ebacffdac07",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "1d97780f-9214-4fd8-beb0-fb26967a2bf2",
              "title": "#debt calculation - mint",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/02-debt.ts",
              "file": "/src/test/stability-rate/02-debt.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#debt calculation - mint\"",
                  "fullTitle": "Stability Rates #debt calculation - mint \"before each\" hook in \"#debt calculation - mint\"",
                  "timedOut": false,
                  "duration": 5,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);",
                  "err": {},
                  "uuid": "26b435bd-f6a8-45d9-bf6a-50bab0be01d8",
                  "parentUUID": "1d97780f-9214-4fd8-beb0-fb26967a2bf2",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct debt amount when amm price > oracle",
                  "fullTitle": "Stability Rates #debt calculation - mint calculates correct debt amount when amm price > oracle",
                  "timedOut": false,
                  "duration": 424,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 105; // 105% eg. 5% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));\nawait hardhat_network_helpers_1.time.increase(+calculations_1.ONE_YEAR);\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfterYear).to.not.bignumber.equal(debt);\n(0, chai_1.expect)(debtAfterYear).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));",
                  "err": {},
                  "uuid": "99fbc97b-a1f2-484f-bdab-4184d0681f41",
                  "parentUUID": "1d97780f-9214-4fd8-beb0-fb26967a2bf2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct debt amount when amm price < oracle",
                  "fullTitle": "Stability Rates #debt calculation - mint calculates correct debt amount when amm price < oracle",
                  "timedOut": false,
                  "duration": 398,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 95; // 95% eg. -5% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));\nawait hardhat_network_helpers_1.time.increase(+calculations_1.ONE_YEAR);\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfterYear).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));",
                  "err": {},
                  "uuid": "65753428-c0df-4af3-8d6f-bfe212af5dc8",
                  "parentUUID": "1d97780f-9214-4fd8-beb0-fb26967a2bf2",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct rate index after a year for amm price == oracle",
                  "fullTitle": "Stability Rates #debt calculation - mint calculates correct rate index after a year for amm price == oracle",
                  "timedOut": false,
                  "duration": 231,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));\nawait hardhat_network_helpers_1.time.increase(+calculations_1.ONE_YEAR);\nconst debtIndex = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndex.gt(wadray_1.oneRay)).to.be.true;\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfterYear).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));",
                  "err": {},
                  "uuid": "6dd3cffa-74a5-4293-97f0-2dc3d927f375",
                  "parentUUID": "1d97780f-9214-4fd8-beb0-fb26967a2bf2",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "99fbc97b-a1f2-484f-bdab-4184d0681f41",
                "65753428-c0df-4af3-8d6f-bfe212af5dc8",
                "6dd3cffa-74a5-4293-97f0-2dc3d927f375"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1053,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "e1118b23-ce3d-4af9-b537-81d1b7e94c55",
              "title": "#debt calculation - repay",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/02-debt.ts",
              "file": "/src/test/stability-rate/02-debt.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#debt calculation - repay\"",
                  "fullTitle": "Stability Rates #debt calculation - repay \"before each\" hook in \"#debt calculation - repay\"",
                  "timedOut": false,
                  "duration": 7,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);",
                  "err": {},
                  "uuid": "f43db18b-7453-44dd-9abe-3347a6fa9c8b",
                  "parentUUID": "e1118b23-ce3d-4af9-b537-81d1b7e94c55",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "calculates correct repay amount when amm price > oracle",
                  "fullTitle": "Stability Rates #debt calculation - repay calculates correct repay amount when amm price > oracle",
                  "timedOut": false,
                  "duration": 370,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 102; // 102% eg. 2% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait this.collateral.setBalance(userOne, amountIn);\n// buy asset, increases price\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.collateral.address, this.krAsset.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.equal(await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset));\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst principalBefore = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\nconst burnAmount = mintAmount.div(2);\nawait (0, krassets_1.burnKrAsset)({\n    asset: this.krAsset,\n    amount: burnAmount,\n    user: userTwo,\n});\nconst debtAfterBurn = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst principalAfter = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(principalAfter).to.equal(principalBefore.sub(burnAmount));\n(0, chai_1.expect)(debtAfterBurn).to.bignumber.closeTo(debtAfterYear.sub(burnAmount), hardhat_1.default.ethers.utils.parseUnits(\"10\", \"gwei\"));",
                  "err": {},
                  "uuid": "6d869855-80b2-43f4-8465-390b6fd3e28d",
                  "parentUUID": "e1118b23-ce3d-4af9-b537-81d1b7e94c55",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct repay amount when amm price > oracle",
                  "fullTitle": "Stability Rates #debt calculation - repay calculates correct repay amount when amm price > oracle",
                  "timedOut": false,
                  "duration": 448,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nconst premiumPercentage = 98; // 101% eg. 1% premium\nconst krAssetAmount = (0, numbers_1.toBig)(1);\nconst collateralAmount = (0, numbers_1.toBig)(10).div(100).mul(premiumPercentage);\nconst [amountIn] = await UniMath.profitMaximizingTrade(this.collateral.address, this.krAsset.address, collateralAmount, krAssetAmount);\nawait (0, krassets_1.mintKrAsset)({ user: userOne, asset: this.krAsset, amount: amountIn });\n// dump asset, decreases price\nawait (0, amm_1.swap)({\n    amount: amountIn,\n    route: [this.krAsset.address, this.collateral.address],\n    router: hardhat_1.default.UniV2Router,\n    user: userOne,\n});\nawait updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.closeTo(mintAmount, 10);\nconst year = 60 * 60 * 24 * 365;\nawait hardhat_network_helpers_1.time.increase(year);\nconst debtIndex = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndex.gt(wadray_1.oneRay)).to.be.true;\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst halfBalanceAfterYear = (await this.krAsset.contract.balanceOf(userTwo.address)).div(2);\nawait (0, krassets_1.burnKrAsset)({\n    asset: this.krAsset,\n    amount: halfBalanceAfterYear,\n    user: userTwo,\n});\nconst debtAfterBurn = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfterBurn).to.bignumber.closeTo(debtAfterYear.sub(halfBalanceAfterYear), wadray_1.oneRay.div(10000));",
                  "err": {},
                  "uuid": "15b59737-3d06-474e-a10f-6175bb5193ce",
                  "parentUUID": "e1118b23-ce3d-4af9-b537-81d1b7e94c55",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "calculates correct rate index after a year for amm price == oracle",
                  "fullTitle": "Stability Rates #debt calculation - repay calculates correct rate index after a year for amm price == oracle",
                  "timedOut": false,
                  "duration": 320,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await updateTWAP();\nawait hardhat_1.default.Diamond.updateStabilityRateAndIndexForAsset(this.krAsset.address);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.bignumber.closeTo(mintAmount, 10);\nconst year = 60 * 60 * 24 * 365;\nawait hardhat_network_helpers_1.time.increase(year);\nconst debtIndex = await hardhat_1.default.Diamond.getDebtIndexForAsset(this.krAsset.address);\n(0, chai_1.expect)(debtIndex.gt(wadray_1.oneRay)).to.be.true;\nconst debtAfterYear = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst halfBalanceAfterYear = (await this.krAsset.contract.balanceOf(userTwo.address)).div(2);\nawait (0, krassets_1.burnKrAsset)({\n    asset: this.krAsset,\n    amount: halfBalanceAfterYear,\n    user: userTwo,\n});\nconst debtAfterBurn = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debtAfterBurn).to.bignumber.closeTo(debtAfterYear.sub(halfBalanceAfterYear), wadray_1.oneRay.div(10000));",
                  "err": {},
                  "uuid": "1dafd669-057e-4a8b-8c07-a9d909c48b77",
                  "parentUUID": "e1118b23-ce3d-4af9-b537-81d1b7e94c55",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6d869855-80b2-43f4-8465-390b6fd3e28d",
                "15b59737-3d06-474e-a10f-6175bb5193ce",
                "1dafd669-057e-4a8b-8c07-a9d909c48b77"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1138,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            },
            {
              "uuid": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
              "title": "#debt calculation - repay interest",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/02-debt.ts",
              "file": "/src/test/stability-rate/02-debt.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#debt calculation - repay interest\"",
                  "fullTitle": "Stability Rates #debt calculation - repay interest \"before each\" hook in \"#debt calculation - repay interest\"",
                  "timedOut": false,
                  "duration": 6,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);",
                  "err": {},
                  "uuid": "177e446b-5818-4c97-894a-15b36c507376",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "can view account principal debt for asset",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can view account principal debt for asset",
                  "timedOut": false,
                  "duration": 705,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst expectedPrincipalDebt = mintAmount.mul(2);\nconst principalDebtAfterOneYear = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(principalDebtAfterOneYear).to.bignumber.equal(expectedPrincipalDebt);",
                  "err": {},
                  "uuid": "4cf354a7-32f8-4324-becb-078f641b416e",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can view account scaled debt for asset",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can view account scaled debt for asset",
                  "timedOut": false,
                  "duration": 244,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst principalDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\nconst accruedInterest = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\nconst expectedScaledDebt = principalDebt.add(accruedInterest.assetAmount);\nconst scaledDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(scaledDebt).to.bignumber.equal(expectedScaledDebt);",
                  "err": {},
                  "uuid": "f1409109-4e72-40ab-83a9-a497d1ca0f5a",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can view accrued interest in KISS",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can view accrued interest in KISS",
                  "timedOut": false,
                  "duration": 248,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nconst principalDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\nconst scaledDebt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst expectedValue = (await hardhat_1.default.Diamond.getKrAssetValue(this.krAsset.address, scaledDebt.sub(principalDebt), true)).rawValue;\nconst accruedInterest = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// 8 decimals\n(0, chai_1.expect)(accruedInterest.kissAmount).to.bignumber.equal(expectedValue.mul(10 ** 10));",
                  "err": {},
                  "uuid": "e6fcc2e0-d907-4db6-a973-32453c55c9c0",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can repay full interest with KISS",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can repay full interest with KISS",
                  "timedOut": false,
                  "duration": 290,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userTwo,\n});\n// get the principal before repayment\nconst principalDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\n// repay accrued interest\nawait hardhat_1.default.Diamond.connect(userTwo).repayFullStabilityRateInterest(userTwo.address, this.krAsset.address);\n// get values after repayment\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst accruedInterest = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(accruedInterest.assetAmount).to.bignumber.eq(0);\n(0, chai_1.expect)(debt).to.bignumber.eq(principalDebt);",
                  "err": {},
                  "uuid": "bc1131f5-0e29-4a08-b172-18567a725593",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can repay partial interest with KISS",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can repay partial interest with KISS",
                  "timedOut": false,
                  "duration": 353,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userTwo,\n});\nconst accruedInterestBefore = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// get the principal before repayment\nconst debtBefore = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst repaymentAmount = accruedInterestBefore.kissAmount.div(5);\nconst repaymentAmountAsset = accruedInterestBefore.assetAmount.div(5);\n// repay accrued interest\nawait hardhat_1.default.Diamond.connect(userTwo).repayStabilityRateInterestPartial(userTwo.address, this.krAsset.address, repaymentAmount);\n// get values after repayment\nconst debtAfter = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\nconst accruedInterestAfter = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// TODO: calc exact values instead of closeTo\n(0, chai_1.expect)(accruedInterestAfter.kissAmount).to.be.closeTo(accruedInterestBefore.kissAmount.sub(repaymentAmount), RATE_DELTA);\n(0, chai_1.expect)(debtAfter).to.be.closeTo(debtBefore.sub(repaymentAmountAsset), RATE_DELTA);",
                  "err": {},
                  "uuid": "927c11a6-2799-4ac2-9933-0b57c1134617",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can repay all interest for multiple assets in batch",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can repay all interest for multiple assets in batch",
                  "timedOut": false,
                  "duration": 7720,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait this.collateral.setBalance(userTwo, depositAmountBig);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmountBig,\n    user: userTwo,\n});\n// Create few krAssets\nconst krAssets = await Promise.all([\"krasset2\", \"krasset3\", \"krasset4\"].map(async (name) => await (0, krassets_1.addMockKreskoAsset)({\n    name: name,\n    symbol: name,\n    marketOpen: true,\n    factor: 1,\n    closeFee: 0,\n    openFee: 0,\n    price: 10,\n    supplyLimit: 2000,\n    stabilityRateBase: test_1.BASIS_POINT.mul(1000), // 10%\n})));\n// mint small amount of each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmountSmall,\n    user: userTwo,\n})));\nconst totalInterestInKISSBefore = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n// increase time\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst interestAccrued = await Promise.all(krAssets.map(asset => hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, asset.address)));\nconst expectedKissAmount = interestAccrued.reduce((a, c) => a.add(c.kissAmount), ethers_1.BigNumber.from(0));\nconst totalInterestInKISSAfter = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n(0, chai_1.expect)(totalInterestInKISSBefore.lt(totalInterestInKISSAfter)).to.be.true;\n(0, chai_1.expect)(totalInterestInKISSAfter).to.bignumber.equal(expectedKissAmount);\nconst KISSMinAmount = (0, numbers_1.toBig)(10);\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: KISSMinAmount,\n    user: userTwo,\n});\nawait hardhat_1.default.Diamond.connect(userTwo).batchRepayFullStabilityRateInterest(userTwo.address);\nconst totalInterestInKISSAfterRepay = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n(0, chai_1.expect)(totalInterestInKISSAfterRepay).to.equal(0);",
                  "err": {},
                  "uuid": "845f8c02-48bb-47c2-8b44-8138ba7132ec",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can repay all interest and principal for a single asset",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can repay all interest and principal for a single asset",
                  "timedOut": false,
                  "duration": 475,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst accruedInterestBeforeBurn = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// repay accrued interest\nawait hardhat_1.default.Diamond.connect(userTwo).burnKreskoAsset(userTwo.address, this.krAsset.address, hardhat_1.default.ethers.constants.MaxUint256, 0);\nconst accruedInterestAfterBurn = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// Ensure burning does not wipe interest accrued\n(0, chai_1.expect)(accruedInterestAfterBurn.assetAmount.gt(accruedInterestBeforeBurn.assetAmount)).to.be.true;\n(0, chai_1.expect)(accruedInterestAfterBurn.kissAmount.gt(accruedInterestBeforeBurn.kissAmount)).to.be.true;\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore.length).to.equal(2);\nawait hardhat_1.default.Diamond.connect(userTwo).repayFullStabilityRateInterest(userTwo.address, this.krAsset.address);\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter.length).to.equal(1);\nconst accruedInterestAfterRepayment = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\nconst principalDebt = await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address);\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n// Ensure debt actually gets wiped\n(0, chai_1.expect)(principalDebt).to.equal(0);\n(0, chai_1.expect)(accruedInterestAfterRepayment.assetAmount).to.equal(0);\n(0, chai_1.expect)(accruedInterestAfterRepayment.kissAmount).to.equal(0);\n(0, chai_1.expect)(debt).to.equal(0);\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst accruedInterestYearAfterRepayment = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n// Sanity check with another year of time that there is no interest accrual\n(0, chai_1.expect)(accruedInterestYearAfterRepayment.assetAmount).to.equal(0);\n(0, chai_1.expect)(accruedInterestYearAfterRepayment.kissAmount).to.equal(0);\n// Get kr asset value, should be only KISS minted that remains\nconst krAssetValue = (await hardhat_1.default.Diamond.getAccountKrAssetValue(userTwo.address)).rawValue;\n(0, chai_1.expect)(krAssetValue).to.equal((0, numbers_1.toBig)(10, 8));",
                  "err": {},
                  "uuid": "b52c52db-e4ae-4470-b769-89f7f25c69d2",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can batch repay interest and all debt",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can batch repay interest and all debt",
                  "timedOut": false,
                  "duration": 6924,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait this.collateral.setBalance(userTwo, depositAmountBig);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmountBig,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userTwo,\n});\n// Create few krAssets\nconst krAssets = await Promise.all([\"krasset2\", \"krasset3\", \"krasset4\"].map(async (name) => await (0, krassets_1.addMockKreskoAsset)({\n    name: name,\n    symbol: name,\n    marketOpen: true,\n    factor: 1,\n    closeFee: 0,\n    openFee: 0,\n    price: 10,\n    supplyLimit: 2000,\n    stabilityRateBase: test_1.BASIS_POINT.mul(1000), // 10%\n})));\n// mint small amount of each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmountSmall,\n    user: userTwo,\n})));\nconst totalInterestInKISSBefore = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n// increase time\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst interestAccrued = await Promise.all(krAssets.map(asset => hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, asset.address)));\nconst expectedKissAmount = interestAccrued.reduce((a, c) => a.add(c.kissAmount), ethers_1.BigNumber.from(0));\nconst totalInterestInKISSAfter = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n(0, chai_1.expect)(totalInterestInKISSBefore.lt(totalInterestInKISSAfter)).to.be.true;\n(0, chai_1.expect)(totalInterestInKISSAfter).to.bignumber.equal(expectedKissAmount);\nawait Promise.all(krAssets.map(async (asset) => hardhat_1.default.Diamond.connect(userTwo).burnKreskoAsset(userTwo.address, asset.address, hardhat_1.default.ethers.constants.MaxUint256, await hardhat_1.default.Diamond.getMintedKreskoAssetsIndex(userTwo.address, asset.address))));\nconst mintedKreskoAssetsBefore = await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address);\n(0, chai_1.expect)(mintedKreskoAssetsBefore.length).to.equal(4);\nawait hardhat_1.default.Diamond.connect(userTwo).batchRepayFullStabilityRateInterest(userTwo.address);\nconst totalInterestInKISSAfterRepay = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n(0, chai_1.expect)(totalInterestInKISSAfterRepay).to.equal(0);\nconst mintedKreskoAssetsAfter = await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address);\n(0, chai_1.expect)(mintedKreskoAssetsAfter.length).to.equal(1);",
                  "err": {},
                  "uuid": "8e0226d6-0ef8-40f5-af05-cb3f1318656a",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can open up a new debt positions after wiping all debt + interest",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can open up a new debt positions after wiping all debt + interest",
                  "timedOut": false,
                  "duration": 869,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst expectedDebtAfterOneYear = await (0, calculations_1.toScaledAmountUser)(userTwo, mintAmount, this.krAsset);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.eq(expectedDebtAfterOneYear);\n// Wipe debt\nawait hardhat_1.default.Diamond.connect(userTwo).burnKreskoAsset(userTwo.address, this.krAsset.address, hardhat_1.default.ethers.constants.MaxUint256, 0);\nconst accruedInterest = (await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address))\n    .assetAmount;\n// Mint again, before interest repayment\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\n// Ensure debt is principal + interest\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.closeTo(mintAmount.add(accruedInterest), RATE_DELTA);\n// Burn all assets\nawait hardhat_1.default.Diamond.connect(userTwo).burnKreskoAsset(userTwo.address, this.krAsset.address, hardhat_1.default.ethers.constants.MaxUint256, 0);\n// Ensure debt is equal to interest\nconst accruedInterestAfterBurn = (await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address)).assetAmount;\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.eq(accruedInterestAfterBurn);\n// Repay all interest\nawait hardhat_1.default.Diamond.connect(userTwo).repayFullStabilityRateInterest(userTwo.address, this.krAsset.address);\n// Debt should be wiped\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.eq(0);\n// Mint again\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\n// Scaled should be equal to principal\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.eq(mintAmount);\n// Advance time\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\n// Ensure accrual is the same as the previous year with the same position\nconst debt = await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(debt).to.eq(expectedDebtAfterOneYear);",
                  "err": {},
                  "uuid": "6de8f913-e903-4244-8b45-abd88fe0321b",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can fully close a position in single transaction using the helper function",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can fully close a position in single transaction using the helper function",
                  "timedOut": false,
                  "duration": 428,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nconst minDebtAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: minDebtAmount,\n    user: userOne,\n});\nawait KISS.connect(userOne).transfer(userTwo.address, minDebtAmount);\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: mintAmount,\n    user: userTwo,\n});\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nawait hardhat_1.default.Diamond.connect(userTwo).closeKrAssetDebtPosition(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebt(userTwo.address, this.krAsset.address)).to.eq(0);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.kreskoAssetDebtPrincipal(userTwo.address, this.krAsset.address)).to.eq(0);\nconst accruedInterest = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, this.krAsset.address);\n(0, chai_1.expect)(accruedInterest.assetAmount).to.eq(0);\n(0, chai_1.expect)(accruedInterest.kissAmount).to.eq(0);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address)).length).to.eq(0);",
                  "err": {},
                  "uuid": "7b2d14a2-b74e-4526-8970-822f86850302",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can fully close all positions and interest in single transaction using the helper function",
                  "fullTitle": "Stability Rates #debt calculation - repay interest can fully close all positions and interest in single transaction using the helper function",
                  "timedOut": false,
                  "duration": 7080,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(userTwo).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nconst kissAmount = (await hardhat_1.default.Diamond.minimumDebtValue()).rawValue.mul(10 ** 10).mul(2);\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: kissAmount,\n    user: userOne,\n});\nawait KISS.connect(userOne).transfer(userTwo.address, kissAmount);\nconst krAssets = await Promise.all([\"krasset2\", \"krasset3\", \"krasset4\"].map(async (name) => await (0, krassets_1.addMockKreskoAsset)({\n    name: name,\n    symbol: name,\n    marketOpen: true,\n    factor: 1,\n    closeFee: 0,\n    openFee: 0,\n    price: 10,\n    supplyLimit: 2000,\n    stabilityRateBase: test_1.BASIS_POINT.mul(1000), // 10%\n})));\n// mint small amount of each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmountSmall,\n    user: userTwo,\n})));\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\n// ~1M gas with 8 krAssets\n// console.log(+(await tx.wait()).gasUsed);\nawait hardhat_1.default.Diamond.connect(userTwo).batchCloseKrAssetDebtPositions(userTwo.address);\nconst accruedInterest = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n(0, chai_1.expect)(accruedInterest).to.eq(0);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.getAccountKrAssetValue(userTwo.address)).rawValue).to.eq(0);\n(0, chai_1.expect)((await hardhat_1.default.Diamond.getMintedKreskoAssets(userTwo.address)).length).to.eq(0);",
                  "err": {},
                  "uuid": "8ff29e8f-0da9-496d-bbe9-2dbcf8ad6684",
                  "parentUUID": "e5ce4cc9-8daf-4de3-a7b5-c1229ec6fb56",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "4cf354a7-32f8-4324-becb-078f641b416e",
                "f1409109-4e72-40ab-83a9-a497d1ca0f5a",
                "e6fcc2e0-d907-4db6-a973-32453c55c9c0",
                "bc1131f5-0e29-4a08-b172-18567a725593",
                "927c11a6-2799-4ac2-9933-0b57c1134617",
                "845f8c02-48bb-47c2-8b44-8138ba7132ec",
                "b52c52db-e4ae-4470-b769-89f7f25c69d2",
                "8e0226d6-0ef8-40f5-af05-cb3f1318656a",
                "6de8f913-e903-4244-8b45-abd88fe0321b",
                "7b2d14a2-b74e-4526-8970-822f86850302",
                "8ff29e8f-0da9-496d-bbe9-2dbcf8ad6684"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 25336,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        },
        {
          "uuid": "a622bdac-2225-45ef-8b08-1a603d3b60df",
          "title": "Stability Rates",
          "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/03-liquidation.ts",
          "file": "/src/test/stability-rate/03-liquidation.ts",
          "beforeHooks": [
            {
              "title": "\"before all\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before all\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "if (currentFixtureName && fixtureName.join(\"\") !== currentFixtureName.join(\"\")) {\n    hardhat_1.default.collaterals = [];\n    hardhat_1.default.krAssets = [];\n    hardhat_1.default.allAssets = [];\n    hardhat_1.default.Diamond = undefined;\n}\ncurrentFixtureName = fixtureName;",
              "err": {},
              "uuid": "d8356514-2003-4b30-bb66-a1f67318b8d7",
              "parentUUID": "a622bdac-2225-45ef-8b08-1a603d3b60df",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 24,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fixture = await hardhat_1.deployments.createFixture(async (hre) => {\n    const result = await hardhat_1.deployments.fixture(fixtureName);\n    if (result.Diamond) {\n        hre.Diamond = await hardhat_1.ethers.getContractAt(\"Kresko\", result.Diamond.address);\n    }\n    return {\n        facets: result.Diamond ? result.Diamond.facets : [],\n        collaterals: hre.collaterals,\n        krAssets: hre.krAssets,\n    };\n})();\nthis.facets = fixture.facets;\nthis.collaterals = fixture.collaterals;\nthis.krAssets = fixture.krAssets;",
              "err": {},
              "uuid": "e0b640bf-9f8f-4762-9197-7fb7f0599b22",
              "parentUUID": "a622bdac-2225-45ef-8b08-1a603d3b60df",
              "isHook": true,
              "skipped": false
            },
            {
              "title": "\"before each\" hook in \"Stability Rates\"",
              "fullTitle": "Stability Rates \"before each\" hook in \"Stability Rates\"",
              "timedOut": false,
              "duration": 405,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "users = await hardhat_1.default.getUsers();\nliquidator = users.deployer;\nuserTwo = users.userTwo;\nthis.krAsset = hardhat_1.default.krAssets.find(c => c.deployArgs.name === test_1.defaultKrAssetArgs.name);\nthis.collateral = hardhat_1.default.collaterals.find(c => c.deployArgs.name === test_1.defaultCollateralArgs.name);\nconst krAssetOraclePrice = 10;\nthis.krAsset.setPrice(krAssetOraclePrice);\nconst cLiq = (0, numbers_1.toBig)(1000);\nconst kLiq = (0, numbers_1.toBig)(100);\nawait this.collateral.setBalance(liquidator, cLiq.mul(2));\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: cLiq,\n    user: liquidator,\n});\nawait (0, krassets_1.mintKrAsset)({\n    asset: this.krAsset,\n    amount: kLiq,\n    user: liquidator,\n});\nconst anchorBalance = await this.krAsset.anchor.balanceOf(hardhat_1.default.Diamond.address);\n(0, chai_1.expect)(anchorBalance).to.equal(kLiq);\n// 1000/100 = krAsset amm price 10\nconst pair = await (0, amm_1.addLiquidity)({\n    user: liquidator,\n    router: hardhat_1.default.UniV2Router,\n    amount0: cLiq,\n    amount1: kLiq,\n    token0: this.collateral,\n    token1: this.krAsset,\n});\nupdateTWAP = (0, amm_1.getTWAPUpdaterFor)(pair.address);\nawait hardhat_1.default.UniV2Oracle.initPair(pair.address, this.krAsset.address, 60 * 60);\nawait updateTWAP();",
              "err": {},
              "uuid": "8fd7bff2-594a-4428-bba9-884194751180",
              "parentUUID": "a622bdac-2225-45ef-8b08-1a603d3b60df",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "71e83842-f0e8-4350-b3ce-b45663242724",
              "title": "#stability rate - liquidation",
              "fullFile": "/Users/pk/Projects/kresko-protocol/src/test/stability-rate/03-liquidation.ts",
              "file": "/src/test/stability-rate/03-liquidation.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"#stability rate - liquidation\"",
                  "fullTitle": "Stability Rates #stability rate - liquidation \"before each\" hook in \"#stability rate - liquidation\"",
                  "timedOut": false,
                  "duration": 6841,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);\n// Create few krAssets\nkrAssets = await Promise.all([\"krasset2\", \"krasset3\", \"krasset4\"].map(async (name) => await (0, krassets_1.addMockKreskoAsset)({\n    name: name,\n    symbol: name,\n    marketOpen: true,\n    factor: 1.1,\n    closeFee: 0,\n    openFee: 0,\n    price: 10,\n    supplyLimit: 2000,\n    stabilityRateBase: test_1.BASIS_POINT.mul(1000), // 10%\n})));",
                  "err": {},
                  "uuid": "ff924529-a06c-48e7-bfec-9b3c331e781e",
                  "parentUUID": "71e83842-f0e8-4350-b3ce-b45663242724",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "cannot liquidate accrued interest of healthy account",
                  "fullTitle": "Stability Rates #stability rate - liquidation cannot liquidate accrued interest of healthy account",
                  "timedOut": false,
                  "duration": 569,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\n// mint each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmount,\n    user: userTwo,\n})));\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\nconst krAsset = krAssets[0];\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.false;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(liquidator).liquidateInterest(userTwo.address, krAsset.address, this.collateral.address)).to.be.revertedWith(errors_1.Error.NOT_LIQUIDATABLE);",
                  "err": {},
                  "uuid": "aa0312e4-597a-49d6-a015-e7b491584144",
                  "parentUUID": "71e83842-f0e8-4350-b3ce-b45663242724",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "cannot batch liquidate accrued interest of healthy account",
                  "fullTitle": "Stability Rates #stability rate - liquidation cannot batch liquidate accrued interest of healthy account",
                  "timedOut": false,
                  "duration": 607,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await this.collateral.setBalance(userTwo, depositAmount);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\n// mint each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmount,\n    user: userTwo,\n})));\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR);\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.false;\nawait (0, chai_1.expect)(hardhat_1.default.Diamond.connect(liquidator).batchLiquidateInterest(userTwo.address, this.collateral.address)).to.be.revertedWith(errors_1.Error.NOT_LIQUIDATABLE);",
                  "err": {},
                  "uuid": "36222bb3-4a7d-4b4e-92c3-6853073dbdfe",
                  "parentUUID": "71e83842-f0e8-4350-b3ce-b45663242724",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can liquidate accrued interest of unhealthy account",
                  "fullTitle": "Stability Rates #stability rate - liquidation can liquidate accrued interest of unhealthy account",
                  "timedOut": false,
                  "duration": 1228,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(liquidator).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait this.collateral.setBalance(userTwo, depositAmount);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\n// mint each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmount,\n    user: userTwo,\n})));\n// Up the asset prices\nconst newPrice = 15;\nkrAssets.map(asset => asset.setPrice(newPrice));\n// increase time so account is liquidatable\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.false;\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR * 4);\n// should be liquidatable\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.true;\n// Asset to liquidate\nconst krAsset = krAssets[0];\nconst interestUSDTotal = await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address);\n// Liquidator mints KISS\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: interestUSDTotal.add((0, numbers_1.toBig)(1)),\n    user: liquidator,\n});\n// liquidatable value total before\nconst accruedKissInterest = (0, hardhat_1.fromBig)((await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, krAsset.address)).kissAmount);\nconst accountCollateralBefore = await hardhat_1.default.Diamond.collateralDeposits(userTwo.address, this.collateral.address);\n// Wipe seized collateral balance before liquidation for easy comparison\nawait this.collateral.setBalance(liquidator, (0, numbers_1.toBig)(0));\n// Liquidate\nconst tx = await hardhat_1.default.Diamond.connect(liquidator).liquidateInterest(userTwo.address, krAsset.address, this.collateral.address);\n// Should all be wiped\nconst interestAccruedAfterLiq = await hardhat_1.default.Diamond.kreskoAssetDebtInterest(userTwo.address, krAsset.address);\n(0, chai_1.expect)(interestAccruedAfterLiq.kissAmount).to.eq(0);\n(0, chai_1.expect)(interestAccruedAfterLiq.assetAmount).to.eq(0);\nconst accountCollateralAfter = await hardhat_1.default.Diamond.collateralDeposits(userTwo.address, this.collateral.address);\nconst event = await (0, lib_1.getInternalEvent)(tx, (0, events_1.EventContract)(), \"InterestLiquidationOccurred\");\n// validate interest accrual changes\n(0, chai_1.expect)(accountCollateralAfter).to.equal(accountCollateralBefore.sub(event.collateralSent));\nconst liquidationIncentive = (0, hardhat_1.fromBig)((await hardhat_1.default.Diamond.liquidationIncentiveMultiplier()).rawValue);\nconst expectedCollateral = (accruedKissInterest / (0, hardhat_1.fromBig)(await this.collateral.getPrice(), 8)) * liquidationIncentive;\n// event validation\n(0, chai_1.expect)(event.account).to.equal(userTwo.address);\n(0, chai_1.expect)(event.liquidator).to.equal(liquidator.address);\n(0, chai_1.expect)(event.repayKreskoAsset).to.equal(krAsset.address);\n(0, chai_1.expect)(event.seizedCollateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)((0, hardhat_1.fromBig)(event.collateralSent).toFixed(6)).to.equal(expectedCollateral.toFixed(6));\n(0, chai_1.expect)((0, hardhat_1.fromBig)(event.repayUSD)).to.closeTo(accruedKissInterest, 0.0001);\n// liquidator received collateral\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(liquidator.address)).to.equal(event.collateralSent);",
                  "err": {},
                  "uuid": "37236af2-3936-434c-91ab-7869796002f2",
                  "parentUUID": "71e83842-f0e8-4350-b3ce-b45663242724",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "can batch liquidate accrued interest of unhealthy account",
                  "fullTitle": "Stability Rates #stability rate - liquidation can batch liquidate accrued interest of unhealthy account",
                  "timedOut": false,
                  "duration": 1841,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const KISS = await hardhat_1.default.ethers.getContract(\"KISS\");\nawait KISS.connect(liquidator).approve(hardhat_1.default.Diamond.address, hardhat_1.default.ethers.constants.MaxUint256);\nawait this.collateral.setBalance(userTwo, depositAmount);\n// Deposit a bit more to cover the mints\nawait (0, collaterals_1.depositCollateral)({\n    asset: this.collateral,\n    amount: depositAmount,\n    user: userTwo,\n});\n// mint each krasset\nawait Promise.all(krAssets.map(krAsset => (0, krassets_1.mintKrAsset)({\n    asset: krAsset,\n    amount: mintAmount,\n    user: userTwo,\n})));\n// Up the asset prices\nconst newPrice = 15;\nkrAssets.map(asset => asset.setPrice(newPrice));\n// increase time so account is liquidatable\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.false;\nawait hardhat_network_helpers_1.time.increase(calculations_1.ONE_YEAR * 4);\n// should be liquidatable\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.true;\nconst interestKissTotal = (0, hardhat_1.fromBig)(await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address));\n// Liquidator mints KISS\nawait (0, krassets_1.mintKrAsset)({\n    asset: KISS,\n    amount: interestKissTotal + 1,\n    user: liquidator,\n});\n// Wipe seized collateral balance before liquidation for easy comparison\nawait this.collateral.setBalance(liquidator, (0, numbers_1.toBig)(0));\n// Liquidate\nconst tx = await hardhat_1.default.Diamond.connect(liquidator).batchLiquidateInterest(userTwo.address, this.collateral.address);\nconst interestKissTotalAfter = (0, hardhat_1.fromBig)(await hardhat_1.default.Diamond.kreskoAssetDebtInterestTotal(userTwo.address));\n(0, chai_1.expect)(await hardhat_1.default.Diamond.isAccountLiquidatable(userTwo.address)).to.be.false;\nconst event = await (0, lib_1.getInternalEvent)(tx, (0, events_1.EventContract)(), \"BatchInterestLiquidationOccurred\");\nconst repayUSD = (0, hardhat_1.fromBig)(event.repayUSD);\n// interest accrued changes\n(0, chai_1.expect)(interestKissTotalAfter).to.closeTo(interestKissTotal - (0, hardhat_1.fromBig)(event.repayUSD), 0.0001);\nconst liquidationIncentive = (0, hardhat_1.fromBig)((await hardhat_1.default.Diamond.liquidationIncentiveMultiplier()).rawValue);\nconst expectedCollateral = (repayUSD / (0, hardhat_1.fromBig)(await this.collateral.getPrice(), 8)) * liquidationIncentive;\n// event validation\n(0, chai_1.expect)(event.account).to.equal(userTwo.address);\n(0, chai_1.expect)(event.liquidator).to.equal(liquidator.address);\n(0, chai_1.expect)(event.seizedCollateralAsset).to.equal(this.collateral.address);\n(0, chai_1.expect)((0, hardhat_1.fromBig)(event.collateralSent)).to.closeTo(expectedCollateral, 0.0001);\n(0, chai_1.expect)(repayUSD).to.closeTo(interestKissTotal - interestKissTotalAfter, 0.0001);\n// liquidator received collateral\n(0, chai_1.expect)(await this.collateral.contract.balanceOf(liquidator.address)).to.equal(event.collateralSent);",
                  "err": {},
                  "uuid": "9d02f187-bbe5-46fb-a892-f94fc57d8d87",
                  "parentUUID": "71e83842-f0e8-4350-b3ce-b45663242724",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "aa0312e4-597a-49d6-a015-e7b491584144",
                "36222bb3-4a7d-4b4e-92c3-6853073dbdfe",
                "37236af2-3936-434c-91ab-7869796002f2",
                "9d02f187-bbe5-46fb-a892-f94fc57d8d87"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 4245,
              "root": false,
              "rootEmpty": false,
              "_timeout": 15000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 15000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 15000
    }
  ],
  "meta": {
    "mocha": {
      "version": "10.1.0"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": null,
      "version": "6.2.0"
    }
  }
}